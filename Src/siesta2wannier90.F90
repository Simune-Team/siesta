module m_siesta2wannier90

  use precision, only : dp
  use parallel,  only : IOnode, Node, Nodes
  use parallelsubswan,  only : GetNodeProjs
  use sys,       only : die
  use TrialOrbitalClass

  real(dp) :: latvec(3,3)    ! Real lattice vectors.
                             !   Cartesian coordinates. 
                             !   Readed in Angstroms and transformed to Bohr
                             !   internally
                             !   First  index: vector
                             !   Second index: component
  real(dp) :: reclatvec(3,3) ! Reciprocal lattice vectors.
                             !   Cartesian coordinates. 
                             !   Readed in Angstroms^-1 and transformed 
                             !   to Bohr^-1 internally
                             !   First  index: vector
                             !   Second index: component
!
! Variables related with the k-point list for which the overlap
! matrices Mmn between a k-point and its neighbor will be computed
!
  integer  :: numkpoints     ! Total number of k-points
  real(dp), pointer :: kpointsfrac(:,:) 
                             ! List of k points relative
                             !   to the reciprocal lattice vectors.
                             !   First  index: component
                             !   Second index: k-point index in the list
  real(dp), pointer :: bvectorsfrac(:,:)
                             ! The vectors b that connect each mesh-point k
                             !   to its nearest neighbours
!
! Variables related with the projections with trial functions,
! initial approximations to the MLWF
!
  integer  :: numproj        ! Total number of projection centers,
                             !   equal to the number of MLWF
  type(trialorbital), target, allocatable  :: projections(:)       
!
! Variables related with the neighbours of the k-points
!
  integer           :: nncount  
                             ! The number of nearest neighbours belonging to 
                             !   each k-point of the Monkhorst-Pack mesh
  integer, pointer  :: nnlist(:,:)
                             ! nnlist(ikp,inn) is the index of the 
                             !   inn-neighbour of ikp-point
                             !   in the Monkhorst-Pack grid folded to the 
                             !   first Brillouin zone
  integer, pointer  :: nnfolding(:,:,:)
! integer nnfolding(:,:,:)   ! nnfolding(i,ikp,inn) is the i-component 
                             !   of the reciprocal lattice vector 
                             !   (in reduced units) that brings
                             !   the inn-neighbour specified in nnlist
                             !   (which is in the first BZ) to the
                             !   actual \vec{k} + \vec{b} that we need.
                             !   In reciprocal lattice units.
!
! Variables related with the excluded bands
!
  integer          :: numexcluded 
                             ! Number of states to exclude from the calculation
                             !   of the overlap and projection matrices.
  integer, pointer :: excludedbands(:)
                             ! States to be excluded
!
! Variables related with the number of bands considered for wannierization
!
  integer          :: numbands(2) ! Number of bands for wannierization

CONTAINS

subroutine siesta2wannier90

  use m_spin,        only: nspin         ! Number of spin components
  use files,         only: slabel        ! Short system label, 
                                         !   used to generate file names
  use files,         only: label_length  ! Number of characters in slabel
  use m_digest_nnkp, only: read_nnkp     ! Subroutine that reads the .nnkp file
  use m_digest_nnkp, only: chosing_b_vectors ! Subroutine that computes the b
                                         ! vectors that connect each mesh 
                                         ! k-point to its nearest neighbours.
  use m_digest_nnkp, only: number_bands_wannier ! Subroutine that computes the
                                         ! number of bands for wannierization

  implicit none

  integer                    :: ispin    ! Spin counter
  integer                    :: numbandswan(2)
                                         ! Number of bands for wannierization
  character(label_length+3)  :: seedname ! Name of the file where the Wannier90
                                         !   code, when used as a postprocessing
                                         !   tool, dumps the information.

! For debugging
  integer  i, j, numproj_l
! End debugging

  external  :: timer, mmn

  call timer("siesta2wannier90",1)

  do ispin = 1, nspin
!   Append _up or _dn to the seedname if spin polarized
    seedname = trim(getFileNameRoot(ispin,nspin,slabel))
!   A priori, the .nnkp file generated by Wannier90 used as a 
!   postprocessing tool is independent of spin.
!   However, they provide examples (example08, bulk Fe) where
!   two different .nnkp files are generated, 
!   one for each component of the spin.
!   This inspired us to read the .nnkp file for each component of the spin
!   (note that the seedname will be different in every case).
!   The information is read only by the master node,
!   and broadcast to the rest of the nodes later. 
    if (IOnode) then
       write(6,'(/,a)')  &
 &       'siesta2wannier90: Reading the ' // trim(seedname) // '.nnkp file'
    endif
    call read_nnkp( seedname, latvec, reclatvec, numkpoints,          &
                    kpointsfrac, nncount, nnlist, nnfolding,          &
                    numproj, projections, numexcluded, excludedbands  )

!   Compute the vectors that connect each mesh k-point to its nearest neighbours
    call chosing_b_vectors( kpointsfrac, nncount, nnlist, nnfolding, &
                            bvectorsfrac )

!   Compute the number of bands for wannierization
    call number_bands_wannier( numbandswan )
    numbands(ispin) = numbandswan(ispin)

!   Compute the matrix elements of the plane wave,
!   for all the wave vectors that connect a given k-point to its nearest
!   neighbours
    call compute_pw_matrix( nncount, bvectorsfrac )

    call mmn( ispin )

!   Compute the projections on the trial functions
    call amn( ispin )

!!   For debugging
!    write(6,*)' Node, Nodes, numproj_l = ', Node, Nodes, numproj_l
!!   End debugging


!   Compute the vectors that connect each mesh k-point to its nearest neighbours
!! For debugging
!      if( Node .eq. 1 ) then
!        do i = 1, 3
!          write(6,'(a,3f12.5)')' latvec        = ', (latvec(i,j), j = 1, 3) 
!        enddo
!
!        do i = 1, 3
!          write(6,'(a,3f12.5)')' reclatvec     = ', (reclatvec(i,j), j = 1, 3) 
!        enddo
!
!        write(6,'(a,i5)')      ' numkpoints    = ', numkpoints
!        do i = 1, numkpoints
!          write(6,'(a,i5,3f12.5)') &
! &          ' kpointsfrac   = ', i,(kpointsfrac(j,i), j=1,3) 
!        enddo
!
!        write(6,'(a,i5)')      ' numproj    = ', numproj
!        do i = 1, numproj
!          write(6,'(a,i5,3f12.5)')' center = ', i, projections(i)%center
!          write(6,'(a,i5,3f12.5)')' zaxis  = ', i, projections(i)%zaxis
!          write(6,'(a,i5,3f12.5)')' xaxis  = ', i, projections(i)%xaxis
!          write(6,'(a,i5,f12.5)') ' zovera = ', i, projections(i)%zovera
!          write(6,'(a,2i5)')      ' r      = ', i, projections(i)%r
!          write(6,'(a,2i5)')      ' l      = ', i, projections(i)%l
!          write(6,'(a,2i5)')      ' mr     = ', i, projections(i)%mr
!          write(6,'(a,i5,f12.5)') ' rcut   = ', i, projections(i)%rcut
!          write(6,'(a,2i5)')      ' lmax   = ', i, projections(i)%lmax
!        enddo
!
!        write(6,'(a,i5)')      ' nncount       = ', nncount
!        do i = 1, numkpoints
!          write(6,*) ' nnlist       = ', i, (nnlist(i,j), j = 1, nncount) 
!        enddo
!        do i = 1, numkpoints
!          do j = 1, nncount
!            write(6,*) ' nnfolding    = ', i, nnlist(i,j), nnfolding(:,i,j)
!          enddo 
!        enddo
!
!        write(6,'(a,i5)')      ' numexcluded   = ', numexcluded
!        do i = 1, numexcluded
!          write(6,'(a,2i5)')   ' excludedbands = ', i, excludedbands(i)
!        enddo 
!
!        do i = 1, nncount
!          write(6,'(a,i5,3f12.5)') &
! &          ' bvectorsfrac  = ', i,(bvectorsfrac(j,i), j=1,3) 
!        enddo
!      endif
!! End debugging
  enddo

  call timer("siesta2wannier90",2)

end subroutine siesta2wannier90

function getFileNameRoot(ispin,nspin,root)
!
! Constructs filenames for various cases of spin:
! Nonpolarized, down and up by adding an extension to
! "root". Behavior:
! (a) unpolarized: no change
! (b) spin up: _up suffix
! (c) spin down: _dn suffix
!
  character(*),intent(in)      :: root
  integer,intent(in)           :: ispin, nspin
  character(len_trim(root)+3)  :: getFileNameRoot

  select case (nspin)
!   If only one spin component, do nothing
    case (1) 
      getFileNameRoot = trim(root)
!   If two spin components, 
!   append "_up" (for the first one) or "_dn" (for the second spin component)
!   to the seed name
    case (2) 
      select case (ispin)
         case (1)
           getFileNameRoot = trim(root)//"_up"
         case (2)
           getFileNameRoot = trim(root)//"_dn"
      end select 
!   If more than two spin components, stop the program 
!   and print and error message
    case default 
      call die("getFileNameRoot: non-collinear spin not implemented yet")
  end select 
end function getFileNameRoot

endmodule m_siesta2wannier90
