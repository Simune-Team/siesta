! this class aims to implement a tri-diagonal matrix
! The memory layout is almost equivalent to that of regular fortran
! arrays, i.e.:
!  1. the first diagonal block
!  2. the 1st lower triangular block
!  3. the 1st upper triangular block
!  4. the second diagonal block
!  5. the 2st lower triangular block
!  6. the 2st upper triangular block
!  7. the third diagonal block
!

  use alloc, only: re_alloc, de_alloc

  implicit none

  character(len=*), parameter :: mod_name="class_"//STR_TYPE_NAME//".F90"

  integer, parameter :: sp = selected_real_kind(5,10)
  integer, parameter :: dp = selected_real_kind(10,100)

  type TYPE_NAME_
     integer :: refCount = 0
     character(len=36)   :: id = "null_id"
     !----------------------
     character(len=256)  :: name = "null "//STR_TYPE_NAME
     ! The number of rows of the full matrix
     integer             :: nrows_g
     ! The number of rows of the left tri-diagonal part
     integer             :: left
     ! The number of rows of the center tri-diagonal part
     integer             :: center
     ! The number of rows of the right tri-diagonal part
     integer             :: right
#ifdef PREC
     VAR_TYPE(PREC), pointer :: mat(:) => null() ! matrix values
#else
     VAR_TYPE,       pointer :: mat(:) => null() ! matrix values
#endif
  end type

  type TYPE_NAME
     type(TYPE_NAME_), pointer :: data => null()
  end type

! Note that "basic_type.inc" adds the PRIVATE directive
! This will also release the requirement to change the local names.
! Only those through public statements should potentially be altered.

  public :: NEW_TYPE, print_type, init_val

  public :: val, val11, val21, val12, val22, val32, val23, val33
  public :: index
  public :: nrows_g
  public :: nrows_g_left, nrows_g_center, nrows_g_right

  interface NEW_TYPE
     module procedure newTriMat3fromDimensions
  end interface

  interface nrows_g
     module procedure nrows_gTriMat
  end interface
  interface nrows_g_left
     module procedure nleft_gTriMat
  end interface
  interface nrows_g_center
     module procedure ncenter_gTriMat
  end interface
  interface nrows_g_right
     module procedure nright_gTriMat
  end interface

  interface index
     module procedure index_TriMat3
  end interface

  interface init_val
     module procedure initializeTriMat3
  end interface

  interface val
     module procedure val_TriMat3
  end interface

  interface val11
     module procedure val11_TriMat3
  end interface
  interface val21
     module procedure val21_TriMat3
  end interface
  interface val12
     module procedure val12_TriMat3
  end interface
  interface val22
     module procedure val22_TriMat3
  end interface
  interface val32
     module procedure val32_TriMat3
  end interface
  interface val23
     module procedure val23_TriMat3
  end interface
  interface val33
     module procedure val33_TriMat3
  end interface

  interface print_type
     module procedure printTriMat3
  end interface

!========================
#include "basic_type.inc"
!========================

  subroutine delete_Data(trimat_data)
    type(TYPE_NAME_) :: trimat_data
    if (associated(trimat_data%mat)) then
       call de_alloc( trimat_data%mat, &
            name="val "//trim(trimat_data%name),routine=STR_TYPE_NAME)	
    endif
  end subroutine delete_Data

  pure function nrows_gTriMat(this) result (n)
    type(TYPE_NAME), intent(in) :: this
    integer                     :: n
    n = this%data%nrows_g
  end function nrows_gTriMat
  pure function nleft_gTriMat(this) result (n)
    type(TYPE_NAME), intent(in) :: this
    integer                     :: n
    n = this%data%left
  end function nleft_gTriMat
  pure function ncenter_gTriMat(this) result (n)
    type(TYPE_NAME), intent(in) :: this
    integer                     :: n
    n = this%data%center
  end function ncenter_gTriMat
  pure function nright_gTriMat(this) result (n)
    type(TYPE_NAME), intent(in) :: this
    integer                     :: n
    n = this%data%right
  end function nright_gTriMat
  
  subroutine newTriMat3FromDimensions(this,left,center,right,name)
    ! This could be implemented also as an assignment 
    ! (see below)

    type(TYPE_NAME), intent(inout)  :: this
    integer, intent(in)           :: left, center, right
    character(len=*), intent(in), optional  :: name

    integer :: n
    integer :: stat

    ! We release the previous incarnation
    ! This means that we relinquish access to the previous
    ! memory location. It will be deallocated when nobody
    ! else is using it.
   
    call init(this)

    if (present(name)) then
       this%data%name = trim(name)
    else
       this%data%name = "("//STR_TYPE_NAME//")"
    endif

    ! Calculate number of rows
    this%data%nrows_g = left + center + right

    ! Save the dimensions
    this%data%left   = left
    this%data%center = center
    this%data%right  = right

    ! Calculate size of the tri-diagonal matrix
    n =     (left + center        ) * left   ! first column
    n = n + (left + center + right) * center ! second column
    n = n + (       center + right) * right  ! last column

    call re_alloc(this%data%mat,1,n, &
         name="mat "//trim(this%data%name),routine=STR_TYPE_NAME) 

    call tag_new_object(this)

  end subroutine newTriMat3FromDimensions

  function val_TriMat3(this) result(p)
    type(TYPE_NAME), intent(in) :: this
#ifdef PREC
    VAR_TYPE(PREC), pointer     :: p(:) !=> null()
#else
    VAR_TYPE,       pointer     :: p(:) !=> null()
#endif
    
    p => this%data%mat
  end function val_TriMat3

  function val11_TriMat3(this) result(p)
    type(TYPE_NAME), intent(in) :: this
#ifdef PREC
    VAR_TYPE(PREC), pointer     :: p(:) !=> null()
#else
    VAR_TYPE,       pointer     :: p(:) !=> null()
#endif
    integer :: s,e
    s = 1
    e = s + this%data%left*this%data%left - 1
    p => this%data%mat(s:e)
  end function val11_TriMat3

  function val21_TriMat3(this) result(p)
    type(TYPE_NAME), intent(in) :: this
#ifdef PREC
    VAR_TYPE(PREC), pointer     :: p(:) !=> null()
#else
    VAR_TYPE,       pointer     :: p(:) !=> null()
#endif
    integer :: s,e
    s = 1 + this%data%left*this%data%left
    e = s + this%data%center*this%data%left - 1
    p => this%data%mat(s:e)
  end function val21_TriMat3

  function val12_TriMat3(this) result(p)
    type(TYPE_NAME), intent(in) :: this
#ifdef PREC
    VAR_TYPE(PREC), pointer     :: p(:) !=> null()
#else
    VAR_TYPE,       pointer     :: p(:) !=> null()
#endif
    integer :: s,e
    s = 1 + this%data%left*this%data%left
    s = s + this%data%center*this%data%left
    e = s + this%data%left*this%data%center - 1
    p => this%data%mat(s:e)
  end function val12_TriMat3

  function val22_TriMat3(this) result(p)
    type(TYPE_NAME), intent(in) :: this
#ifdef PREC
    VAR_TYPE(PREC), pointer     :: p(:) !=> null()
#else
    VAR_TYPE,       pointer     :: p(:) !=> null()
#endif
    integer :: s,e
    s = 1 + this%data%left*this%data%left
    s = s + this%data%center*this%data%left
    s = s + this%data%left*this%data%center
    e = s + this%data%center*this%data%center - 1
    p => this%data%mat(s:e)
  end function val22_TriMat3

  function val32_TriMat3(this) result(p)
    type(TYPE_NAME), intent(in) :: this
#ifdef PREC
    VAR_TYPE(PREC), pointer     :: p(:) !=> null()
#else
    VAR_TYPE,       pointer     :: p(:) !=> null()
#endif
    integer :: s,e
    s = 1 + this%data%left*this%data%left
    s = s + this%data%center*this%data%left
    s = s + this%data%left*this%data%center
    s = s + this%data%center*this%data%center
    e = s + this%data%right*this%data%center - 1
    p => this%data%mat(s:e)
  end function val32_TriMat3

  function val23_TriMat3(this) result(p)
    type(TYPE_NAME), intent(in) :: this
#ifdef PREC
    VAR_TYPE(PREC), pointer     :: p(:) !=> null()
#else
    VAR_TYPE,       pointer     :: p(:) !=> null()
#endif
    integer :: s,e
    s = 1 + this%data%left*this%data%left
    s = s + this%data%center*this%data%left
    s = s + this%data%left*this%data%center
    s = s + this%data%center*this%data%center
    s = s + this%data%right*this%data%center
    e = s + this%data%center*this%data%right - 1
    p => this%data%mat(s:e)
  end function val23_TriMat3

  function val33_TriMat3(this) result(p)
    type(TYPE_NAME), intent(in) :: this
#ifdef PREC
    VAR_TYPE(PREC), pointer     :: p(:) !=> null()
#else
    VAR_TYPE,       pointer     :: p(:) !=> null()
#endif
    integer :: s,e
    s = 1 + this%data%left*this%data%left
    s = s + this%data%center*this%data%left
    s = s + this%data%left*this%data%center
    s = s + this%data%center*this%data%center
    s = s + this%data%right*this%data%center
    s = s + this%data%center*this%data%right
    e = s + this%data%right*this%data%right - 1
    p => this%data%mat(s:e)
  end function val33_TriMat3

! we return -1 if the index does not exist
  pure function index_TriMat3(this,r,c) result(n)
    type(TYPE_NAME), intent(in) :: this
    ! The row and column requested
    integer, intent(in) :: r, c
    integer :: n, sub
    
    if ( c <= this%data%left ) then
       ! We are in the first column
       if ( r <= this%data%left ) then
          ! We are in m11
          n = this%data%left*(c-1)+r
          return
       else if ( r <= this%data%left + this%data%center ) then
          ! We must be in m21
          n = this%data%left**2+this%data%center*(c-1)+r &
	       - this%data%left
          return
       else
          n = 0
	  return
       end if
    else if ( c <= this%data%left + this%data%center ) then
       sub = this%data%left
       ! We are in the middle column
       n = (this%data%left+this%data%center)*this%data%left
       if ( r <= this%data%left ) then
          ! We are in m12
          n = n + this%data%left*(c-sub-1)+r
          return
       else if ( r <= this%data%left + this%data%center ) then
          ! We are in m22
          n = n + this%data%left*this%data%center &
                + this%data%center*(c-sub-1)+r &
		- sub
          return
       else 
          ! We are in m32
          n = n + (this%data%left+this%data%center)*this%data%center &
                + this%data%right*(c-sub-1)+r &
		- sub - this%data%center
          return
       end if
    else
       sub = this%data%left + this%data%center
       ! We are in the last column
       n = (this%data%left+this%data%center)*this%data%left + &
            (this%data%left+this%data%center+this%data%right) &
            * this%data%center
       if ( r <= this%data%left ) then
          n = 0
	  return
       else if ( r <= this%data%left + this%data%center ) then
          ! We are in m23
          n = n + this%data%center*(c-sub-1)+r &
                - this%data%left
          return
       else 
          ! We are in m33
          n = n + this%data%center*this%data%right &
                + this%data%right*(c-sub-1)+r &
                - sub
          return
       end if
    end if
  end function index_TriMat3
       



  subroutine printTriMat3(this)
    type(TYPE_NAME), intent(in)  :: this
    
    if (.not. associated(this%data)) then
       print "(a)", STR_TYPE_NAME//" Not Associated"
       RETURN
    endif
    
    print "(5(a,i0),a)", "  <"//STR_TYPE_NAME//":" // trim(this%data%name) // &
                                " L=",  this%data%left, &
                                " C=",  this%data%center, &
                                " R=",  this%data%right, &
                                " elements=",  size(this%data%mat), &
                                ", refcount: ", refcount(this),">"
  end subroutine printTriMat3

  subroutine initializeTriMat3(this)
    type(TYPE_NAME), intent(in out) :: this
#ifdef PREC
    VAR_TYPE(PREC), pointer     :: p(:) !=> null()
#else
    VAR_TYPE,       pointer     :: p(:) !=> null()
#endif
    
    p => val(this)
    p(:) = VAR_INIT

  end subroutine initializeTriMat3


#undef TYPE_NAME
#undef STR_TYPE_NAME
#undef TYPE_NAME_
#undef NEW_TYPE
#undef VAR_TYPE
#ifdef PREC
#undef PREC
#endif
#undef VAR_INIT