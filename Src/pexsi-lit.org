#+TITLE: Literate version of PEXSI driver
#+AUTHOR: Alberto Garcia

* Introduction


* Auxiliary module for holding the plan

The /plan/ feature allows, among other things, the re-use of
factorization information. 

#+BEGIN_SRC f90 :noweb yes :tangle m_pexsi.f90
  module m_pexsi
  use precision, only: dp
  use iso_c_binding

  integer(c_intptr_t), public :: plan

  public :: pexsi_initialize_scfloop
  public :: pexsi_finalize_scfloop

  private

  CONTAINS

    <<initialize-scf-loop>>
    <<finalize-scf-loop>>
    <<get-optimal-row-col>>

end module m_pexsi

#+END_SRC

#+BEGIN_SRC f90 :noweb-ref initialize-scf-loop
subroutine pexsi_initialize_scfloop(World_Comm,npPerPole,mpirank)
  use f_ppexsi_interface
  integer, intent(in) :: npPerPole, mpirank
  integer, intent(in) :: World_Comm

  integer :: numProcRow, numProcCol
  integer :: outputFileIndex, info

  call get_row_col(npPerPole,numProcRow,numProcCol)

  ! Set the outputFileIndex to be the pole index.
  ! Starting from PEXSI v0.8.0, the first processor for each pole outputs
  ! information

  if( mod( mpirank, npPerPole ) .eq. 0 ) then
    outputFileIndex = mpirank / npPerPole;
  else
    outputFileIndex = -1;
  endif

  plan = f_ppexsi_plan_initialize(&
    World_Comm,&
    numProcRow,&
    numProcCol,&
    outputFileIndex,&
    info) 

  if (mpirank == 0) then
    print *, "Info in plan_initialize: ", info
  endif
end subroutine pexsi_initialize_scfloop

#+END_SRC

#+BEGIN_SRC f90 :noweb-ref finalize-scf-loop

subroutine pexsi_finalize_scfloop() ! mpirank)
  use f_ppexsi_interface
  !  integer, intent(in) :: mpirank

  integer :: info

  call f_ppexsi_plan_finalize( plan, info )

  !  if (mpirank == 0) then
  !     print *, "Info in plan_finalize: ", info
  !  endif
end subroutine pexsi_finalize_scfloop
#+END_SRC

#+BEGIN_SRC f90 :noweb-ref get-optimal-row-col

subroutine get_row_col(np,nrow,ncol)
  integer, intent(in)  :: np
  integer, intent(out) :: nrow, ncol
  !
  ! Finds the factors nrow and ncol such that nrow*ncol=np,
  ! are as similar as possible, and nrow>=ncol.
  ! For prime np, ncol=1, nrow=np.

  ncol  = floor(sqrt(dble(np)))
  do
    nrow = np/ncol
    if (nrow*ncol == np) exit
    ncol = ncol - 1
  enddo
end subroutine get_row_col
#+END_SRC


* The pexsi_solver code

This is the main structure of the code. 

#+begin_src f90 :noweb-ref code-structure
module m_pexsi_solver
 use precision, only  : dp

 implicit none

 public :: pexsi_solver

 real(dp), save :: prevDmax  ! For communication of max diff in DM in scf loop
                             ! used in the heuristics for N_el tolerance
 public :: prevDmax

CONTAINS

<<routine-header>>
!
<<routine-variables>>
!
#ifndef MPI
    call die("PEXSI needs MPI")
#else
<<define-communicators>>
<<re-distribute-matrices>>

<<set-tolerance>>
<<broadcast-and-temperature>>

<<initialize-plan-at-first-step>>
<<set-options>>

<<load-hs-matrices>>
<<factorization>>

<<call-driver>>
<<get-matrices-and-energy>>
<<copy-to-siesta-side>>

<<clean-up>>
#endif

CONTAINS
    
<<support-routines>>

end subroutine pexsi_solver
end module m_pexsi_solver
#+end_src

#+BEGIN_SRC f90 :noweb yes :tangle m_pexsi_driver.F90 :exports none
    ! Tangled code
    <<code-structure>>
    ! End of tangled code
#+END_SRC

** Routine header

#+BEGIN_SRC  f90 :noweb-ref routine-header
! This version uses separate distributions for Siesta 
! (setup_H et al) and PEXSI.
! It uses the simple KSDFT driver
!
  subroutine pexsi_solver(iscf, no_u, no_l, nspin,  &
       maxnh, numh, listhptr, listh, H, S, qtot, DM, EDM, &
       ef, Entropy, temp, delta_Ef)

    use fdf
    use parallel, only   : SIESTA_worker, BlockSize
    use parallel, only   : SIESTA_Group, SIESTA_Comm
    use m_mpi_utils, only: globalize_sum, globalize_max
    use m_mpi_utils, only: broadcast
    use units,       only: Kelvin, eV
    use m_redist_spmatrix, only: aux_matrix, redistribute_spmatrix
    use class_Dist
    use alloc,             only: re_alloc, de_alloc
    use siesta_options,    only: dDtol
#ifdef MPI
    use mpi_siesta
#endif
use f_ppexsi_interface
use iso_c_binding
use m_pexsi, only: plan, pexsi_initialize_scfloop

#ifdef TRACING_SOLVEONLY
      use extrae_module
#endif

    implicit          none

    integer, intent(in)  :: iscf  ! scf step number
    integer, intent(in)  :: maxnh, no_u, no_l, nspin
    integer, intent(in), target  :: listh(maxnh), numh(no_l), listhptr(no_l)
    real(dp), intent(in), target :: H(maxnh,nspin), S(maxnh)
    real(dp), intent(in) :: qtot
    real(dp), intent(out), target:: DM(maxnh,nspin), EDM(maxnh,nspin)
    real(dp), intent(out)        :: ef  ! Fermi energy
    real(dp), intent(out)        :: Entropy ! Entropy/k, dimensionless
    real(dp), intent(in)         :: temp   ! Electronic temperature
    real(dp), intent(in)         :: delta_Ef  ! Estimated shift in E_fermi
#+END_SRC

** Routine variables
#+BEGIN_SRC f90 :noweb-ref routine-variables
type(f_ppexsi_options) :: options

integer :: numTotalPEXSIIter
integer :: numTotalInertiaIter
real(dp) :: totalEnergyH
real(dp) :: totalEnergyS
real(dp) :: totalFreeEnergy


    integer :: PEXSI_Comm, World_Comm
    integer :: PEXSI_Group, World_Group

    integer :: ispin, maxnhtot, ih, nnzold, i, pexsiFlag

    real(dp), save :: muMin0, muMax0, mu
    real(dp), save :: muMinInertia, muMaxInertia
    real(dp), save :: previous_pexsi_temperature
    logical, save  :: first_call = .true.

    real(dp)       :: bs_energy, eBandH, on_the_fly_tolerance

    integer        :: info
    integer        :: verbosity
    logical        :: write_ok

!Lin variables
integer :: nrows, nnz, nnzLocal, numColLocal
integer, pointer, dimension(:) ::  colptrLocal=> null(), rowindLocal=>null()
!
real(dp), pointer, dimension(:) :: &
        HnzvalLocal=>null(), SnzvalLocal=>null(),  &
        DMnzvalLocal => null() , EDMnzvalLocal => null(), &
        FDMnzvalLocal => null()
!
logical  :: PEXSI_worker
real(dp) :: temperature, numElectronExact, numElectron
integer  :: npPerPole
integer  :: mpirank, mpisize, ierr
integer  :: isSIdentity

real(dp) :: pexsi_temperature, two_kT

real(dp) :: PEXSINumElectronToleranceMin, &
            PEXSINumElectronToleranceMax, &
            PEXSINumElectronTolerance
real(dp) :: free_bs_energy

!------------

external         :: timer

type(aux_matrix) :: m1, m2
type(Dist)       :: dist1, dist2
integer          :: pbs, norbs, scf_step
#+END_SRC


** Define communicators

#+BEGIN_SRC f90 :noweb-ref define-communicators
! "SIESTA_Worker" means a processor which is in the Siesta subset.
! NOTE:  fdf calls will assign values to the whole processor set,
! but some other variables will have to be re-broadcast (see examples
! below)

World_Comm = true_MPI_Comm_World

if (SIESTA_worker) then
   ! deal with intent(in) variables
   norbs = no_u
   scf_step = iscf
endif
call broadcast(norbs,comm=World_Comm)
call broadcast(scf_step,comm=World_Comm)
call broadcast(prevDmax,comm=World_Comm)
call broadcast(dDtol,comm=World_Comm)

!  Find rank in global communicator
call mpi_comm_rank( World_Comm, mpirank, ierr )
call mpi_comm_size( World_Comm, mpisize, ierr )

call newDistribution(BlockSize,SIESTA_Group,dist1,TYPE_BLOCK_CYCLIC,"bc dist")

! Group and Communicator for first-pole team of PEXSI workers
!
npPerPole  = fdf_get("PEXSI.np-per-pole",4)
if (npPerPole > mpisize) call die("PEXSI.np-per-pole is too big for MPI size")

call MPI_Comm_Group(World_Comm, World_Group, Ierr)
call MPI_Group_incl(World_Group, npPerPole,   &
                    (/ (i,i=0,npPerPole-1) /),&
                    PEXSI_Group, Ierr)
call MPI_Comm_create(World_Comm, PEXSI_Group,&
                     PEXSI_Comm, Ierr)

PEXSI_worker = (mpirank < npPerPole)

pbs = norbs/npPerPole
call newDistribution(pbs,PEXSI_Group,dist2,TYPE_PEXSI,"px dist")

#+END_SRC



** Re-distribute matrices

#+BEGIN_SRC f90 :noweb-ref re-distribute-matrices


if (SIESTA_worker) then
   call timer("pexsi", 1)

   ispin = 1
   if (nspin /=1) then
      call die("Spin polarization not yet supported in PEXSI")
   endif

   numElectronExact = qtot 

   ! Note that the energy units for the PEXSI interface are arbitrary, but
   ! H, the interval limits, and the temperature have to be in the
   ! same units. Siesta uses Ry units.

   temperature      = temp

   if (mpirank==0) write(6,"(a,f10.2)") &
               "Electronic temperature (K): ", temperature/Kelvin

   m1%norbs = norbs
   m1%no_l  = no_l
   m1%nnzl  = sum(numH(1:no_l))
   m1%numcols => numH
   m1%cols    => listH
   allocate(m1%vals(2))
   m1%vals(1)%data => S(:)
   m1%vals(2)%data => H(:,ispin)

endif  ! SIESTA_worker

call timer("redist_orbs_fwd", 1)
call redistribute_spmatrix(norbs,m1,dist1,m2,dist2,World_Comm)
call timer("redist_orbs_fwd", 2)

if (PEXSI_worker) then

   nrows = m2%norbs          ! or simply 'norbs'
   numColLocal = m2%no_l
   nnzLocal    = m2%nnzl
   call MPI_AllReduce(nnzLocal,nnz,1,MPI_integer,MPI_sum,PEXSI_Comm,ierr)

  call re_alloc(colptrLocal,1,numColLocal+1,"colptrLocal","pexsi_solver")
  colptrLocal(1) = 1
  do ih = 1,numColLocal
     colptrLocal(ih+1) = colptrLocal(ih) + m2%numcols(ih)
  enddo

  rowindLocal => m2%cols
  SnzvalLocal => m2%vals(1)%data
  HnzvalLocal => m2%vals(2)%data

  call re_alloc(DMnzvalLocal,1,nnzLocal,"DMnzvalLocal","pexsi_solver")
  call re_alloc(EDMnzvalLocal,1,nnzLocal,"EDMnzvalLocal","pexsi_solver")
  call re_alloc(FDMnzvalLocal,1,nnzLocal,"FDMnzvalLocal","pexsi_solver")

  call memory_all("after setting up H+S for PEXSI (PEXSI_workers)",PEXSI_comm)

endif ! PEXSI worker

call memory_all("after setting up H+S for PEXSI",World_comm)

#+END_SRC
** Set options

We use the options interface to get a template with default values,
and then fill in a few custom options based on fdf variables.

#+BEGIN_SRC f90 :noweb-ref set-options
    
    !@declare type(f_ppexsi_options) :: options
    
    !
    call f_ppexsi_set_default_options( options )

    options%muPEXSISafeGuard = fdf_get("PEXSI.mu-pexsi-safeguard",0.05_dp,"Ry")
    options%maxPEXSIIter = fdf_get("PEXSI.mu-max-iter",10)

    isSIdentity = 0

    options%numPole  = fdf_get("PEXSI.num-poles",40)
    options%gap      = fdf_get("PEXSI.gap",0.0_dp,"Ry")

    ! deltaE is in theory the spectrum width, but in practice can be much smaller
    ! than | E_max - mu |.  It is found that deltaE that is slightly bigger
    ! than  | E_min - mu | is usually good enough.

    options%deltaE     = fdf_get("PEXSI.delta-E",3.0_dp,"Ry") ! Lin: 10 Ry...

    ! Ordering flag:
    !   1: Use METIS
    !   0: Use PARMETIS/PTSCOTCH
    options%ordering = fdf_get("PEXSI.ordering",1)

    ! Number of processors for symbolic factorization
    ! Only relevant for PARMETIS/PT_SCOTCH
    options%npSymbFact = fdf_get("PEXSI.np-symbfact",1)

    verbosity = fdf_get("PEXSI.verbosity",1)
    options%verbosity = verbosity

    options%temperature = pexsi_temperature
    options%numElectronPEXSITolerance = PEXSINumElectronTolerance
#+END_SRC


** Load H and S matrices

In this version H and S are symmetric. We associate them with the plan
(I really do not know very well what happens behind the
scenes. Presumably no copy is made.)

#+BEGIN_SRC f90 :noweb-ref load-hs-matrices
call f_ppexsi_load_real_symmetric_hs_matrix(&
      plan,&
      options,&
      nrows,&
      nnz,&
      nnzLocal,&
      numColLocal,&
      colptrLocal,&
      rowindLocal,&
      HnzvalLocal,&
      isSIdentity,&
      SnzvalLocal,&
      info) 

call check_info(info,"load_real_sym_hs_matrix")

#+END_SRC




** Set tolerance 

These are wrapped in a test for =first_call=. Some other operations
could be done in that case.

#+BEGIN_SRC f90 :noweb-ref set-tolerance
  if (first_call) then

  ! Initial guess of chemical potential and containing interval
  ! When using inertia counts, this interval can be wide.
  ! Note that mu, muMin0 and muMax0 are saved variables

     muMin0           = fdf_get("PEXSI.mu-min",-1.0_dp,"Ry")
     muMax0           = fdf_get("PEXSI.mu-max", 0.0_dp,"Ry")
     mu               = fdf_get("PEXSI.mu",-0.60_dp,"Ry")

     PEXSINumElectronToleranceMin =  &
           fdf_get("PEXSI.num-electron-tolerance-lower-bound",0.01_dp)
     PEXSINumElectronToleranceMax =  &
           fdf_get("PEXSI.num-electron-tolerance-upper-bound",0.5_dp)

     ! start with largest tolerance
     ! (except if overriden by user)
     PEXSINumElectronTolerance = fdf_get("PEXSI.num-electron-tolerance",&
                                         PEXSINumElectronToleranceMax)
     first_call = .false.
  else
  !
  !  Here we could also check whether we are in the first scf iteration
  !  of a multi-geometry run...
  !
     ! Use a moving tolerance, based on how far DM_out was to DM_in
     ! in the previous iteration (except if overriden by user)

     call get_on_the_fly_tolerance(prevDmax,on_the_fly_tolerance)

     ! Override if tolerance is explicitly specified in the fdf file
     PEXSINumElectronTolerance =  fdf_get("PEXSI.num-electron-tolerance",&
                                          on_the_fly_tolerance)
  endif
#+END_SRC

** Broadcast and temperature

#+BEGIN_SRC f90 :noweb-ref broadcast-and-temperature

  !-----------------------------------------------------------------------------

  !
  ! Broadcast these to the whole processor set, just in case
  ! (They were set only by the Siesta workers)
  !
  call MPI_Bcast(nrows,1,MPI_integer,0,World_Comm,ierr)
  call MPI_Bcast(nnz,1,MPI_integer,0,World_Comm,ierr)
  call MPI_Bcast(numElectronExact,1,MPI_double_precision,0,World_Comm,ierr)
  call MPI_Bcast(temperature,1,MPI_double_precision,0,World_Comm,ierr)
  call MPI_Bcast(delta_Ef,1,MPI_double_precision,0,World_Comm,ierr)
  !
  call get_current_temperature(pexsi_temperature)
  !
  !  Set guard smearing for later use
  !
  two_kT = 2.0_dp * pexsi_temperature
#+END_SRC

** Initialize plan at first scf step
#+BEGIN_SRC f90 :noweb-ref initialize-plan-at-first-step

  !  New interface.
  if (iscf == 1) then
     call pexsi_initialize_scfloop(World_Comm,npPerPole,mpirank)
  endif


#+END_SRC
** Factorization

This is only done at the beginning of the scf cycle.

#+BEGIN_SRC f90 :noweb-ref factorization

  if (iscf == 1) then
     ! This is only needed for inertia-counting
     call f_ppexsi_symbolic_factorize_real_symmetric_matrix(&
          plan, &
          options,&
          info)
     call check_info(info,"symbolic_factorize_real_symmetric_matrix")

     call f_ppexsi_symbolic_factorize_complex_symmetric_matrix(&
          plan, &
          options,&
          info)
     call check_info(info,"symbolic_factorize_complex_symmetric_matrix")
  endif
  options%isSymbolicFactorize = 0 ! We do not need it anymore
#+END_SRC


** Set up options and call the simple driver

This is too black of a black box, as there is very little control
of the operations. The most glaring shortcoming is the lack of a
proper handling of the convergence conditions.

#+BEGIN_SRC f90 :noweb-ref call-driver

  !
  !  do actual solve
  !
  call timer("pexsi-solver", 1)

  if (need_inertia_counting()) then
     options%isInertiaCount = 1
     ! Stop inertia count if mu has not changed much from iteration to iteration.
     options%muInertiaTolerance =  &
               fdf_get("PEXSI.inertia-mu-tolerance",0.05_dp,"Ry")
     ! One-sided expansion of interval if correct mu falls outside it
     options%muInertiaExpansion =  &
               fdf_get("PEXSI.lateral-expansion-inertia",3.0_dp*eV,"Ry") 

     call get_bracket_for_inertia_count( )  
     options%muMin0 = muMin0
     options%muMax0 = muMax0
     if (mpirank == 0) then
       write (6,"(a,2f9.4,a)") 'Calling inertiaCount: [', &
                                        muMin0/eV, muMax0/eV, "] (eV)"
     endif

  else
     ! Will call the PEXSI solver directly
     options%isInertiaCount = 0
     call get_bracket_for_solver()
     options%muMin0 = muMin0
     options%muMax0 = muMax0
     options%mu0       = mu
     if(mpirank == 0) then
       write (6,"(a,2f9.4,a,f9.4,a,f9.5)") 'Calling solver directly (eV): [', &
                                        muMin0/eV, &
                                        muMax0/eV, &
                                       "] prev. mu: ", mu/eV, &
                                       ' Tol: ', PEXSINumElectronTolerance
     endif

  endif
        
  call f_ppexsi_dft_driver(&
    plan,&
    options,&    ! includes muMin0, muMax0
    numElectronExact,& ! in
    mu,&             ! out
    numElectron,&    ! out
    muMinInertia,&   ! out
    muMaxInertia,&   ! out
    numTotalInertiaIter,&  ! out
    numTotalPEXSIIter,&    ! out
    info)

  call check_info(info,"dft_driver")

  if (abs(numElectron-numElectronExact) > PEXSINumElectronTolerance) then
     ! Might take another go, but for now just warn the user and rely on
     ! the normalization of the DM to try to get the calculation going...
     if(mpirank == 0) then
        write(6,*) "PEXSI solver did not converge. DM normalization might work"
     endif
  endif
#+END_SRC

** Get output matrices and compute energies

This section is still done by the PEXSI group processors

#+BEGIN_SRC f90 :noweb-ref get-matrices-and-energy

  if( PEXSI_worker ) then
    call f_ppexsi_retrieve_real_symmetric_dft_matrix(&
      plan,&
      DMnzvalLocal,&
      EDMnzvalLocal,&
      FDMnzvalLocal,&
      totalEnergyH,&
      totalEnergyS,&
      totalFreeEnergy,&
      info)
    call check_info(info,"retrieve_real_symmetric_dft_matrix")

  endif

  call timer("pexsi-solver", 2)

  !------------ End of solver step

  if ((mpirank == 0) .and. (verbosity >= 1)) then
    write(6,"(a,i3)") " #&s Number of solver iterations: ", numTotalPEXSIIter
    write(6,"(a,i3)") " #&s Number of inertia iterations: ", numTotalInertiaIter
    write(6,"(a,f12.4)") " #&s muMinInertia: ", muMinInertia
    write(6,"(a,f12.4)") " #&s muMaxInertia: ", muMaxInertia
    write(6,"(a,f12.5,f12.4,2x,a2)") "mu, N_e:", mu/eV, &
                                      numElectron, "&s"
  endif

  if (PEXSI_worker) then

     free_bs_energy = totalFreeEnergy
     bs_energy = totalEnergyS
     eBandH = totalEnergyH

     if ((mpirank == 0) .and. (verbosity >= 2)) then
        write(6, "(a,f12.4)") "#&s Tr(S*EDM) (eV) = ", bs_energy/eV
        write(6,"(a,f12.4)") "#&s Tr(H*DM) (eV) = ", eBandH/eV
        write(6,"(a,f12.4)") "#&s Tr(S*FDM) (eV) = ", (free_bs_energy)/eV
     endif

     ef = mu
     ! Note that we use the S*EDM version of the band-structure energy
     ! to estimate the entropy, by comparing it to S*FDM This looks
     ! consistent, but note that the EDM is not used in Siesta to
     ! estimate the total energy, only the DM (via the density) (that
     ! is, the XC and Hartree correction terms to Ebs going into Etot
     ! are estimated using the DM)

     Entropy = - (free_bs_energy - bs_energy) / temp

  endif ! PEXSI_worker

#+END_SRC

** Copy information to Siesta side

#+BEGIN_SRC f90 :noweb-ref copy-to-siesta-side

  if (PEXSI_worker) then
     ! Prepare m2 to transfer

     call de_alloc(FDMnzvalLocal,"FDMnzvalLocal","pexsi_solver")
     call de_alloc(colPtrLocal,"colPtrLocal","pexsi_solver")

     call de_alloc(m2%vals(1)%data,"m2%vals(1)%data","pexsi_solver")
     call de_alloc(m2%vals(2)%data,"m2%vals(2)%data","pexsi_solver")

     m2%vals(1)%data => DMnzvalLocal(1:nnzLocal)
     m2%vals(2)%data => EDMnzvalLocal(1:nnzLocal)
     
  endif

  ! Prepare m1 to receive the results
  if (SIESTA_worker) then
     nullify(m1%vals(1)%data)    ! formerly pointing to S
     nullify(m1%vals(2)%data)    ! formerly pointing to H
     deallocate(m1%vals)
     nullify(m1%numcols)         ! formerly pointing to numH
     nullify(m1%cols)            ! formerly pointing to listH
  endif

  call timer("redist_orbs_bck", 1)
  call redistribute_spmatrix(norbs,m2,dist2,m1,dist1,World_Comm)
  call timer("redist_orbs_bck", 2)

  if (PEXSI_worker) then
     call de_alloc(DMnzvalLocal, "DMnzvalLocal", "pexsi_solver")
     call de_alloc(EDMnzvalLocal,"EDMnzvalLocal","pexsi_solver")

     nullify(m2%vals(1)%data)    ! formerly pointing to DM
     nullify(m2%vals(2)%data)    ! formerly pointing to EDM
     deallocate(m2%vals)
      ! allocated in the direct transfer
     call de_alloc(m2%numcols,"m2%numcols","pexsi_solver")
     call de_alloc(m2%cols,   "m2%cols",   "pexsi_solver")
  endif

  ! We assume that the root node is common to both communicators
  if (SIESTA_worker) then
     call broadcast(ef,comm=SIESTA_Comm)
     call broadcast(Entropy,comm=SIESTA_Comm)
     ! In future, m1%vals(1,2) could be pointing to DM and EDM,
     ! and the 'redistribute' routine check whether the vals arrays are
     ! associated, to use them instead of allocating them.
     DM(:,ispin)  = m1%vals(1)%data(:)    
     EDM(:,ispin) = m1%vals(2)%data(:)    
     ! Check no_l
     if (no_l /= m1%no_l) then
        call die("Mismatch in no_l")
     endif
     ! Check listH
     if (any(listH(:) /= m1%cols(:))) then
        call die("Mismatch in listH")
     endif

     call de_alloc(m1%vals(1)%data,"m1%vals(1)%data","pexsi_solver")
     call de_alloc(m1%vals(2)%data,"m1%vals(2)%data","pexsi_solver")
     deallocate(m1%vals)
     ! allocated in the direct transfer
     call de_alloc(m1%numcols,"m1%numcols","pexsi_solver") 
     call de_alloc(m1%cols,   "m1%cols",   "pexsi_solver")

     call timer("pexsi", 2)

  endif

#+END_SRC
   
** Clean up
#+BEGIN_SRC f90 :noweb-ref clean-up

  call delete(dist1)
  call delete(dist2)

  ! Step 3. Clean up */

  ! We cannot finalize now if we are going to reuse
  ! the plan in subsequent iterations...
  ! We need an extra module to take care of this

  if (PEXSI_worker) then
     call MPI_Comm_Free(PEXSI_Comm, ierr)
     call MPI_Group_Free(PEXSI_Group, ierr)
  endif
#+END_SRC
   
** Support routines

Several routines 

#+BEGIN_SRC f90 :noweb-ref support-routines
 <<get-on-the-fly-tolerance>>
 <<need-inertia-counting>>
 <<get-bracket-for-inertia-count>>
 <<get-bracket-for-solver>>
 <<get-current-temperature>>
 <<check-info>> 
#+END_SRC

*** On-the-fly tolerance determination
#+BEGIN_SRC f90 :noweb-ref get-on-the-fly-tolerance

!
! This routine encodes the heuristics to compute the
! tolerance dynamically.
!
subroutine get_on_the_fly_tolerance(dDmax,tolerance)
real(dp), intent(in)  :: dDmax
real(dp), intent(out) :: tolerance

real(dp) :: tolerance_preconditioner
real(dp) :: tolerance_target_factor, tolerance_exp
real(dp), save :: previous_tolerance
logical :: new_algorithm

new_algorithm = fdf_get("PEXSI.dynamical-tolerance",.false.)
!
!
if (new_algorithm) then

!   By default, the tolerance goes to the (minimum) target 
!   at a level 5 times dDtol

   tolerance_target_factor = fdf_get("PEXSI.tolerance-target-factor",5.0_dp)

!
!  This can range in a (0.5,2.0) interval, approximately

   tolerance_preconditioner = fdf_get("PEXSI.tolerance-preconditioner",1.0_dp)

   if (scf_step > 1 ) then

      tolerance_exp = log10(dDmax/(tolerance_target_factor*dDtol))
      ! 
  !   range = log10(PEXSINumElectronToleranceMax/PEXSINumElectronToleranceMin)
      tolerance_exp = max(tolerance_exp,0.0_dp)*tolerance_preconditioner
      tolerance = PEXSINumElectronToleranceMin * 10.0_dp**tolerance_exp
      tolerance = min(tolerance,PEXSINumElectronToleranceMax)

      if (tolerance > previous_tolerance) then
         if (mpirank==0) write(6,"(a,f10.2)") &
              "Will not raise PEXSI solver tolerance to: ", &
              tolerance
         tolerance = previous_tolerance
      endif
      previous_tolerance = tolerance
   else
      ! No heuristics for now for first step
      ! Note that this should really change in MD or geometry optimization
      previous_tolerance = huge(1.0_dp)
      tolerance = PEXSINumElectronToleranceMax

   endif
else
   tolerance = Max(PEXSINumElectronToleranceMin, &
                              Min(dDmax*1.0, PEXSINumElectronToleranceMax))
endif

if (mpirank==0) write(6,"(a,f10.2)") &
     "Current PEXSI solver tolerance: ", tolerance

end subroutine get_on_the_fly_tolerance
#+END_SRC

*** Decide whether inertia-counting is needed
#+BEGIN_SRC f90 :noweb-ref need-inertia-counting

!------------------------------------------------------------------
! This function will determine whether an initial inertia-counting
! stage is needed, based on user input and the level of convergence
!
! Variables used through host association for now:
!
!      scf_step
!      prevDmax, safe_dDmax_NoInertia
!
! Some logging output is done, so this function is not pure.

function need_inertia_counting() result(do_inertia_count)
logical :: do_inertia_count

real(dp) :: safe_dDmax_NoInertia
integer  :: isInertiaCount, numInertiaCounts

! Use inertia counts?
! The use of this input variable is deprecated. Warn the user
! only if there is a disagreement.

isInertiaCount = fdf_get("PEXSI.inertia-count",-1)
! For how many scf steps?
numInertiaCounts = fdf_get("PEXSI.inertia-counts",3)

if ((isInertiaCount == 0) .and. (numInertiaCounts > 0)) then 
   if (mpirank == 0) write(6,"(a,i4)")  &
        "Warning: Inertia-counts turned off by legacy parameter" // &
        " PEXSI.inertia-count"
   numInertiaCounts = 0
endif

safe_dDmax_NoInertia = fdf_get("PEXSI.safe-dDmax-no-inertia",0.05)

do_inertia_count = .false.

write_ok = ((mpirank == 0) .and. (verbosity >= 1))

if (numInertiaCounts > 0) then
  if (scf_step .le. numInertiaCounts) then
     if (write_ok) write(6,"(a,i4)")  &
      "&o Inertia-count step scf_step<numIC", scf_step
     do_inertia_count = .true.
  endif
else  if (numInertiaCounts < 0) then
   if (scf_step <= -numInertiaCounts) then
      if (write_ok) write(6,"(a,i4)") &
           "&o Inertia-count step scf_step<-numIC ", scf_step
      do_inertia_count = .true.
   else if (prevDmax > safe_dDmax_NoInertia) then
      if (write_ok) write(6,"(a,i4)") &
           "&o Inertia-count step as prevDmax > safe_Dmax ", scf_step
      do_inertia_count = .true.
   endif
endif

end function need_inertia_counting
#+END_SRC

*** Get bracket for inertia-counting
#+BEGIN_SRC f90 :noweb-ref get-bracket-for-inertia-count

!---------------------------------------------------------------
!  Chooses the proper interval for the call to the driver
!  in case we need a stage of inertia counting  
!
subroutine get_bracket_for_inertia_count()

 real(dp)       :: safe_width_ic
 real(dp)       :: safe_dDmax_Ef_inertia

 safe_width_ic = fdf_get("PEXSI.safe-width-ic-bracket",4.0_dp*eV,"Ry")
 safe_dDmax_Ef_Inertia = fdf_get("PEXSI.safe-dDmax-ef-inertia",0.1)

write_ok = ((mpirank == 0) .and. (verbosity >= 1))

 ! Proper bracketing                                                           
 if (scf_step > 1) then
   if (prevDmax < safe_dDmax_Ef_inertia) then
      ! Shift brackets using estimate of Ef change from previous iteration 
      !                                                                    
      if (write_ok) write(6,"(a)") &
         "&o Inertia-count bracket shifted by Delta_Ef"
      ! This might be risky, if the final interval of the previous iteration   
      ! is too narrow. We should broaden it by o(kT)                           
      ! The usefulness of delta_Ef is thus debatable...                        

      muMin0 = muMinInertia + delta_Ef - two_kT
      muMax0 = muMaxInertia + delta_Ef + two_kT
   else
      ! Use a large enough interval around the previous estimation of   
      ! mu (the gap edges are not available...)  
      if (write_ok) write(6,"(a)") "&o Inertia-count safe bracket"
!      muMin0 = min(muLowerEdge - 0.5*safe_width_ic, muMinInertia)
      muMin0 = min(mu - 0.5*safe_width_ic, muMinInertia)
!      muMax0 = max(muUpperEdge + 0.5*safe_width_ic, muMaxInertia)
      muMax0 = max(mu + 0.5*safe_width_ic, muMaxInertia)
   endif
 else
    if (write_ok) write(6,"(a)") &
       "&o Inertia-count called with iscf=1 parameters"
 endif
end subroutine get_bracket_for_inertia_count
#+END_SRC

*** Get bracket for solver
#+BEGIN_SRC f90 :noweb-ref get-bracket-for-solver

subroutine get_bracket_for_solver()

    real(dp)       :: safe_width_solver
    real(dp)       :: safe_dDmax_Ef_solver

safe_width_solver = fdf_get("PEXSI.safe-width-solver-bracket",4.0_dp*eV,"Ry")
safe_dDmax_Ef_solver = fdf_get("PEXSI.safe-dDmax-ef-solver",0.05)

write_ok = ((mpirank == 0) .and. (verbosity >= 1))

! Do nothing for now
! No setting of  muMin0 and muMax0 yet, pending clarification of flow

  if (scf_step > 1) then
     if (prevDmax < safe_dDmax_Ef_solver) then
        if (write_ok) write(6,"(a)") "&o Solver mu shifted by delta_Ef"
        mu = mu + delta_Ef
     endif
     ! Always provide a safe bracket around mu, in case we need to fallback
     ! to executing a cycle of inertia-counting
     if (write_ok) write(6,"(a)") "&o Safe solver bracket around mu"
     muMin0 = mu - 0.5*safe_width_solver
     muMax0 = mu + 0.5*safe_width_solver
  else
     if (write_ok) write(6,"(a)") "&o Solver called with iscf=1 parameters"
     ! do nothing. Keep mu, muMin0 and muMax0 as they are inherited
  endif
end subroutine get_bracket_for_solver
#+END_SRC

*** Compute current temperature if annealing
#+BEGIN_SRC f90 :noweb-ref get-current-temperature

!------------------------------------------------------
! If using the "annealing" feature, this routine computes
! the current temperature to use in the PEXSI solver
!
subroutine get_current_temperature(pexsi_temperature)
  real(dp), intent(out) :: pexsi_temperature

 logical  :: use_annealing
 real(dp) :: annealing_preconditioner, temp_factor
 real(dp) :: annealing_target_factor

 use_annealing = fdf_get("PEXSI.use-annealing",.false.)
 if (use_annealing) then
   annealing_preconditioner = fdf_get("PEXSI.annealing-preconditioner",1.0_dp)
!   By default, the temperature goes to the target at a level 10 times dDtol
   annealing_target_factor = fdf_get("PEXSI.annealing-target-factor",10.0_dp)

   if (scf_step > 1 ) then

      ! Examples for target_factor = 10, dDtol=0.0001:
      ! prevDmax=0.1, preconditioner=1, factor=3
      ! prevDmax=0.1, preconditioner=2, factor=5
      ! prevDmax=0.1, preconditioner=3, factor=7
      ! prevDmax<=0.001, factor = 1
      ! prevDmax<0.001, factor = 1

      temp_factor = (log10(prevDmax/(annealing_target_factor*dDtol)))
      temp_factor = 1 + annealing_preconditioner * max(0.0_dp, temp_factor)

      pexsi_temperature = temp_factor * temperature
      if (pexsi_temperature > previous_pexsi_temperature) then
         if (mpirank==0) write(6,"(a,f10.2)") &
              "Will not raise PEXSI temperature to: ", &
              pexsi_temperature/Kelvin
         pexsi_temperature = previous_pexsi_temperature
      endif
      previous_pexsi_temperature = pexsi_temperature
   else
      ! No heuristics for now for first step
      previous_pexsi_temperature = huge(1.0_dp)
      pexsi_temperature = temperature
      !   Keep in mind for the future if modifying T at the 1st step
      !      previous_pexsi_temperature = pexsi_temperature
   endif
else
      pexsi_temperature = temperature
endif
if (mpirank==0) write(6,"(a,f10.2)") &
     "Current PEXSI temperature (K): ", pexsi_temperature/Kelvin
end subroutine get_current_temperature
#+END_SRC

*** Error dispatcher
#+BEGIN_SRC f90 :noweb-ref check-info

subroutine check_info(info,str)
integer, intent(in) :: info
character(len=*), intent(in) :: str

    if(mpirank == 0) then
       if (info /= 0) then
          write(6,*) trim(str) // " info : ", info
          call die("Error exit from " // trim(str) // " routine")
       endif
      call pxfflush(6)
    endif	
end subroutine check_info
#+END_SRC
