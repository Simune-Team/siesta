
      SUBROUTINE EGOFV(H,S,N,E,G,Y,L,Z,A,B,RMAX,NPRIN,NNODE,DR)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  EIOFV DETERMINES THE EIGENENERGY AND WAVEFUNCTION CORRESPONDING
C  TO A PARTICULAR L, PRINCIPAL QUANTUM NUMBER AND BOUNDARY CONDITION.
C
C  TWO FUNDAMENTAL TECHNIQUES ARE USED TO LOCATE THE SOLUTION:
C       1) NODE COUNTING AND BISECTION
C       2) VARIATIONAL ESTIMATE BASED ON A SLOPE DISCONTINUITY IN PSI
C  THE ARGUMENTS ARE DEFINED AS FOLLOWS:
C       H,S: G" = (H-E*S)*G
C       NR: MAXIMUM ALLOWED NUMBER OF RADIAL POINTS
C       E: E(I) IS THE I-TH ENERGY FOUND
C       NE: NUMBER OF ENERGIES FOUND
C       L: THE ANGULAR MOMENTUM
C       NCOR: THE NUMBER OF LOWER-ENERGY STATES
C
C  THE INDIVIDUAL ENERGIES ARE RESOLVED BY PERFORMING A FIXED NUMBER
C  OF BISECTIONS AFTER A GIVEN EIGENVALUE HAS BEEN ISOLATED
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION H(N),S(N),G(N),Y(*)
      DATA TOL   /1.D-5/
      NCOR=NPRIN-L-1
      N1=NNODE
      N2=NNODE-1
      E1=E
      E2=E
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  THE LABELS 1 AND 2 REFER TO THE BISECTION PROCESS, DEFINING THE
C  RANGE IN WHICH THE DESIRED SOLUTION IS LOCATED.  THE INITIAL
C  SETTINGS OF N1, N2, E1 AND E2 ARE NOT CONSISTENT WITH THE BISECTION
C  ALGORITHM; THEY ARE SET TO CONSISTENT VALUES WHEN THE DESIRED
C  ENERGY INTERVAL HAS BEEN LOCATED.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      DEL=5.D-1
      DE=0.D0
      NITER = 0
 1    NITER = NITER + 1
      IF(NITER.GT.40) GO TO 3
      ET=E+DE
C  THE FOLLOWING LINE IS THE FUNDAMENTAL "BISECTION"
      E=0.5*(E1+E2)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  THE FOLLOWING CONCATENATION OF LOGICAL ORS ENSURES THAT NODE
C  COUNTING IS USED UNLESS THE PREVIOUS INTEGRATION OF THE RADIAL
C  EQ PRODUCED BOTH THE CORRECT NUMBER OF NODES AND A SENSIBLE
C  PREDICTION FOR THE ENERGY.
C
C     SENSIBLE MEANS THAT ET MUST BE GREATER THAN E1 AND LESS THAN E2
C     CORRECT NUMBER OF NODES MEANS THAT NT = NNODE OR NNODE-1.
C
C     LEAVING E SET TO ITS BISECTION VALUE, AND TRANSFERING TO
C     THE CALL TO YOFE MEANS THAT WE ARE PERFORMING BISECTION,
C     WHEREAS SETTING E TO ET IS USE OF THE VARIATIONAL ESTIMATE.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IF(ET.LE.E1 .OR. ET.GE.E2 .OR.
     1       NT.LT.NNODE-1 .OR. NT.GT.NNODE) GO TO 2
      E=ET
      IF(DABS(DE).LT.TOL) GO TO 6
 2    CALL YOFE(E,DE,DR,RMAX,H,S,Y,N,L,NCOR,NT,Z,A,B)
C     WRITE(6,101) L,DR,N1,NT,NNODE,N2,E1,E,E2,DE
C101  FORMAT('  L     DR     N1  NT   N  N2       E1           E',
C    1       '          E2          DE'/I3,D10.3,4I4,4F12.5)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  YOFE INTEGRATES THE SCHRO EQ.; NOW THE BISECTION LOGIC
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IF(NT.GE.NNODE) GO TO 5
C  TOO FEW NODES; SET E1 AND N1
      E1=E
      N1=NT
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  AT THIS POINT, WE HAVE JUST SET THE BOTTOM OF THE BISECTION RANGE;
C  IF THE TOP IS ALSO SET, WE PROCEDE.  IF THE TOP OF THE RANGE HAS NOT
C  BEEN SET, IT MEANS THAT WE HAVE YET TO FIND AN E GREATER THAN THE
C  DESIRED ENERGY.  THE UPPER END OF THE RANGE IS EXTENDED.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IF(N2.GE.NNODE) GO TO 1
      DEL=DEL*2.D0
      E2=E1+DEL
      GO TO 1
C  TOO MANY NODES; SET E2 AND N2
 5    E2=E
      N2=NT
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  AT THIS POINT, WE HAVE JUST SET THE TOP OF THE BISECTION RANGE;
C  IF THE TOP IS ALSO SET, WE PROCEDE.  IF THE TOP OF THE RANGE HAS
C  NOT BEEN SET, IT MEANS THAT WE HAVE YET TO FIND AN E LESS THAN THE
C  DESIRED ENERGY.  THE LOWER END OF THE RANGE IS EXTENDED.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IF(N1.LT.NNODE) GO TO 1
      DEL=DEL*2.D0
      E1=E2-DEL
      GO TO 1
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  THE NUMEROV METHOD USES A TRANSFORMATION OF THE RADIAL WAVE FCN.
C  THAT WE CALL "Y".  HAVING LOCATED THE EIGENENERGY, WE TRANSFORM
C  Y TO "G", FROM WHICH THE DENSITY IS EASILY CONSTRUCTED.
C  FINALLY, THE CALL TO "NRMLZG" NORMALIZES G TO ONE ELECTRON.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 6    G(1) = 0.D0
      DO 7 I=2,N
           T=H(I)-E*S(I)
           G(I)=Y(I)/(1.D0-T/12.D0)
 7    CONTINUE
      CALL NRMLZG(G,S,N)
      RETURN
 3    WRITE(6,4) Z,L,NNODE,E,DE
 4    FORMAT(' EGOFV: TOO MANY ITERATIONS; EXECUTION STOPPING'/
     1       ' Z=',F3.0,'  L=',I2,'  NNODE=',I2,'  E=',F12.5,
     2       '  DE=',F12.5)
      STOP 8
      END





      SUBROUTINE YOFE(E,DE,DR,RMAX,H,S,Y,NMAX,L,NCOR,NNODE,Z,A,B)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C   YOFE INTEGRATES THE RADIAL SCHRODINGER EQN USING THE NUMEROV
C   METHOD.
C
C   THE ARGUMENTS ARE DEFINED AS FOLLOWS:
C       E IS THE OLD ENERGY(OVERWRITTEN) BY THE NEW ENERGY
C       DE IS THE E CHANGE PREDICTED TO ELIM THE KINK IN PSI
C       DR IS THE LOG DERIV (THE BOUNDARY CONDITION)
C       G" = (H-ES)G (ALL DIAGONAL IN I (RADIUS) )
C       Y IS THE NUMEROV INDEPENDENT VARIABLE Y = G - G"/12
C       N IS THE NUMBER OF RADIAL MESH POINTS
C       L IS THE ANGULAR MOMENTUM
C       NCOR IS THE NUMBER OF STATES OF LOWER ENERGY
C       NNODE IS 1 + THE NUMBER OF INTERIOR NODES IN PSI
C       Z IS THE ATOMIC NUMBER
C       A AND B SPECIFY THE RADIAL MESH R(I)=(EXP(A*(I-1))-1)*B
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION H(NMAX),S(NMAX),Y(NMAX)
      ZDR = Z*A*B
      N=NMAX
 8    IF( H(N)-E*S(N) .LT. 1.D0 ) GO TO 9
      Y(N)=0.D0
      N=N-1
      GO TO 8
 9    CONTINUE
      CALL BCORGN(E,H,S,L,ZDR,Y2)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  BCORGN COMPUTES Y2, WHICH EMBODIES THE BOUNDARY CONDITION
C  SATISFIED BY THE RADIAL WAVE FUNCTION AT THE ORIGIN
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC=
      KNK=N
      CALL NUMOUT(E,H,S,Y,NCOR,KNK,NNODE,Y2,G,GSG,X)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  THE OUTWARD INTEGRATION IS NOW COMPLETE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC=
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     WE FIRST DECIDE IF THE KINETIC ENERGY IS SUFFICIENTLY NON
C     NEGATIVE TO PERMIT USE OF THE NUMEROV EQ AT RMAX.  IF
C     IT IS NOT, THEN ZERO-VALUE BOUNDARY CONDITION IS USED
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      YN=0.D0
      IF(N.LT.NMAX .OR. DABS(DR).GT.1.D3) GO TO 7
      CALL BCRMAX(E,DR,RMAX,H,S,N,YN,A,B)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  BCRMAX COMPUTES YN, WHICH EMBODIES THE BOUNDARY CONDITION
C  SATISFIED BY THE RADIAL WAVE FUNCTION AT RMAX
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC=
 7    CALL NUMIN(E,H,S,Y,N,NNDIN,YN,GIN,GSGIN,XIN,KNK)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  NUMIN PERFORMS THE INWARD INTEGRATION BY THE NUMEROV METHOD
C
C  THE ENERGY INCREMENT IS NOW EVALUATED FROM THE KINK IN PSI
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC=
      RATIO = G/GIN
      XIN=XIN*RATIO
      GSG=GSG+GSGIN*RATIO*RATIO
      T=H(KNK)-E*S(KNK)
      DE=G*(X+XIN+T*G)/GSG
      NNODE=NNODE+NNDIN
      IF(DE.LT.0.D0) NNODE=NNODE+1
      DO 6 I=KNK,N
         Y(I) = Y(I)*RATIO
 6    CONTINUE
      RETURN
      END
      SUBROUTINE NRMLZG(G,S,N)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C   NRMLZG NORMALIZES THE SUPPLIED RADIAL WAVE FUNCTION
C
C   THE ARGUMENTS ARE DEFINED AS FOLLOWS:
C       G IS THE RADIAL WAVE FUNCTION APPROPRIATE TO THE NUMEROV
C             REPRESENTATION OF THE RADIAL SCHRODINGER EQUATION
C             THAT IS, THE RADIAL FCN R(R) = (DRDI)**1/2 G(I) / R(I)
C       G" = (H-ES)G (ALL DIAGONAL IN I (RADIUS) )
C       N1 IS THE NUMBER OF RADIAL MESH POINTS CORRESPONDING TO
C             THE PORTION OF THE RADIAL MESH ON WHICH THE NORM
C             IS DEFINED
C       N2 IS THE NUMBER OF RADIAL MESH POINTS CORRESPONDING TO
C             THE PORTION OF THE RADIAL MESH ON WHICH THE WAVE
C             FUNCTION IS DEFINED.  FOR THE INTENDED USE OF THIS
C             ROUTINE, N1 = NRVAL AND N2 = NRCOR
C       A AND B ARE THE RADIAL MESH PARAMETERS
C             R(I) = ( EXP(A*(I-1)) - 1 ) * B
C             (DR/DI = A*B AT THE ORIGIN)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC=
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION S(*),G(*),NORM
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  DETERMINE THE NORM OF G(I) USING SIMPSON'S RULE
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IF (MOD(N,2).NE.1) WRITE(6,*) ' NRMLZG: N SHOULD BE ODD. N =',N
      NORM = 0.D0
      NM1 = N - 1
      DO 2 I = 2,NM1,2
         NORM=NORM + G(I)*S(I)*G(I)
 2    CONTINUE
      NORM = NORM * 2.D0
      NM2  = N - 2
      DO 3 I = 3,NM2,2
         NORM=NORM + G(I)*S(I)*G(I)
 3    CONTINUE
      NORM = NORM * 2.D0
      NM2  = N - 2
      DO 4 I = 1,N,NM1
         NORM=NORM + G(I)*S(I)*G(I)
 4    CONTINUE
      NORM = NORM/3.D0
      SRNRM = DSQRT(NORM)
      DO 5 I=1,N
         G(I) = G(I)/SRNRM
 5    CONTINUE
      RETURN
      END






      SUBROUTINE BCORGN(E,H,S,L,ZDR,Y2)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C   YOFE INTEGRATES THE RADIAL SCHRODINGER EQN USING THE NUMEROV
C   METHOD.
C
C   THE ARGUMENTS ARE DEFINED AS FOLLOWS:
C       E IS THE OLD ENERGY(OVERWRITTEN) BY THE NEW ENERGY
C       DE IS THE E CHANGE PREDICTED TO ELIM THE KINK IN PSI
C       DR IS THE LOG DERIV (THE BOUNDARY CONDITION)
C       G" = (H-ES)G (ALL DIAGONAL IN I (RADIUS) )
C       Y IS THE NUMEROV INDEPENDENT VARIABLE Y = G - G"/12
C       N IS THE NUMBER OF RADIAL MESH POINTS
C       L IS THE ANGULAR MOMENTUM
C       NNODE IS 1 + THE NUMBER OF INTERIOR NODES IN PSI
C       Z IS THE ATOMIC NUMBER
C       A AND B SPECIFY THE RADIAL MESH R(I)=(EXP(A*(I-1))-1)*B
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION H(*),S(*)
C
C   THE QUANTITY CALLED D(I) IN THE PROGRAM IS ACTUALLY THE INVERSE
C   OF THE DIAGONAL OF THE TRI-DIAGONAL NUMEROV MATRIX
C
      T2=H(2)-E*S(2)
      D2=-((24.D0+10.D0*T2)/(12.D0-T2))
C
C=================================================================
C  THE FOLLOWING SECTION DEALS WITH THE FACT THAT THE INDEPENDENT
C  VARIABLE "Y" IN THE NUMEROV EQUATION IS NOT ZERO AT THE ORIGIN
C  FOR L LESS THAN 2
C  THE L=0 SOLUTION G VANISHES, BUT THE FIRST AND SECOND
C  DERIVATIVES ARE FINITE, MAKING THE NUMEROV VARIABLE Y FINITE
C  THE L=1 SOLUTION G VANISHES, AND G' ALSO VANISHES, BUT
C  THE SECOND DERIVATIVE G" IS FINITE MAKING Y FINITE.  FOR L > 1,
C  G AND ITS FIRST TWO DERIVATIVES VANISH, MAKING Y ZERO.
C=================================================================
      IF(L.GE.2) GOTO 3
      IF(L.GT.0) GOTO 1
      C0=ZDR/6.D0
      C0=C0/(1.D0-0.75*ZDR)
      GO TO 2
 1    C0=1.D0/12.D0
      C0=(-C0)*8.D0/3.D0
 2    C1=C0*(12.D0+13.D0*T2)/(12.D0-T2)
      T3=H(3)-E*S(3)
      C2=(-5.D-1)*C0*(24.D0-T3)/(12.D0-T3)
      D2=(D2-C1)/(1.D0-C2)
 3    Y2=(-1.D0)/D2
      RETURN
      END



      SUBROUTINE BCRMAX(E,DR,RMAX,H,S,N,YN,A,B)
C
C 22.7.85
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION  H(*),S(*),
     .   E,DR,RMAX,YN,A,B,TNM1,TN,TNP1,BETA,DG,C1,C2,C3,DN
C
C     WRITE(6,*) 'BCRMAX:',DR
      TNM1=H(N-1)-E*S(N-1)
      TN  =H(N  )-E*S(N  )
      TNP1=H(N+1)-E*S(N+1)
      BETA=1.D0+B/RMAX
      DG=A*BETA*(DR+1.D0-5.D-1/BETA)
C
C
      C2=24.D0*DG/(12.D0-TN)
      DN=-((24.D0+10.D0*TN)/(12.D0-TN))
C
      C1= (1.D0-TNM1/6.D0)/(1.D0-TNM1/12.D0)
      C3=-((1.D0-TNP1/6.D0)/(1.D0-TNP1/12.D0))
      YN=-((1.D0-C1/C3)/(DN-C2/C3))
C
C
      RETURN
      END



      SUBROUTINE NUMIN(E,H,S,Y,N,NNODE,YN,G,GSG,X,KNK)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C   YOFE INTEGRATES THE RADIAL SCHRODINGER EQN USING THE NUMEROV
C   METHOD.
C
C   THE ARGUMENTS ARE DEFINED AS FOLLOWS:
C       E IS THE OLD ENERGY(OVERWRITTEN) BY THE NEW ENERGY
C       DE IS THE E CHANGE PREDICTED TO ELIM THE KINK IN PSI
C       DR IS THE LOG DERIV (THE BOUNDARY CONDITION)
C       G" = (H-ES)G (ALL DIAGONAL IN I (RADIUS) )
C       Y IS THE NUMEROV INDEPENDENT VARIABLE Y = G - G"/12
C       N IS THE NUMBER OF RADIAL MESH POINTS
C       L IS THE ANGULAR MOMENTUM
C       NNODE IS 1 + THE NUMBER OF INTERIOR NODES IN PSI
C       Z IS THE ATOMIC NUMBER
C       A AND B SPECIFY THE RADIAL MESH R(I)=(EXP(A*(I-1))-1)*B
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION H(N),S(N),Y(N)
      Y(N)=YN
      T=H(N)-E*S(N)
      G=Y(N)/(1.D0-T/12.D0)
      GSG=G*S(N)*G
      I=N-1
      Y(I)=1.D0
      T=H(I)-E*S(I)
      G=Y(I)/(1.D0-T/12.D0)
      GSG=GSG+G*S(I)*G
      X=Y(I)-Y(N)
      NNODE=0
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  BEGIN THE INWARD INTEGRATIONBY THE NUMEROV METHOD
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC=
 1    X=X+T*G
      I=I-1
      Y(I)=Y(I+1)+X
      IF( Y(I)*Y(I+1) .LT. 0.D0) NNODE=NNODE+1
      T=H(I)-E*S(I)
      G=Y(I)/(1.D0-T/12.D0)
      GSG=GSG+G*S(I)*G
      IF(I.GT.KNK) GO TO 1
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  THE LAST STATEMENT DEFINES THE KINK RADIUS AS THE POINT WHERE
C  PSI FIRST TURNS DOWNWARD.  THIS USUALLY MEANS AT THE OUTERMOST
C  MAXIMUM
C
C  THE INWARD INTEGRATION IS NOW COMPLETE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC=
      KNK=I
      RETURN
      END




      SUBROUTINE NUMOUT(E,H,S,Y,NCOR,KNK,NNODE,Y2,G,GSG,X)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C   YOFE INTEGRATES THE RADIAL SCHRODINGER EQN USING THE NUMEROV
C   METHOD.
C
C   THE ARGUMENTS ARE DEFINED AS FOLLOWS:
C       E IS THE OLD ENERGY(OVERWRITTEN) BY THE NEW ENERGY
C       DE IS THE E CHANGE PREDICTED TO ELIM THE KINK IN PSI
C       DR IS THE LOG DERIV (THE BOUNDARY CONDITION)
C       G" = (H-ES)G (ALL DIAGONAL IN I (RADIUS) )
C       Y IS THE NUMEROV INDEPENDENT VARIABLE Y = G - G"/12
C       N IS THE NUMBER OF RADIAL MESH POINTS
C       L IS THE ANGULAR MOMENTUM
C       NNODE IS 1 + THE NUMBER OF INTERIOR NODES IN PSI
C       Z IS THE ATOMIC NUMBER
C       A AND B SPECIFY THE RADIAL MESH R(I)=(EXP(A*(I-1))-1)*B
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION H(KNK),S(KNK),Y(KNK)
      Y(1)=0.D0
      Y(2)=Y2
      T=H(2)-E*S(2)
      G=Y(2)/(1.D0-T/12.D0)
      GSG=G*S(2)*G
      Y(3)=1.D0
      T=H(3)-E*S(3)
      G=Y(3)/(1.D0-T/12.D0)
      GSG=GSG+G*S(3)*G
      X=Y(3)-Y(2)
      I=3
      NNODE=0
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  BEGIN THE OUTWARD INTEGRATIONBY THE NUMEROV METHOD
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC=
      NM4=KNK-4
 1    XL=X
      X=X+T*G
      I=I+1
      Y(I)=Y(I-1)+X
C     WRITE(6,300) I,Y(I),X,T,H(I),S(I)
C300  FORMAT(I5,5D14.5)
      IF( Y(I)*Y(I-1) .LT. 0.D0) NNODE=NNODE+1
      T=H(I)-E*S(I)
      G=Y(I)/(1.D0-T/12.D0)
      GSG=GSG+G*S(I)*G
      IF(I.EQ.NM4) GO TO 2
      IF(NNODE.LT.NCOR) GO TO 1
      IF(XL*X.GT.0.D0) GO TO 1
 2    KNK=I
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  THE OUTWARD INTEGRATION IS NOW COMPLETE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC=
      RETURN
      END



      SUBROUTINE VHRTRE(RHO,V,R,DRDI,SRDRDI,NR,A)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C   VHRTRE CONSTRUCTS THE ELECTROSTATIC POTENTIAL DUE TO A SUPPLIED
C   ELECTRON DENSITY.  THE NUMEROV METHOD IS USED TO INTEGRATE
C   POISSON'S EQN.
C
C   DESCRIPTION OF ARGUMENTS:
C      RHO....4*PI*R**2 * THE ELECTRON DENSITY FOR WHICH WE CALCULATING
C             THE ELECTROSTATIC POTENTIAL
C      V......THE ELECTROSTATIC POTENTIAL DUE TO THE ELECTRON DENSITY
C             RHO.  THE CONSTANTS OF INTEGRATION ARE FIXED SO THAT THE
C             POTENTIAL TENDS TO A CONSTANT AT THE ORIGIN AND TO
C             2*Q/R AT R=R(NR), WHERE Q IS THE INTEGRATED CHARGE
C             CONTAINED IN RHO(R)
C      R......THE RADIAL MESH R(I) = B*(EXP(A(I-1))-1)
C      NR.....THE NUMBER OF RADIAL MESH POINTS
C      DRDI...DR(I)/DI
C      SRDRDI.SQRT(DR/DI)
C      A......THE PARAMETER APPEARING IN R(I) = B*(EXP(A(I-1))-1)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION RHO(*),V(*),R(*),DRDI(*),SRDRDI(*)
      NRM1=NR-1
      NRM2=NR-2
      A2BY4=A*A/4.D0
      YBYQ=1.D0-A*A/48.D0
      QBYY=1.D0/YBYQ
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  SIMPSON'S RULE IS USED TO PERFORM TWO INTEGRALS OVER THE ELECTRON
C  DENSITY.  THE TOTAL CHARGE QT IS USED TO FIX THE POTENTIAL AT R=R(NR)
C  AND V0 (THE INTEGRAL OF THE ELECTRON DENSITY DIVIDED BY R) FIXES
C  THE ELECTROSTATIC POTENTIAL AT THE ORIGIN
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      V0=0.D0
      QT=0.D0
      DO 1 IR=2,NRM1,2
      DZ=DRDI(IR)*RHO(IR)
      QT=QT+DZ
 1    V0=V0+DZ/R(IR)
      V0=V0+V0
      QT=QT+QT
      DO 2 IR=3,NRM2,2
      DZ=DRDI(IR)*RHO(IR)
      QT=QT+DZ
 2    V0=V0+DZ/R(IR)
      DZ=DRDI(NR)*RHO(NR)
      QT=(QT+QT+DZ)/3.D0
      V0=(V0+V0+DZ/R(NR))/3.D0
      V(1)=2.D0*V0
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  THE ELECTROSTATIC POTENTIAL AT R=0 IS SET EQUAL TO
C                       THE AVERAGE VALUE OF RHO(R)/R
C  BEGIN CONSTRUCTION OF THE POTENTIAL AT FINITE R
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IR=2
      T=SRDRDI(IR)/R(IR)
      BETA=DRDI(IR)*T*RHO(IR)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  THE NEXT 4 STATEMENTS INDICATE THAT WE FIRST FIND THE PARTICULAR
C  SOLUTION TO THE INHOMOGENEOUS EQN. FOR WHICH Q(2)=0, WE THEN
C  ADD TO THIS PARTICULAR SOLUTION A SOLUTION OF THE HOMOGENEOUS EQN.
C  (A CONSTANT IN V OR A Q PROPORTIONAL TO R)
C  WHICH WHEN DIVIDED BY R IN GOING FROM Q TO V GIVES
C  THE POTENTIAL THE DESIRED COULOMB TAIL OUTSIDE THE ELECTRON DENSITY.
C  THE SIGNIFICANCE OF THE SOLUTION VANISHING AT THE SECOND RADIAL
C  MESH POINT IS THAT, SINCE ALL REGULAR SOLUTIONS OF THE EQUATION
C  FOR Q=R*V VANISH AT THE ORIGIN, THE KNOWLEDGE OF THE SOLUTION
C  VALUE AT THE SECOND MESH POINT PROVIDES THE TWO SOLUTION VALUES
C  REQUIRED TO START THE NUMEROV PROCEDURE.
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      X=0.D0
      Y=0.D0
      Q=(Y-BETA/12.D0)*QBYY
      V(IR)=2.D0*T*Q
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  BEGINNING OF THE NUMEROV ALGORITHM
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 3    X=X+A2BY4*Q-BETA
      Y=Y+X
      IR=IR+1
      T=SRDRDI(IR)/R(IR)
      BETA=T*DRDI(IR)*RHO(IR)
      Q=(Y-BETA/12.D0)*QBYY
      V(IR)=2.D0*T*Q
      IF(IR.LT.NR) GO TO 3
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  END OF THE NUMEROV ALGORITHM
C
C  WE HAVE NOW FOUND A PARTICULAR SOLUTION TO THE INHOMOGENEOUS EQN.
C  FOR WHICH Q(R) AT THE SECOND RADIAL MESH POINT EQUALS ZERO.
C  NOTE THAT ALL REGULAR SOLUTIONS TO THE EQUATION FOR Q=R*V
C  VANISH AT THE ORIGIN.
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      QPARTC = R(NR)*V(NR)/2.D0
      DZ=QT-QPARTC
      DV=2.D0*DZ/R(NR)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  THE LOOP FOLLOWING ADDS THE CONSTANT SOLUTION OF THE HOMOGENEOUS
C  EQN TO THE PARTICULAR SOLUTION OF THE INHOMOGENEOUS EQN.
C  NOTE THAT V(1) IS CONSTRUCTED INDEPENDENTLY
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      DO 4 IR=2,NR
         V(IR)=V(IR)+DV
 4    CONTINUE
      RETURN
      END





      CHARACTER*2 FUNCTION SYMBOL( IZ )

C RETURNS THE SYMBOL OF THE ELEMENT OF ATOMIC NUMBER IZ

      PARAMETER (NZ=103)
      CHARACTER*2 NAME(NZ)
      DATA NAME /'H' ,'He','Li','Be','B' ,'C' ,'N' ,'O' ,'F' ,'Ne',
     .           'Na','Mg','Al','Si','P' ,'S' ,'Cl','Ar','K' ,'Ca',
     .           'Sc','Ti','V' ,'Cr','Mn','Fe','Co','Ni','Cu','Zn',
     .           'Ga','Ge','As','Se','Br','Kr','Rb','Sr','Y' ,'Zr',
     .           'Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn',
     .           'Sb','Te','I' ,'Xe','Cs','Ba','La','Ce','Pr','Nd',
     .           'Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb',
     .           'Lu','Hf','Ta','W' ,'Re','Os','Ir','Pt','Au','Hg',
     .           'Tl','Pb','Bi','Po','At','Rn','Fr','Ra','Ac','Th',
     .           'Pa','U' ,'Np','Pu','Am','Cm','Bk','Cf','Es','Fm',
     .           'Md','No','Lr'/
      IF (IZ.LT.1 .OR. IZ.GT.NZ) THEN
         WRITE(6,*) ' SYMBOL: OUT OF RANGE IZ =',IZ
         SYMBOL = ' '
      ELSE
         SYMBOL = NAME(IZ)
      ENDIF
      END





      CHARACTER*(*) FUNCTION PASTE( STR1, STR2 )

C CONCATENATES THE STRINGS STR1 AND STR2 REMOVING BLANKS IN BETWEEN

      CHARACTER*(*) STR1, STR2
      DO 10 L = LEN( STR1 ), 1, -1
         IF (STR1(L:L) .NE. ' ') GOTO 20
   10 CONTINUE
   20 PASTE = STR1(1:L)//STR2
      END




      CHARACTER*(*) FUNCTION PASTEB( STR1, STR2 )

C CONCATENATES THE STRINGS STR1 AND STR2 LEAVING ONLY ONE BLANK IN BETWEEN

      CHARACTER*(*) STR1, STR2 
      CHARACTER*1 BLANK
      DATA BLANK /' '/
      DO 10 L = LEN( STR1 ), 1, -1
         IF (STR1(L:L) .NE. ' ') GOTO 20
   10 CONTINUE
   20 PASTEB = STR1(1:L)//BLANK
      PASTEB = PASTEB(1:L+1)//STR2
      END





      SUBROUTINE RATINT(XA,YA,N,X,Y,DY)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (NMAX=20,TINY=1.D-15)
      DIMENSION XA(N),YA(N),C(NMAX),D(NMAX)

      IF (N.GT.NMAX) THEN 
        WRITE(6,*) 'RATINT: NMAX TOO SMALL' 
        STOP
      ENDIF 

      NS=1
      HH=ABS(X-XA(1))
      DO 11 I=1,N
        H=DABS(X-XA(I))
        IF (H.LT.TINY)THEN
          Y=YA(I)
          DY=0.0D0
          RETURN
        ELSE IF (H.LT.HH) THEN
          NS=I
          HH=H
        ENDIF
        C(I)=YA(I)
        D(I)=YA(I)+TINY
11    CONTINUE
      Y=YA(NS)
      NS=NS-1
      DO 13 M=1,N-1
        DO 12 I=1,N-M
          W=C(I+1)-D(I)
          H=XA(I+M)-X
          T=(XA(I)-X)*D(I)/H
          DD=T-C(I+1)
          IF(DD.EQ.0.0D0)GOTO 100
          DD=W/DD
          D(I)=C(I+1)*DD
          C(I)=T*DD
12      CONTINUE
        IF (2*NS.LT.N-M)THEN
          DY=C(NS+1)
        ELSE
          DY=D(NS)
          NS=NS-1
        ENDIF
        Y=Y+DY
13    CONTINUE

C*** AS RATIONAL INTERPOLATION DOES NOT CONVERGE,****************** 
C*************WE TRY WITH A POLYNOMIAL ONE*************************


100   CALL POLINT(XA,YA,N,X,Y,DY)

      RETURN
      END





      SUBROUTINE SPLINE(DELT,Y,N,YP1,YPN,Y2,U)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION Y(N),Y2(N),U(N)
    
      IF (YP1.GT..99E30) THEN
        Y2(1)=0.0D0
        U(1)=0.0D0
      ELSE
        Y2(1)=-0.5D0
        U(1)=(3.0D0/DELT)*((Y(2)-Y(1))/DELT-YP1)
      ENDIF
      DO 11 I=2,N-1
        SIG=0.5D0
        P=SIG*Y2(I-1)+2.0D0
        Y2(I)=(SIG-1.0D0)/P
        U(I)=(3.0D0*( Y(I+1)+Y(I-1)-2.0D0*Y(I) )/(DELT*DELT)
     *      -SIG*U(I-1))/P
11    CONTINUE
      IF (YPN.GT..99E30) THEN
        QN=0.0D0
        UN=0.0D0
      ELSE
        QN=0.5D0
        UN=(3.0D0/DELT)*(YPN-(Y(N)-Y(N-1))/DELT)
      ENDIF
      Y2(N)=(UN-QN*U(N-1))/(QN*Y2(N-1)+1.)
      DO 12 K=N-1,1,-1
        Y2(K)=Y2(K)*Y2(K+1)+U(K)
12    CONTINUE
      RETURN
      END






      SUBROUTINE SPLINT(DELT,YA,Y2A,N,X,Y,DYDX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      DIMENSION YA(N),Y2A(N)
      
      NLO=INT(X/DELT)+1
      NHI=NLO+1

 
      IF (DELT.EQ.0.) PAUSE 'Bad DELT input.'

      A=NHI-X/DELT-1
      B=1.0D0-A
      Y=A*YA(NLO)+B*YA(NHI)+
     *      ((A**3-A)*Y2A(NLO)+(B**3-B)*Y2A(NHI))*(DELT**2)/6.

      DYDX=(YA(NHI)-YA(NLO))/DELT +
     * (-((3*(A**2)-1.0)*Y2A(NLO))+(3*(B**2)-1.0)*Y2A(NHI))*DELT/6.
      RETURN
      END







        SUBROUTINE YLMR (R,LI,MI,YLM,GRYLM)

C COMPUTES REAL SPHERICAL HARMONICS YLM IN THE DIRECTION OF VECTOR R:
C    YLM = C * PLM( COS(THETA) ) * SIN(M*PHI)   FOR   M <  0
C    YLM = C * PLM( COS(THETA) ) * COS(M*PHI)   FOR   M >= 0
C WITH (THETA,PHI) THE POLAR ANGLES OF R, C A POSITIVE NORMALIZATION
C CONSTANT AND PLM ASSOCIATED LEGENDRE POLYNOMIALS.

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (LMAXD=10,NLD=LMAXD+1,TINY=1.D-30,
     .   ZERO=0.D0,HALF=0.5D0,ONE=1.D0,TWO=2.D0,THREE=3.D0,SIX=6.D0)
      DIMENSION R(3),C(0:NLD*NLD),GRYLM(3)
      SAVE LMAX,C
      DATA LMAX /-1/

C EVALUATE NORMALIZATION CONSTANTS ONCE AND FOR ALL
      IF (LI.GT.LMAXD) THEN
         WRITE(6,*) 'YLM: ERROR PARAMETER LMAXD MUST BE INCREASED'
         STOP
      ENDIF

      IF (LI.GT.LMAX) THEN
         FOURPI=TWO**4*ATAN(ONE)
         DO 20 L=0,LI
            ILM0=L*L+L
            DO 15 M=0,L
               FAC=(2*L+1)/FOURPI
               DO 10 I=L-M+1,L+M
                  FAC=FAC/I
   10          CONTINUE
               C(ILM0+M)=SQRT(FAC)
C              NEXT LINE BECAUSE YLM'S ARE REAL COMBINATIONS OF M AND -M
               IF (M.NE.0) C(ILM0+M)=C(ILM0+M)*SQRT(TWO)
               C(ILM0-M)=C(ILM0+M)
   15       CONTINUE
   20    CONTINUE
         LMAX=LI
      ENDIF

C IF L=0, NO CALCULATIONS ARE REQUIRED

      IF (LI.EQ.0) THEN

      YLM=C(0)
      GRYLM(1)=ZERO
      GRYLM(2)=ZERO
      GRYLM(3)=ZERO

       GOTO 999

      ENDIF

C IF R=0, DIRECTION IS UNDEFINED => MAKE YLM=0 EXCEPT FOR L=0
      R2=R(1)*R(1)+R(2)*R(2)+R(3)*R(3)
      IF (R2.LT.TINY) THEN
         YLM=ZERO
C        Next three lines added by J.M.Soler. 14/08/96.
         GRYLM(1)=ZERO
         GRYLM(2)=ZERO
         GRYLM(3)=ZERO
         GOTO 999
      ENDIF
      RSIZE=SQRT(R2)
        
      X=R(1)/RSIZE
      Y=R(2)/RSIZE
      Z=R(3)/RSIZE

C EXPLICIT FORMULAS FOR L=1 AND L=2
      IF (LI.EQ.1) THEN
         IF(MI.EQ.-1) THEN 
           YLM=(-C(1))*Y
           GRYLM(1)= C(1)*X*Y/RSIZE
           GRYLM(2)=(-C(1))*(ONE-Y*Y)/RSIZE
           GRYLM(3)= C(1)*Z*Y/RSIZE 
         ELSEIF(MI.EQ.0) THEN
           YLM= C(2)*Z
           GRYLM(1)=(-C(2))*X*Z/RSIZE
           GRYLM(2)=(-C(2))*Y*Z/RSIZE
           GRYLM(3)= C(2)*(ONE-Z*Z)/RSIZE
         ELSEIF(MI.EQ.1) THEN
           YLM=(-C(3))*X
           GRYLM(1)=(-C(3))*(ONE-X*X)/RSIZE
           GRYLM(2)= C(3)*Y*X/RSIZE
           GRYLM(3)= C(3)*Z*X/RSIZE
         ENDIF
         GOTO 999
      ENDIF
         
       IF (LI.EQ.2) THEN
         IF(MI.EQ.-2)THEN
           YLM= C(4)*SIX*X*Y
           GRYLM(1)=(-C(4))*SIX*(TWO*X*X*Y-Y)/RSIZE
           GRYLM(2)=(-C(4))*SIX*(TWO*Y*X*Y-X)/RSIZE
           GRYLM(3)=(-C(4))*SIX*(TWO*Z*X*Y)/RSIZE
         ELSEIF(MI.EQ.-1)THEN
           YLM=(-C(5))*THREE*Y*Z
           GRYLM(1)= C(5)*THREE*(TWO*X*Y*Z)/RSIZE
           GRYLM(2)= C(5)*THREE*(TWO*Y*Y*Z-Z)/RSIZE
           GRYLM(3)= C(5)*THREE*(TWO*Z*Y*Z-Y)/RSIZE
         ELSEIF(MI.EQ.0) THEN
           YLM= C(6)*HALF*(THREE*Z*Z-ONE)
           GRYLM(1)=(-C(6))*THREE*(X*Z*Z)/RSIZE
           GRYLM(2)=(-C(6))*THREE*(Y*Z*Z)/RSIZE
           GRYLM(3)=(-C(6))*THREE*(Z*Z-ONE)*Z/RSIZE
         ELSEIF(MI.EQ.1) THEN
           YLM=(-C(7))*THREE*X*Z
           GRYLM(1)= C(7)*THREE*(TWO*X*X*Z-Z)/RSIZE
           GRYLM(2)= C(7)*THREE*(TWO*Y*X*Z)/RSIZE
           GRYLM(3)= C(7)*THREE*(TWO*Z*X*Z-X)/RSIZE
         ELSEIF(MI.EQ.2) THEN
           YLM= C(8)*THREE*(X*X-Y*Y)
           GRYLM(1)=(-C(8))*SIX*(X*X-Y*Y-ONE)*X/RSIZE
           GRYLM(2)=(-C(8))*SIX*(X*X-Y*Y+ONE)*Y/RSIZE
           GRYLM(3)=(-C(8))*SIX*(X*X-Y*Y)*Z/RSIZE
         ENDIF

         GOTO 999
      ENDIF

C GENERAL ALGORITHM BASED ON ROUTINE PLGNDR OF 'NUMERICAL RECIPES'

      MABS=ABS(MI)
      XYSIZE=SQRT(MAX(X*X+Y*Y,TINY))
      COSPHI=X/XYSIZE
      SINPHI=Y/XYSIZE
      COSM=ONE
      SINM=ZERO
      DO M=1,MABS
        COSMM1=COSM
        SINMM1=SINM
        COSM=COSMM1*COSPHI-SINMM1*SINPHI
        SINM=COSMM1*SINPHI+SINMM1*COSPHI
      ENDDO

     
      IF(MI.LT.0) THEN
        PHASE=SINM
        DPHASE=MABS*COSM
      ELSE
        PHASE=COSM
        DPHASE=(-MABS)*SINM
      ENDIF

         PMM=ONE
         FACT=ONE
       IF(MABS.GT.ZERO) THEN
         DO 30 I=1,MABS
            PMM=(-PMM)*FACT*XYSIZE
            FACT=FACT+TWO
   30    CONTINUE
       ENDIF

       IF(LI.EQ.MABS) THEN
         PLGNDR=PMM
         DPLG=(-LI)*Z*PMM/(XYSIZE**2)
       ELSE   
         PMMP1=Z*(2*MABS+1)*PMM
         IF(LI.EQ.MABS+1) THEN
           PLGNDR=PMMP1
           DPLG=-((LI*Z*PMMP1-(MABS+LI)*PMM)/(XYSIZE**2))
         ELSE 

         DO 40 L=MABS+2,LI
            PLL=(Z*(2*L-1)*PMMP1-(L+MABS-1)*PMM)/(L-MABS)
            PMM=PMMP1
            PMMP1=PLL
   40    CONTINUE
         PLGNDR=PLL
         DPLG=-((LI*Z*PLL-(L+MABS-1)*PMM)/(XYSIZE**2))
         ENDIF
       ENDIF         
        

         ILM0=LI*LI+LI
         CMI=C(ILM0+MI)
         YLM=CMI*PLGNDR*PHASE
         GRYLM(1)=(-CMI)*DPLG*X*Z*PHASE/RSIZE
     .     -CMI*PLGNDR*DPHASE*Y/(RSIZE*XYSIZE**2)

         GRYLM(2)=(-CMI)*DPLG*Y*Z*PHASE/RSIZE
     .     +CMI*PLGNDR*DPHASE*X/(RSIZE*XYSIZE**2)

         GRYLM(3)= CMI*DPLG*(ONE-Z*Z)*PHASE/RSIZE
   

  999 CONTINUE

      END






      SUBROUTINE QVLOFZ(IZ,QVAL) 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (LMAX=3,IZMAX=98,NCHNG=15)
      DIMENSION QVAL(0:*),Q(0:LMAX,0:IZMAX),
     .          NVAL(0:5),N(0:LMAX),IZCHNG(NCHNG),LCHNG(NCHNG)

      DATA IZCHNG /3,9,11,17,19,31,35,37,49,53,55,72,81,85,87/
      DATA LCHNG  /0,0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 3, 2, 0, 1/

      DATA (Q(0,I),I= 0, 2) /0.,1.,2./
      DATA (Q(0,I),I= 3,10) /1.,2.,  2.,2.,2.,2.,0.,0./
      DATA (Q(0,I),I=11,18) /1.,2.,  2.,2.,2.,2.,0.,0./
      DATA (Q(0,I),I=19,30) /1.,2.,  2.,2.,2.,1.,2.,2.,2.,2.,1.,2./
      DATA (Q(0,I),I=31,36) /        2.,2.,2.,2.,0.,0./
      DATA (Q(0,I),I=37,48) /1.,2.,  2.,2.,1.,1.,2.,1.,1.,0.,1.,2./
      DATA (Q(0,I),I=49,54) /        2.,2.,2.,2.,0.,0./
      DATA (Q(0,I),I=55,71) /1.,2.,  2.,  14*2./
      DATA (Q(0,I),I=72,80) /           2.,2.,2.,2.,2.,2.,0.,1.,2./
      DATA (Q(0,I),I=81,86) /        2.,2.,2.,2.,0.,0./
      DATA (Q(0,I),I=87,98) /1.,2.,  10*2./

      DATA (Q(1,I),I= 0,10) / 5*0.,1.,2.,3.,4.,5.,6./
      DATA (Q(1,I),I=11,18) / 2*0.,1.,2.,3.,4.,5.,6./
      DATA (Q(1,I),I=19,36) /12*0.,1.,2.,3.,4.,5.,6./
      DATA (Q(1,I),I=37,54) /12*0.,1.,2.,3.,4.,5.,6./
      DATA (Q(1,I),I=55,86) /26*0.,1.,2.,3.,4.,5.,6./
      DATA (Q(1,I),I=87,98) /12*0./

      DATA (Q(2,I),I= 0,30) /21*0.,1.,2.,3.,5.,5.,6.,7., 8.,10.,10./
      DATA (Q(2,I),I=31,48) / 8*0.,1.,2.,4.,5.,5.,7.,8.,10.,10.,10./
      DATA (Q(2,I),I=49,71) / 8*0.,1.,  6*0.,1.,6*0.,1./
      DATA (Q(2,I),I=72,80) /         2.,3.,4.,5.,6.,7.,10.,10.,10./
      DATA (Q(2,I),I=81,98) / 8*0.,1.,2.,1.,1.,3*0.,1.,2.,1./

      DATA (Q(3,I),I= 0,64) /58*0.,2.,3.,4.,5.,6.,7.,7./
      DATA (Q(3,I),I=65,71) /      9.,10.,11.,12.,13.,14.,14./
      DATA (Q(3,I),I=72,98) /18*0.,0.,2.,3.,5.,6.,7.,7.,7.,9./
 
      IF(IZ.GT.IZMAX) THEN 
        WRITE(6,*) 'QVLOFZ: IZ GREATER THAN IZMAX'
        STOP
      ENDIF

      DO 10 L=0,LMAX
         N(L)=L+1
  10  CONTINUE
      DO 20 ICHNG=1,NCHNG
         IF (IZ.LT.IZCHNG(ICHNG)) GOTO 20
         L=LCHNG(ICHNG)
         N(L)=N(L)+1
  20  CONTINUE
      CALL LMXOFZ (IZ,LMXCHM,LMXATM)
      CALL CNFIG (IZ,NVAL)
      DO 30 L=0,LMXCHM
         IF (NVAL(L).LT.N(L)) QVAL(L)=2*(2*L+1)+Q(L,IZ)
         IF (NVAL(L).EQ.N(L)) QVAL(L)=Q(L,IZ)
         IF (NVAL(L).GT.N(L)) QVAL(L)=0
  30  CONTINUE
      END

      SUBROUTINE LMXOFZ (Z,LMXCHM,LMXATM)
      PARAMETER (NCHNG=17)
      INTEGER Z,ZCHNG(NCHNG),LCHNG(NCHNG)
      DATA ZCHNG /5,11,13,19,21,31,37,39,49,55,57,58,72,81,87,89,90/
      DATA LCHNG /1, 0, 1, 0, 2, 1, 0, 2, 1, 0, 2, 3, 2, 1, 0, 2, 3/
      LMXCHM=0
      LMXATM=0
      DO 1 ICHNG=1,NCHNG
         IF (Z.LT.ZCHNG(ICHNG)) RETURN
         LMXCHM=LCHNG(ICHNG)
         LMXATM=MAX(LMXATM,LMXCHM)
   1  CONTINUE
      RETURN
      END


      SUBROUTINE CNFIG (Z,CONFIG)
      IMPLICIT INTEGER (A-Z)
      PARAMETER (LMAX=4,NCHNG=15)
      INTEGER Z,CONFIG(0:LMAX),ZCHNG(NCHNG),LCHNG(NCHNG)
*     DATA ZCHNG /3,9,11,17,19,31,35,37,49,53,55,72,81,85,87/
      DATA ZCHNG /3,11,11,17,19,31,35,37,49,53,55,72,81,85,87/
      DATA LCHNG /0,0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 3, 2, 0, 1/
      DO 10 L=0,LMAX
         CONFIG(L)=L+1
   10 CONTINUE
      DO 20 ICHNG=1,NCHNG
         IF (Z.LT.ZCHNG(ICHNG)) GOTO 30
         L=LCHNG(ICHNG)
         CONFIG(L)=CONFIG(L)+1
   20 CONTINUE
   30 END

      SUBROUTINE POLINT(XA,YA,N,X,Y,DY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NMAX=10) 
      DIMENSION XA(N),YA(N),C(NMAX),D(NMAX)


      IF(N.GT.NMAX) THEN 
        WRITE(6,*) 'POLINT: NMAX TOO SMALL'
        STOP
      ENDIF


      NS=1
      DIF=DABS(X-XA(1))
      DO 11 I=1,N 
        DIFT=DABS(X-XA(I))
        IF (DIFT.LT.DIF) THEN
          NS=I
          DIF=DIFT
        ENDIF
        C(I)=YA(I)
        D(I)=YA(I)
11    CONTINUE
      Y=YA(NS)
      NS=NS-1
      DO 13 M=1,N-1
        DO 12 I=1,N-M
          HO=XA(I)-X
          HP=XA(I+M)-X
          W=C(I+1)-D(I)
          DEN=HO-HP
          IF(DEN.EQ.0.0D0)PAUSE
          DEN=W/DEN
          D(I)=HP*DEN
          C(I)=HO*DEN
12      CONTINUE
        IF (2*NS.LT.N-M)THEN
          DY=C(NS+1)
        ELSE
          DY=D(NS)
          NS=NS-1
        ENDIF
        Y=Y+DY
13    CONTINUE
      RETURN
      END




       INTEGER FUNCTION IZOFIS( IS )

C***********************************************************************
C  Returns atomic number of a given species, assigned by routine ATOM
C  Written by D. Sanchez-Portal. Oct, 1996 
C**************************INPUT****************************************
C  INTEGER IS     : Species index
C**************************OUTPUT***************************************
C  INTEGER IZOFIS : Atomic number
C**************************BEHAVIOUR************************************
C  0) Before using IZOFIS, the pseudopotential must be initialized 
C     by calling ATOM for each atomic species required.
C  1) Prints a message and stops when no data exists for IS.
C**********************************************************************

         include 'atom.h'

 
         integer
     .    is,iztb(nsmax),ismax

          

         common/ciztb/iztb
         common/control/ismax

         if ((is.lt.1).or.(is.gt.ismax)) then 
            write(6,*) 'IZOFIS: THERE ARE NO DATA FOR IS=',IS
            write(6,*) 'IZOFIS: ISMIN= 1, ISMAX= ',ismax
            STOP
         endif


 
         izofis=iztb(is)


         return

         end



        SUBROUTINE CHOVERLP(IS1,IS2,RMX,CORR,CORR2,AUX)



C***********************************************************************
C  Returns a table with the difference between the electrostatic energy 
C  of two spherical charge-densities and two punctual charges with the 
C  same total charge as a function of the distance between the centers 
C  of these charge densities. 
C  Written by D.Sanchez-Portal. March, 1997.(from routine MATEL, written 
C  by Jose M. Soler)
C*************************INPUT*****************************************
C  INTEGER IS1,IS2             :  Species indexes.
C  EXTERNAL PSCH(IS,R,CH,GRCH) :  This functions provides the
C                                 'local-pseudopotential charge density'
C                                 for each specie and its gradient
C                                 at point R.
C  RMX                         :  Maximum range of the correction.
C*************************OUTPUT****************************************
C  CORR(NTBMAX)                :  Electrostatic correction energy.
C  CORR2(NTBMAX)               :  Table with the second derivative 
C                                 of CORR for spline interpolation.
C  RMX                         :  Rmx is zero in output is one of 
C                                 the 'atoms' is not an atom but 
C                                 just a floating basis set. 
C*************************UNITS*****************************************
C Distances in Bohr.
C Energy in Rydbergs.
C***********************************************************************



C****************PRECISION**********************************************
C
        IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
C
C***********************************************************************


C******************INTERNAL PARAMETERS**********************************
C
C Internal precision parameters  ------------------------------------
C NQ is the number of radial points in reciprocal space.
C Npoint , 2npoint+1 is the number of points used by RATINT in the 
C interpolation.
C Q2CUT is the required planewave cutoff for the expansion of
C the 'local-pseudopotential atomic charge density'
C  (in Ry if lengths are in Bohr).
C TINY is a small number to check the precision of the charge density
C integration.
C
C***********************************************************************

        INCLUDE    'atom.h'
        PARAMETER ( NQ     =  512   )
        PARAMETER ( NPOINT =  4     ) 
        PARAMETER ( Q2CUT  =  2.5D3 )
        PARAMETER ( CHERR   =  5.D-2 )

C
C**********************************************************************

C********************ARRAYS DECLARATION********************************
C
        DIMENSION 
     .    CH(0:NQ,2),VTB(NTBMAX,2),CORR(NTBMAX),
     .    CORR2(NTBMAX),AUX(NTBMAX),V(0:NQ,2),
     .    GRCH(3),RX(3),QVAL(0:LMAXD,2),RAUX(2*NPOINT+1)

        EXTERNAL PSCH
C
C**********************************************************************

C***********************PI********************************************* 
C
          PI= 4.D0 * ATAN(1.D0)       
          CONS= 1.0d0/(2.0d0*PI)**1.5D0
C
C***********************************************************************

C******************CUT-OFF IN REAL AND RECIPROCAL SPACE*****************
C
           QMAX =  DSQRT( Q2CUT )
           RMAX = PI * NQ / QMAX
           IF(RMX.GT.RMAX) THEN  
              WRITE(6,*) 'CHOVERLP: THE NUMBER OF INTEGRATION',
     .       ' POINTS MUST BE INCREASED'
              STOP
           ENDIF 
           DELT=PI/QMAX
           C=4.0D0*PI*DELT
           DLT=RMX/(NTBMAX-1)
C
C*********************************************************************** 
     

C*********RADIAL CHARGE DENSITIES(CHECKING TOTAL CHARGE)****************
C
          IZ1=IZOFIS(IS1)
          IZ2=IZOFIS(IS2)

          IF((IZ1.LT.0.0D0).OR.(IZ2.LT.0.0D0)) THEN 
              DO ITB=1,NTBMAX
                 CORR(ITB)=0.0D0
                 CORR2(ITB)=0.0D0
              ENDDO 
              RMX=0.0D0
              RETURN
          ENDIF

C***********CALCULATING TOTAL VALENCE CHARGE FOR EACH ATOM**************
C
          DO L=0,LMAXD
             QVAL(L,1)=0.0D0
             QVAL(L,2)=0.0D0
          ENDDO  
          CALL QVLOFZ(IZ1,QVAL(0,1))
          CALL QVLOFZ(IZ2,QVAL(0,2))
          Z1=0.0D0
          Z2=0.0D0
          DO L=0,LMAXD
            Z1=Z1+QVAL(L,1)
            Z2=Z2+QVAL(L,2)
          ENDDO
          IZ1=NINT(Z1)
          IZ2=NINT(Z2)


          Z1=0.0D0
          Z2=0.0D0

          RX(2)=0.0D0
          RX(3)=0.0D0 

          DO IR=0,NQ
             R=IR*DELT
        
             RX(1)=R
             
             CALL PSCH(IS1,RX,CH1,GRCH)
             CALL PSCH(IS2,RX,CH2,GRCH)

             CH(IR,1)=-CH1
             CH(IR,2)=-CH2

             Z1=Z1-C*CH1*R*R    
             Z2=Z2-C*CH2*R*R

           ENDDO
           
           IF((DABS(Z1-IZ1).GT.CHERR).OR.
     .        (DABS(Z2-IZ2).GT.CHERR)) THEN 
              WRITE(6,*) 'CHOVERLP: THE NUMBER OF INTEGRATION',
     .       ' POINTS MUST BE INCREASED'
              WRITE(6,*) 'CHOVERLP: Z1=',Z1,' IZ1=',IZ1
              WRITE(6,*) 'CHOVERLP: Z2=',Z2,' IZ2=',IZ2
             STOP
           ENDIF

           DO IR=0,NQ
             CH(IR,1)=DBLE(IZ1)*CH(IR,1)/Z1
             CH(IR,2)=DBLE(IZ2)*CH(IR,2)/Z2
           ENDDO 
C
C**********************************************************************





C*****REAL SPACE INTEGRATION OF POISSON EQUATION***********************
C          
          
           CALL NUMEROV(NQ,DELT,CH(0,1),V(0,1))
           CALL NUMEROV(NQ,DELT,CH(0,2),V(0,2))
           
           DO ITB=1,NTBMAX
              R=DLT*(ITB-1)
              NR=NINT(R/DELT)
              NMIN=MAX(0,NR-NPOINT)
              NMAX=MIN(NQ,NR+NPOINT)
              NN=NMAX-NMIN+1
              DO IR=1,NN
                 RAUX(IR)=DELT*(NMIN+IR-1) 
              ENDDO 
              CALL RATINT(RAUX,V(NMIN,1),NN,R,VV1,VD)
              CALL RATINT(RAUX,V(NMIN,2),NN,R,VV2,VD)
 
              VTB(ITB,1)=VV1
              VTB(ITB,2)=VV2
           ENDDO 
         

C
C**********************************************************************


C****FOURIER-TRANSFORM OF RADIAL CHARGE DENSITY************************
C
           CALL RADFFT( 0, NQ, RMAX, CH(0,1), CH(0,1) )
           CALL RADFFT( 0, NQ, RMAX, CH(0,2), CH(0,2) )
C
C**********************************************************************


C*****NEUTRALIZE CHARGE DENSITY FOR FOURIER-SPACE CALCULATION**********
C
           DO IQ=0,NQ
              R=IQ*QMAX/NQ

              CH1 = (CH(IQ,1)-IZ1*CONS)*CH(IQ,2)
              CH2=  (CH(IQ,2)-IZ2*CONS)*CH(IQ,1)
              
              CH(IQ,1) = CH1
              CH(IQ,2) = CH2

           ENDDO
C
C**********************************************************************



C*********THE ELECTROSTATIC ENERGY CORRECTION IS STORED IN 'CORR'******
C  
            DO IR=1,NTBMAX

               R=DLT*(IR-1)
               ENERG1=0.0d0
               ENERG2=0.0d0


               DO IQ=0,NQ
                  Q=IQ*QMAX/NQ
                  Q=Q*R 
                  ENERG1=ENERG1+BESSPH(0,Q)*CH(IQ,1)
                  ENERG2=ENERG2+BESSPH(0,Q)*CH(IQ,2)
               ENDDO 

               ENERG1=ENERG1*QMAX/NQ
               ENERG2=ENERG2*QMAX/NQ
   
               ENERG2=ENERG2*4.0D0*(2.0d0*PI)**2
               ENERG1=ENERG1*4.0D0*(2.0d0*PI)**2
              
               ENERG1=-(ENERG1*R)-(IZ2*(VTB(IR,1)*R-IZ1))
               ENERG2=-(ENERG2*R)-(IZ1*(VTB(IR,2)*R-IZ2))
  
               CORR(IR)=0.5D0*(ENERG1+ENERG2)

            ENDDO 

C
C*******************************************************************


C********CREATING A TABLE WITH SECOND DERIVATIVES FOR SPLINES*******
C
            DEV1=1.0D50
            DEVN=1.0D50
            CALL SPLINE(DLT,CORR,NTBMAX,DEV1,DEVN,CORR2,AUX)

C
C******************************************************************
      
          RETURN
          END




           SUBROUTINE NUMEROV(NR,DELT,Q,V)


C*********************************************************************
C   Being Q(r) a spherical charge density in a homogeneus radial mesh
C   with distance DELT between consecutive points, this routine returns
C   the electrostatic potential generated by this charge distribution.
C   Written by D. Sanchez-Portal, March 1997.
C********************INPUT********************************************
C   INTEGER NR      :    Number of radial points.
C   REAL*8  DELT    :    Distance between consecutive points.
C   REAL*8  Q(0:NR) :    Spherical charge density.
C********************OUTPUT*******************************************
C   REAL*8  V(0:NR) :    Electrostatic potential at mesh points.
C********************BEHAVIOUR****************************************
C   Qtot/r asimptotic behaviour is imposed.
C*********************************************************************

           IMPLICIT DOUBLE PRECISION (A-H,O-Z)
 
           DIMENSION Q(0:*),V(0:*) 



            PI=4.0D0*DATAN(1.0D0)
            FOURPI=4.0D0*PI

C********************NUMEROV ALGORITHM******************************* 
C
             V(0)=0.0D0
             V(1)=1.0D0

             DO IR=2,NR
              V(IR)=2.0D0*V(IR-1)-V(IR-2) - FOURPI*DELT**3*
     .      ( Q(IR)*IR+10.0D0*Q(IR-1)*(IR-1)+Q(IR-2)*(IR-2) )/12.0D0
             ENDDO 
C
C********************************************************************

C******************CALCULATE TOTAL CHARGE****************************
C
   
             QTOT=0.0D0
             DO IR=1,NR
               R=IR*DELT
               QTOT=QTOT+R*R*Q(IR)
             ENDDO
             QTOT=4.0D0*PI*QTOT*DELT
C
C********************************************************************

C******* FIXING QTOT/R ASIMPTOTIC BEHAVIOUR**************************
C

             CONS=(QTOT-V(NR))/(NR*DELT)
             
             DO IR=1,NR
                R=IR*DELT
                V(IR)=V(IR)/(IR*DELT)+CONS
             ENDDO 
             V(0)=(4.0D0*V(1)-V(2))/3.0D0
C
C********************************************************************

             RETURN 
             END
              
       






          subroutine psch(is,r,ch,grch)


C***********************************************************************
C Returns 'local-pseudotential charge density'.
C Written by D.Sanchez-Portal. March, 1997
C************************INPUT******************************************
C INTEGER IS     :  Species index
C REAL*8  R(3)   :  Point vector, relative to atom
C ***********************OUTPUT*****************************************
C REAL*8  CH     :  Value of local-pseudotential charge density.
C REAL*8  GRCH(3):  Gradient of local-pseudotential charge density.
C************************UNITS******************************************
C Distances in Bohr
C Energies in Rydbergs
C Density in electrons/Bohr**3
C************************BEHAVIOUR**************************************
C  0) Before using PSCH, the pseudopotential must be initialized
C     by calling ATOM for each atomic species required
C  1) Prints a message and stops when no data exits for IS.
C  2) Returns exactly zero when |R| > Rchloc
C***********************************************************************
 
          implicit double precision (a-h,o-z)
          
          include 'atom.h'

          double precision 
     .     r(3),ch,grch(3),chloctab((ntbmax+1),2,nsmax)
 

          integer
     .     is,ismax
 
          common/control/ismax
          common/cmchloc/chloctab



          if ((is.lt.1).or.(is.gt.ismax)) then
            write(6,*) 'PSCH: THERE ARE NO DATA FOR IS=',IS
            write(6,*) 'PSCH: ISMIN= 1, ISMAX= ',ismax
            STOP
          endif

          dloc=chloctab(1,2,is)
          if(dabs(dloc).lt.1.0d-8) then 
            ch=0.0d0 
            grch(1)=0.0d0 
            grch(2)=0.0d0
            grch(3)=0.0d0 
            return
          endif

          delt=chloctab(1,1,is) 
          rcmx=delt*(ntbmax-1)
          rmod=0.0d0
          do i=1,3
            rmod=rmod+r(i)*r(i)
          enddo
          rmod=dsqrt(rmod)

          if(rmod.gt.rcmx-1.d-12) then
             ch=0.0d0
             grch(1)=0.0d0
             grch(2)=0.0d0
             grch(3)=0.0d0
        
          else
            call splint(delt,chloctab(2,1,is),chloctab(2,2,is),ntbmax,
     .        rmod,ch,dchdr)

             rmod=rmod+1.0d-20
           
             grch(1)=dchdr*r(1)/rmod
             grch(2)=dchdr*r(2)/rmod
             grch(3)=dchdr*r(3)/rmod
       

          endif

 
          return
 
          end





        subroutine rc_vs_e(a,b,r,vps,
     .      ve,nrmax,l,el,rnodo)
      
        implicit double precision (a-h,o-z) 

     
        parameter(nrmx=3000)

        double precision r(nrmax),
     .   el,vps(nrmax),g(nrmx),drdi(nrmx),h(nrmx),ve(nrmax)
        
         integer  l
       
        if (nrmax.gt.nrmx) then   
         write(6,*) 'Rc_vs_E : Nrmx must be increased to at least',
     .         nrmax
        endif

        dexpa=dexp(a)
        ab=a*b
        do ir=1,nrmax
           
           drdi(ir)=ab
c          r2=ab/a-b

c          if(dabs(r2-r(ir)).gt.1.0d-6) then 
c                write(6,*) ir, dabs(r2-r(ir)),r2,r(ir)
c          endif
           ab=dexpa*ab
        enddo            
        rmax=r(nrmax)

 
          do ir=2,nrmax
            hi=vps(ir)+ve(ir)+dble(l*(l+1))/r(ir)**2-el
            hi=hi*(drdi(ir)**2)
            hi=hi+0.25d0*a**2
            h(ir)=hi
          enddo 
          h(1)=h(2)

          
          g(1)=0.0d0
          g(2)=1.0d0
          gold=1.0d0
          rnodo=0.0d0
          do ir=3,nrmax

            hi=(10.0d0*h(ir-1)*g(ir-1)+h(ir-2)*g(ir-2))/12.0d0
 
            hi=hi+2.0d0*g(ir-1)-g(ir-2)

            g(ir)=hi/(1.0d0-h(ir)/12.0d0)


            if((g(ir).eq.0.0d0).or.(g(ir)*gold.lt.0.0d0)) then
                  r0=r(ir-1)
                  g0=gold
                  r1=r(ir)
                  g1=g(ir)
                  rnodo=r0-g0*(r1-r0)/(g1-g0)
                  goto 50
            endif
            
            gold=g(ir)

          enddo 

50        continue 


        
          return 
          end

          
             





        subroutine polarization(a,b,r,psi,vps,
     .      ve,nrc,l,el,psipol,nrmax)
      
        implicit double precision (a-h,o-z) 

C*************************************************************
C      This routine calculate the polarization (unoccupied) 
C      orbitals with angular momentum l from the atomic 
C      orbitals with l-1 angular momentum, using a perturbative
C      approach.
C      The routine solve and inhomogeneus version of 
C      Schrodinger eqn.  
C      It is not an optimized algorithm!!!!!!!!!!!!!!!!!
C************************************************************
C************************************************************
C       cons1 is a big number. If it is choosen too 
C       big, too many iterations will be needed.
C       If cons1 is too small it may happen that 
C       the routine never converges to the solution.
C
C       If Rc is too big the very simple (unoptimized)
C       algorithm used here cannot converge. That is 
C       why Rc's are required to be smaller than Rint,
C       where Rint should not be greater than aprox. 15 Bohr
C       Written by Daniel Sanchez-Portal, July 1997
C************************************************************ 
     
        parameter(nrmx=3000,nrmin=1,niter=1000,
     .                    cons1=1.0d5,rint=15.0d0)

        double precision r(nrmax),psi(nrmax),psipol(nrmax),
     .   el,vps(nrmax),g(nrmx),drdi(nrmx),h(nrmx),ve(nrmax)
        
         integer  l
       
        if ((nrmax.gt.nrmx).or.(nrc.gt.nrmx)) then   
         write(6,*) 'POLARIZATION: Nrmx must be increased to at least',
     .        max(nrmax,nrmx)
        endif

        dexpa=dexp(a)
        ab=a*b
        do ir=1,nrmax
           
           drdi(ir)=ab
c          r2=ab/a-b

c          if(dabs(r2-r(ir)).gt.1.0d-6) then 
c                write(6,*) ir, dabs(r2-r(ir)),r2,r(ir)
c          endif
           ab=dexpa*ab
        enddo            
        rmax=r(nrmax)

        if(rmax.gt.rint) then 
          write(6,*) 'POLARIZATION: Rc for the polarization orbitals'
          write(6,*) 'must be smaller than ',rint,' Bohr'
          stop
        endif

        do ir=nrc+1,nrmax
          psi(ir)=0.0d0 
        enddo 
 
          reduc=-0.5d0
          dl=1

          do ir=2,nrmax
            hi=vps(ir)+ve(ir)+(l+dl)*(l+dl+1)/r(ir)**2-el
            hi=hi*(drdi(ir)**2)
            hi=hi+0.25d0*a**2
            h(ir)=hi
          enddo 
          h(1)=h(2)

          rnd1=0.0d0
          index=1
          nnodes=1
          do iter=1,niter
           rnodo=0.0d0
           if(index.eq.1) then 
              cons=cons1
              index=2
           else
              cons=c2
           endif
          
          g(1)=0.0d0
          do ir=1,nrmin+1
            g(ir)=cons*(r(ir)**(l+dl+1))/dsqrt(drdi(ir))
          enddo 
          gold=g(nrmin+1)

          nnd=0
          gmax=0.0d0
          do ir=nrmin+2,nrmax
            hi=-((r(ir)*psi(ir)+10.0d0*r(ir-1)*psi(ir-1)
     .         +r(ir-2)*psi(ir-2))/12.0d0)

            hi=hi+(10.0d0*h(ir-1)*g(ir-1)+h(ir-2)*g(ir-2))/12.0d0
 
            hi=hi+2.0d0*g(ir-1)-g(ir-2)

            g(ir)=hi/(1.0d0-h(ir)/12.0d0)
            gmax=max(gmax,dabs(g(ir)))
            if((g(ir).eq.0.0d0).or.(g(ir)*gold.lt.0.0d0)) then

              nnd=nnd+1
                
              if (nnd.eq.nnodes) then 
                  r0=r(ir-1)
                  g0=gold
                  r1=r(ir)
                  g1=g(ir)
                  rnodo=r0-g0*(r1-r0)/(g1-g0)
                  goto 50
              endif 
           endif
            
           gold=g(ir)


          enddo 

 50        continue




          grmx=g(nrmax)/gmax

          if(((dabs(rnodo-rmax).lt.1.0d-3).and.
     .      (dabs(grmx).lt.1.0d-7) )
     .        .or. 
     .        ((rnodo.eq.0.0d0).and.
     .        (dabs(grmx).lt.1.0d-7) ) ) goto 100

**********Para empezar hay que encontrar un nodo!!!!**********************

          if((rnd1.eq.0.0d0).and.(rnodo.eq.0.0d0)) then  
             c2=(-reduc)*cons
             if(dabs(c2).le.1.0d0/dabs(cons1)) then 
               index=1
               rnd1=0.0d0
               reduc=(1.0d0+reduc)/2.0d0
             endif  
          elseif((rnd1.eq.0.0d0).and.(rnodo.ne.0.0d0)) then
              rnd1=rnodo
              c1=cons
              c2=2.0d0*cons
          endif  
       
**************************************************************************

      
********Ahora hay que ir llevandose el nodo hacia Rc**********************
          if((rnd1.ne.0.0d0).and.(rnodo.eq.0.0d0)) then 
              c2=0.50d0*(c1+c2)
          elseif((rnd1.ne.0.0d0).and.(rnodo.ne.0.0d0)) then 
              if(dabs(rnd1-rnodo).gt.1.0d-6)then 
                 dff1=dabs(rnd1-rmax) 
                 dff2=dabs(rnodo-rmax) 
                 if(dff1.gt.dff2) then 
                   savecons=c2
                   c2=(rmax-rnd1)*(c1-c2)/(rnd1-rnodo)+c1
                   c1=savecons
                   rnd1=rnodo
                 else
                   c2=1.10d0*c2
                 endif 
              else

               if(dabs(cons).gt.1.0d15) then 
                  nnodes=nnodes+1
                  index=1
                  rnd1=0.0d0
               else
                 c2=1.1d0*c2
               endif  

              endif 
           endif 

          enddo 
          write(6,*)'POLARIZATION: Iteration to find the polarization'
          write(6,*)'orbital has failed !!!!!!!!!'
          write(6,*)'Please try with a Rc no bigger than ',rnd1,' Bohr'
          stop
                          
100       continue
          dnrm=0.0d0
          do ir=1,nrmax
             g(ir)=g(ir)*dsqrt(drdi(ir))
             dnrm=dnrm+drdi(ir)*(g(ir))**2
          enddo 
          dnrm=dsqrt(dnrm)
          do ir=1,nrmax
               psipol(ir) = g(ir)/dnrm
          enddo 

 

          end

          
             


         subroutine parabola(a,b,nrc,rphi,rnrm,l,
     .              splnorm,cons,gexp,nm) 
 

          implicit double precision (a-h,o-z) 
          
          parameter (Ratio=0.61803399D0)       
          double precision rphi(nrc),rnrm(nrc) 


C         Hallar el maximo de la funcion de onda
          rfirst=0.05d0
          nfirst=nint(dlog(rfirst/b+1.0d0)/a)+1
          slopold=0.0d0
          do ir=nfirst,nrc
             slop=rphi(ir)-rphi(ir-1) 
             if(slop*slopold.lt.0.0d0) goto 10
             slopold=slop
          enddo 
10        continue
          nrmax=ir-1
          rmin=b*(dexp(a*(nrmax-1))-1.0d0) 
          rmin=1.01d0*rmin
          nmin=nint(dlog(rmin/b+1.0d0)/a)+1   
          nmin=max(nmin,2)
          nmax=nrc-1 
          
          call findp(nrc,nmin,rphi,a,b,l,cmin,gmin) 
          rmin=b*(dexp(a*(nmin-1))-1.0d0) 
          call nrmpal(cmin,gmin,rmin,l,rnrmin)
          rnrmin=1.0d0+rnrmin-rnrm(nmin)
 
          call findp(nrc,nmax,rphi,a,b,l,cmax,gmax)
          rmax=b*(dexp(a*(nmax-1))-1.0d0) 
          call nrmpal(cmax,gmax,rmax,l,rnrmax) 
          rnrmax=1.0d0+rnrmax-rnrm(nmax)         
          
          valmin=(splnorm-rnrmin)**2
          valmax=(splnorm-rnrmax)**2

          nmed=0.5d0*(nmin+nmax) 
          do iter=1,nrc
            call findp(nrc,nmed,rphi,a,b,l,cmed,gmed)
            rmed=b*(dexp(a*(nmed-1))-1.0d0) 
            call nrmpal(cmed,gmed,rmed,l,rnrmed) 
            rnrmed=1.0d0+rnrmed-rnrm(nmed)
              
            valmed=(splnorm-rnrmed)**2

            if((valmed.lt.valmin).and.(valmed.lt.valmax)) goto 20
            nmed=nmed+1
            if(nmed.eq.nmax) goto 15
          enddo 
15        continue
          nmed=0.5d0*(nmin+nmax)
          do iter=1,nrc
             call findp(nrc,nmed,rphi,a,b,l,cmed,gmed)
             rmed=b*(dexp(a*(nmed-1))-1.0d0)
             call nrmpal(cmed,gmed,rmed,l,rnrmed)
             rnrmed=1.0d0+rnrmed-rnrm(nmed)

             valmed=(splnorm-rnrmed)**2


             if((valmed.lt.valmin).and.(valmed.lt.valmax)) goto 20
             nmed=nmed-1
             if(nmed.eq.nmin) goto  20
          enddo 
20        continue

          if(nmed.eq.nmin) then 
             if(valmin.lt.valmax) then 
                nm=nmin
                cons=cmin
                gexp=gmin
             elseif(valmax.le.valmin) then 
                nm=nmax
                cons=cmax
                gexp=gmax
             endif
             return
           endif 
 
C    Ahora ya tenemos el minimo en un intervalo

           
            n0=nmin
            n3=nmax
            if(abs(nmed-nmax).gt.abs(nmed-nmin)) then 
               n1=nmed
               n2=nmed+nint((1.0-ratio)*(nmax-nmed))
            else
               n2=nmed
               n1=nmed-nint((1.0-ratio)*(nmed-nmin))
            endif
            call findp(nrc,n1,rphi,a,b,l,c1,g1)
            r=b*(dexp(a*(n1-1))-1.0d0)
            call nrmpal(c1,g1,r,l,rn1)
            rn1=1.0d0+rn1-rnrm(n1)
            val1=(splnorm-rn1)**2

            call findp(nrc,n2,rphi,a,b,l,c2,g2)
            r=b*(dexp(a*(n2-1))-1.0d0)
            call nrmpal(c2,g2,r,l,rn2)
            rn2=1.0d0+rn2-rnrm(n2)
            val2=(splnorm-rn2)**2
 
1           if(abs(n3-n0).gt.1) then 
              if(val2.lt.val1) then 
               n0=n1
               n1=n2
               n2=nint(ratio*n1+(1-ratio)*n3)
               val0=val1
               val1=val2
               call findp(nrc,n2,rphi,a,b,l,c2,g2)   
               r=b*(dexp(a*(n2-1))-1.0d0)
               call nrmpal(c2,g2,r,l,rn2)
               rn2=1.0d0+rn2-rnrm(n2)
               val2=(splnorm-rn2)**2
              else
               n3=n2
               n2=n1
               n1=nint(ratio*n2+(1-ratio)*n0)
               val3=val2
               val2=val1
               call findp(nrc,n1,rphi,a,b,l,c1,g1)
               r=b*(dexp(a*(n1-1))-1.0d0)
               call nrmpal(c1,g1,r,l,rn1)
               rn1=1.0d0+rn1-rnrm(n1)
               val1=(splnorm-rn1)**2
              endif
             goto1
             endif 
             if(val1.lt.val2) then 
                  gexp=g1
                  cons=c1
                  nm=n1
             else
                 gexp=g2
                 cons=c2
                 nm=n2
             endif

             return


            end




          subroutine findp(nrc,nm,rphi,a,b,l,c1,c2)

          implicit double precision (a-h,o-z) 
          double precision rphi(nrc)
          
          rm=b*(dexp(a*(nm-1)) + 1.0d0) 
          rm1=b*(dexp(a*(nm-2)) + 1.0d0)
          rm2=b*(dexp(a*(nm)) + 1.0d0)
          drdi=a*b*dexp(a*(nm-1))

          frsp=rphi(nm)/rm
          dfrsp=0.5d0*(rphi(nm+1)/rm2
     .       -rphi(nm-1)/rm1)
          dfrsp=dfrsp/drdi

          c1= 0.5d0*(dfrsp*rm-l*frsp)/(rm**(l+2))
          c2= frsp/(rm**l)-c1*(rm**2)

          
 
          end
        


 
          subroutine nrmpal(c1,c2,r,l,dnrm)
        
          implicit double precision (a-h,o-z)
          
          dnrm=(c1**2)*r**(2*l+7)/(2*l+7) 
     .     + (2.0d0*c1*c2)*r**(2*l+5)/(2*l+5) 
     .     + (c2**2)*r**(2*l+3)/(2*l+3)


          end 
