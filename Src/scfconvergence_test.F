      module m_scfconvergence_test
      private
      public :: scfconvergence_test
      CONTAINS

      subroutine scfconvergence_test( first, iscf, last, dDmax,
     $                                conv_harris, conv_etot,
     $                                converged)
      USE siesta_options
      use siesta_cml
      use m_wallclock, only : wallclock
      use parallel, only: IOnode
      use write_subs
      use m_energies
      use m_convergence, only: converger_t
      use m_convergence, only: add_value, is_converged
#ifdef TRANSIESTA
      use m_ts_global_vars, only: TSinit, TSrun, TSiscf
      use m_ts_options, only: TSmode
      use m_pulay, only: init_pulay_arrays
#endif /* TRANSIESTA */
      implicit none

      integer :: iscf
      logical :: first
      logical :: last

      real(dp), intent(in) :: dDmax     ! Max. change in dens. matrix
      type(converger_t), intent(inout)  :: conv_harris, conv_etot
      logical, intent(out)              :: converged
!------------------------------------------------------------------------- BEGIN

      call timer( 'SCFconv', 1 )
      ! convergence test

      DEna = Enascf - Enaatm
      Etot = E0 + DEna + DUscf + DUext + Exc + Ecorrec+Emad+Emm+
     &       Emeta
      Eharrs = Etot + DEharr

      call add_value(conv_harris, eharrs)
      call add_value(conv_etot, etot)

      FreeE  = Etot - Temp * Entropy

      ! Recalculating the energy in the last iter (for
      ! gridcellsampling) but preserving the value of Eharrs1
      Eharrs1 = Eharrs

      converged = .false.

      Elast = Etot
      if (require_energy_convergence) then
         if (   dDmax.lt.dDtol
     &        .and. is_converged(conv_etot)) then
            converged = .true.
            if (IOnode) then
               write(6,"(a)") "SCF Convergence by Etot+DM criteria"
            endif
         endif
      else if (require_harris_convergence) then
         if (is_converged(conv_harris)) then
            converged = .true.
            if (IOnode) then
               write(6,"(a)") "SCF Convergence by Harris criterion"
            endif
         endif
      else
        if (dDmax.lt.dDtol) converged = .true.
      endif

      ! Print energies
      if (IOnode) then
        call siesta_write_energies( first, iscf, dDmax )

        if (harrisfun) then
          write(6,"(/a,f14.6,/)") 'siesta: Eharris(eV) = ',Eharrs/eV
          if (cml_p) then
            call cmlStartPropertyList(mainXML, title='SCF Cycle')
            call cmlAddProperty(xf=mainXML, value=Eharrs/eV,
     .       units="siestaUnits:eV", dictRef="siesta:Eharrs", 
     .       fmt="r7")
            call cmlEndPropertyList(mainXML)
          endif
        endif
       
        ! flush stdout
        call pxfflush(6)
        call wallclock("-------------- end of scf step")
      endif

      ! In principle, this should be the last step if we
      ! have converged...
      last = converged

#ifdef TRANSIESTA
      ! ... except that we might continue for TranSiesta
      ! This should be made more transparent

!     TSS Begin
      if (TSmode .and. last .and. TSinit) then
         last   = .false.     ! we're only done with the initial diagon run
         TSinit = .false.     ! now we start the TRANSIESTA run
         TSrun = .true.
         if (TSiscf .eq. 1) call timer( 'IterSCF', 3 ) !TSS
         !
         ! From now on, a new mixing cycle starts,
         ! so we have to reset the Pulay record keeping
         !
         call init_pulay_arrays()

         if(IONode) then
           write(6,'(/a)')
     &'                          ************************       '
           write(6,'(a)')
     &'                          *   TRANSIESTA BEGIN   *       '
           write(6,'(a)')
     &'                          ************************       '
        end if
      end if

      if (TSiscf .eq. 1) then
         call timer( 'TS', 3 )       !TSS (with Green's function generation)
         call timer( 'TS_calc', 3 )  !TSS (only calculating routines)
      end if
      if (TSrun .and. TSiscf < min_nscf ) last = .false.
! Needed for an MD run of TranSiesta
!      if (TSrun .and. last) then
!         ! reset pulays again
!         call init_pulay_arrays()
!         ! Set TSinit to .true. for a continuation run in an MD simulation.
!         TSinit = .true.
!         !
!         TSrun  = .false.
!         TSiscf = 0
!      end if

!     TSS End
#endif /* TRANSIESTA */

      call timer( 'SCFconv', 2 )

!--------------------------------------------------------------------------- END
      END subroutine scfconvergence_test
      end module m_scfconvergence_test
