! =======================
! Basic functionality of 
! concatenating to 
! retrieve function names
#include "basic_func.inc"
! =======================

  use alloc, only: re_alloc, de_alloc

  implicit none

  character(len=*), parameter :: mod_name="class_"//STR_TYPE_NAME//".F90"

  integer, parameter :: sp = selected_real_kind(5,10)
  integer, parameter :: dp = selected_real_kind(10,100)

  type TYPE_NAME_
     integer :: refCount = 0
     character(len=36)   :: id = "null_id"
     !----------------------
     character(len=256)   :: name = "null "//STR_TYPE_NAME
     VAR_TYPE(PREC), pointer  :: val(:,:) => null() ! Nonzero-element values
  end type

  type TYPE_NAME
     type(TYPE_NAME_), pointer :: data => null()
  end type

! Note that "basic_type.inc" adds the PRIVATE directive
! This will also release the requirement to change the local names.
! Only those through public statements should potentially be altered.

  public :: NEW_TYPE, print_type, val

  interface NEW_TYPE
     module procedure newArray2DfromDimensions
     module procedure newArray2DfromNakedArray
  end interface
  
  interface val
     module procedure valArray2D
  end interface val

  interface print_type
     module procedure printArray2D
  end interface print_type

!========================
#include "basic_type.inc"
!========================

  subroutine delete_Data(a2d_data)
    type(TYPE_NAME_) :: a2d_data
    if (associated(a2d_data%val)) then
       call de_alloc( a2d_data%val, &
            name="val "//trim(a2d_data%name),routine=STR_TYPE_NAME)	
    endif
  end subroutine delete_Data
  
  
  subroutine newArray2DFromDimensions(this,n,m,name)
    ! This could be implemented also as an assignment 
    ! (see below)

    type(TYPE_NAME), intent(inout)  :: this
    integer, intent(in)           :: n, m
    character(len=*), intent(in), optional  :: name

    integer :: stat

    ! We release the previous incarnation
    ! This means that we relinquish access to the previous
    ! memory location. It will be deallocated when nobody
    ! else is using it.
   
    call init(this)

    if (present(name)) then
       this%data%name = trim(name)
    else
       this%data%name = "("//STR_TYPE_NAME//" from n,m)"
    endif

    call re_alloc(this%data%val,1,n,1,m, &
         name="val "//trim(this%data%name),routine=STR_TYPE_NAME)	
    this%data%val(:,:) = CCAT(0.0_,PREC)

    call tag_new_object(this)

  end subroutine newArray2DFromDimensions

  subroutine newArray2DfromNakedArray(this, val, name)
    !..................................................................
    !...................................................................
    type(TYPE_NAME), intent(inout) :: this
    VAR_TYPE(PREC), intent(in)     :: val(:,:)
    character(len=*), intent(in), optional  :: name

    integer :: n, m

    call init(this)

    n = size(val,dim=1)
    m = size(val,dim=2)

    if (present(name)) then
       this%data%name = trim(name)
    else
       this%data%name = "("//STR_TYPE_NAME//" from naked array)"
    endif

    call re_alloc(this%data%val,1,n,1,m, &
        name="val "//trim(this%data%name),routine=STR_TYPE_NAME)	
    this%data%val(:,:) = val(:,:)

    call tag_new_object(this)
    
  end subroutine newArray2DfromNakedArray


  function valArray2D(this) result(p)
    type(TYPE_NAME), intent(in) :: this
    VAR_TYPE(PREC), pointer     :: p(:,:) !=> null()
    
    p => this%data%val
  end function valArray2D

  subroutine printArray2D(this)
    type(TYPE_NAME), intent(in)  :: this
    
    integer :: n, m
    
    if (.not. associated(this%data)) then
       print "(a)", STR_TYPE_NAME//" Not Associated"
       RETURN
    endif
    
    n = size(this%data%val,dim=1)
    m = size(this%data%val,dim=2)
    
    print "(a,i0,a,i0,a,i0,a)", "  <"//STR_TYPE_NAME//":"//trim(this%data%name)// &
                                " n=",  n," m=",m,   &
                                ", refcount: ", refcount(this),">"
  end subroutine printArray2D

#undef TYPE_NAME
#undef STR_TYPE_NAME
#undef TYPE_NAME_
#undef NEW_TYPE
#undef VAR_TYPE
#undef PREC
