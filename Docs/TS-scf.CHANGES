----------------------------------------------------
December 1, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-229
Added error message if diagonalization errors out tbt_diag

* Added print-out of error message if diagonalization
  fails.

modified:
  Util/TS/TBtrans/m_tbt_diag.F90

----------------------------------------------------
November 30, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-228
Possible bugfix for non-standard MPI libraries

* Certain MPI libraries cannot handle an 
   MPI_WAIT with a MPI_REQUEST_NULL request
  handle.
  Hence, we now test for this on each instance.

  I think this is bad practice, but it may be 
  required for certain libraries.

modified:
  Src/m_io_s.F90
  Src/m_ncdf_io.F90

----------------------------------------------------
November 28, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-227
Bugfix for supercell calculation for negative coord

* When the user has a mixture of out-of unit-cell
  and in-of unit-cell coordinates the supercell
  calculation was erroneous.
  The calculation "should" only be the inside
  calculation. 
  This has been corrected.

  This also corrects a bug for an obscure structure
  sent by Mads Engelund. 
  
modified:
  Src/m_supercell.f90

----------------------------------------------------
November 25, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-226
Removed unneeded variables in transiesta routines

modified:
  Src/m_sparsity_handling.F90
  Src/m_ts_options.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90

----------------------------------------------------
November 25, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-225
Changed a few defaults for transiesta

* The eta value on the non-equilibrium
  contour now only exists in the electrodes.
  Just as in tbtrans.
  Hence, the user _is_ forced to use the device
  eta if needed.

* If the bias for tbtrans and transiesta does
  not match, then a WARNING message is printed.
  This is merely to bring attention to the
  user that interpolation is required.

* Added tbtrans transfer from old to new using the ts2ts
  program.

* The default tbtrans eta value is now the TS.Elecs.Eta
  value.

modified:
  Src/m_ts_options.F90
  Util/TS/TBtrans/m_tbt_contour.F90
  Util/TS/TBtrans/m_tbt_options.F90
  Util/TS/ts2ts/ts2ts.f90

----------------------------------------------------
November 25, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-224
Added timings for tbtrans

* Removed some unused variables in:
  - m_timer
  - m_ts_dm_update
  - m_ts_fullk
  - m_ts_trig
  - m_ts_trik

* Made sure the energy used in the orbital current 
  is the real part (not the imaginary part)

* Added timings to nearly all tbtrans routines.
  This enables a very fine timing report to see where
  the time is mostly spent.

  NOTE: I am not timing the saving routines, thus any
  "missing" time is spent in the IO routines.

* Made sparsity pattern names a lot smaller

modified:
  Src/create_Sparsity_SC.F90
  Src/create_Sparsity_Union.F90
  Src/m_pivot_array.f90
  Src/m_sparsity_handling.F90
  Src/m_timer.F90
  Src/m_ts_dm_update.F90
  Src/m_ts_fullk.F90
  Src/m_ts_options.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/ts_init.F90
  Util/TS/TBtrans/m_tbt_tri_scat.F90
  Util/TS/TBtrans/m_tbt_trik.F90

----------------------------------------------------
November 24, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-223
Bugfix for serial compilation

* Bugfix for tbtrans and transiesta to be
  able to compile in serial.

modified:
  Src/m_ncdf_io.F90
  Src/m_ncdf_siesta.F90
  Util/TS/TBtrans/m_tbt_proj.F90
  Util/TS/TBtrans/m_tbt_sigma_save.F90

----------------------------------------------------
November 24, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-222
Changed name for orbital current

modified:
  Util/TS/TBtrans/m_tbt_options.F90
  Util/TS/TBtrans/m_tbt_proj.F90

----------------------------------------------------
November 24, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-221
Bugfix for spin calculations in TBT

* Added TS.Fermi.Initial to let the user
  set the Fermi-level in case of initialising
  the DM.

* Projection DOS is now not printed out.
  It is currently not implemented.

modified:
  Src/m_new_dm.F90
  Src/m_ts_options.F90
  Util/TS/TBtrans/m_tbt_options.F90
  Util/TS/TBtrans/m_tbt_proj.F90
  Util/TS/TBtrans/m_tbt_save.F90
  Util/TS/TBtrans/m_tbt_trik.F90

----------------------------------------------------
November 23, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-220
Divided code for diagonalization of H in TBT

* Diagonalization for the Hamiltonian when
  projecting the molecule in tbtrans
  has been separated into two modules.

  Now diagonalization is in a generic module.

  m_tbt_diag

added:
  Util/TS/TBtrans/m_tbt_diag.F90
modified:
  Util/TS/TBtrans/Makefile
  Util/TS/TBtrans/m_tbt_proj.F90

----------------------------------------------------
November 23, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-219
Added explicit coordinate

* Added explicit coordinate to the code
  This allows one to do
  MD.TypeOfRun explicit

added:
  Src/m_exp_coord.F90
modified:
  Src/Makefile
  Src/m_new_dm.F90
  Src/save_density_matrix.F
  Src/siesta_init.F
  Src/siesta_move.F
  Src/siesta_options.F90
  Src/state_init.F
  Src/struct_init.F
  Src/write_subs.F
  Util/Denchar/Src/Makefile
  Util/Gen-basis/Makefile
  Util/Grimme/Makefile
  Util/Helpers/Makefile
  Util/STM/ol-stm/Src/Makefile
  Util/TBTrans/Makefile
  Util/TS/TBtrans/Makefile
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile
  Util/VCA/Makefile

----------------------------------------------------
November 23, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-218
Speedup for tbtrans

* Searching for the sparsity indices was extremely
  slow. We now utilise the search function SFIND
  to double the performance! 
  Simply by searching instead of simple look-ups!

* Redid the projection, instead of projecting <i|Gam|j> per
  projection we do it once for all unique projections.
  Thus we save double calculations.
  The code has also been made more clear.

* Enabled bond-currents.
  Both for projected and non-projected regions.
  It takes up a-lot of disk-space, so compression 
  is handy here. 
  
* Divided ncdf_io into two modules.
  - A generic ncdf_io routine to write to netcdf files
  - A ncdf_siesta module to handle specific siesta write

* Added dep_all.sh script in the utility folder
  to easily re-create all dependencies.

removed:
  Util/Gen-basis/fdf/
  Util/VCA/fdf/
  Util/Vibra/Src/fdf/
modified:
  Src/Makefile
  Src/final_H_f_stress.F
  Src/m_ncdf_io.F90
  Src/m_region.F90
  Src/m_ts_electype.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri_scat.F90
  Src/save_density_matrix.F
  Src/state_init.F
  Src/write_md_record.F
  Util/Denchar/Src/Makefile
  Util/Gen-basis/Makefile
  Util/Grimme/Makefile
  Util/Helpers/Makefile
  Util/Optimizer/Makefile
  Util/STM/ol-stm/Src/Makefile
  Util/TBTrans/Makefile
  Util/TS/TBtrans/Makefile
  Util/TS/TBtrans/m_tbt_options.F90
  Util/TS/TBtrans/m_tbt_proj.F90
  Util/TS/TBtrans/m_tbt_regions.F90
  Util/TS/TBtrans/m_tbt_save.F90
  Util/TS/TBtrans/m_tbt_tri_init.F90
  Util/TS/TBtrans/m_tbt_tri_scat.F90
  Util/TS/TBtrans/m_tbt_trik.F90
  Util/TS/TBtrans/m_tbtrans.F90
  Util/TS/TBtrans/tbt_data.py
  Util/TS/TBtrans/tbt_init.F90
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile
  Util/VCA/Makefile

----------------------------------------------------
November 20, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-217
Bugfix for ifort compiler

* Ifort compiler does not allow interfaced
  functions and variables to be named the same.
  Nor does it allow modules to be named the same as 
  functions.
  Hence a few corrections has been made.

modified:
  Src/m_ncdf_io.F90

----------------------------------------------------
November 20, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-216
Added first commit of TBtrans

* Added initial commit of tbtrans.
  There are too many options to account for in this
  short commit message.

  Suffice to say that it has these properties:
   - much faster
   - handles N-dimensionality very nicely
   - allows calculation of many more quantities than
     any previous version of TBtrans

* A lot of bugfixes for various makefiles:
   COOP
   Denchar
   STM/ol-stm
   WFS
  some of them are now compilable again
  after having being defunct for quite some time.


added:
  Util/TS/TBtrans/
  Util/TS/TBtrans/Makefile
  Util/TS/TBtrans/fdf_extra.F90
  Util/TS/TBtrans/m_tbt_contour.F90
  Util/TS/TBtrans/m_tbt_gf.F90
  Util/TS/TBtrans/m_tbt_hs.F90
  Util/TS/TBtrans/m_tbt_kpoint.F90
  Util/TS/TBtrans/m_tbt_options.F90
  Util/TS/TBtrans/m_tbt_proj.F90
  Util/TS/TBtrans/m_tbt_regions.F90
  Util/TS/TBtrans/m_tbt_save.F90
  Util/TS/TBtrans/m_tbt_sigma_save.F90
  Util/TS/TBtrans/m_tbt_sparsity2trimat.F90
  Util/TS/TBtrans/m_tbt_tri_init.F90
  Util/TS/TBtrans/m_tbt_tri_scat.F90
  Util/TS/TBtrans/m_tbt_trik.F90
  Util/TS/TBtrans/m_tbt_trimat_invert.F90
  Util/TS/TBtrans/m_tbtrans.F90
  Util/TS/TBtrans/tbt_data.py
  Util/TS/TBtrans/tbt_end.F90
  Util/TS/TBtrans/tbt_init.F90
  Util/TS/TBtrans/tbt_reinit.F90
  Util/TS/TBtrans/tbtrans.F90
modified:
  Src/Makefile
  Src/class_Geometry.F90
  Src/class_OrbitalDistribution.F90
  Src/class_Sparsity.F90
  Src/iodm.F
  Util/COOP/Makefile
  Util/Denchar/Src/Makefile
  Util/Gen-basis/Makefile
  Util/STM/ol-stm/Src/Makefile
  Util/STM/ol-stm/Src/atompla.f
  Util/STM/ol-stm/Src/readstm.f
  Util/STM/ol-stm/Src/reinitstm.f
  Util/TS/README
  Util/WFS/makefile

----------------------------------------------------
November 20, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-214
Update for preparing merging of tbtrans [4]

* Added MPI_STATUSES_IGNORE to the mpi interface

* Added saving of other variables to the SIESTA.nc
  file.
  Now fa, stress and Qtot are also saved.

  The MD writing has for now been disabled.
  The sparsity pattern cannot be assured constant.

* Bugfix for bulk-initialization from Gamma
  calculations.

* Added generic routine for reducing a matrix to only one spin
  channel.
  [m_handle_sparse]
  call reduce_spin_size(ispin,H_2D,S_1D,Ef)

  will retain the spin-index ispin and
  if S and Ef is provided the values will be shifted 
  according to:
    H(:,ispin) = H(:,ispin) - Ef * S(:)

* Bugfixes for the ncdf_io routine. Not optimal yet, but
  it should be a good base to start off from.

* Changed the scattering states for the electrodes
  to be Sigma - Sigma^\dagger.
  This will limit the i multiplication when creating the
  Gamma functions.
  As far as I know will BLAS always multiply with alpha
  in zgemm, hence we put it there instead of 1.

* Enabled several keys for the electrodes to work with tbt.<flag> flags.

* Possible bugfix for reading in a Gamma calculation TSHS file.
  Now the isc_off is always allocated. And for Gamma it is zero.
  
modified:
  Src/MPI/mpi__include.f90
  Src/final_H_f_stress.F
  Src/m_handle_sparse.F90
  Src/m_ncdf_io.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electype.F90
  Src/m_ts_full_scat.F90
  Src/m_ts_io.F90
  Src/m_ts_mumps_scat.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri_scat.F90
  Src/obj_setup.sh
  Src/save_density_matrix.F
  Src/siesta_init.F
  Src/siesta_options.F90
  Src/state_init.F
  Src/write_md_record.F

----------------------------------------------------
November 9, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-213
Added OpenMP support in TranSIESTA, added GEMM_3M

* Fixed pure statements in intrinsic routines

* Added the possibility to utilize
    [sdcz]gemm3m 
  routines when performing matrix multiplications
  in transiesta and related routines.

  gemm3m is using 3 multiplications and 5 additions
  instead of 5 multiplications and 3 additions.
  There are no down-sides that I am aware of.
  Performance increase can be expected.
  To utilize these routines compile with:
   -DUSE_GEMM3M
  and it will compile with gemm3m routines.

* Allowed regions to print with indention.

* Added OpenMP in these files:
   Src/m_sparsity_handling.F90
   Src/m_trimat_invert.F90
   Src/m_ts_charge.F90
   Src/m_ts_dm_update.F90
   Src/m_ts_elec_se.F90
   Src/m_ts_electrode.F90
   Src/m_ts_fullg.F90
   Src/m_ts_fullk.F90
   Src/m_ts_hartree.F90
   Src/m_ts_mumps_init.F90
   Src/m_ts_mumpsg.F90
   Src/m_ts_mumpsk.F90
   Src/m_ts_sparse.F90
   Src/m_ts_sparse_helper.F90
   Src/m_ts_tri_scat.F90
   Src/m_ts_trig.F90
   Src/m_ts_trik.F90
   Src/m_ts_trimat_invert.F90
   Src/m_ts_weight.F90

* Changed algorithm for determining the fastest
  tri-diagonal matrix.
  Now we better approximate the number of elemental
  operations performed via this:
    Ax=B
  takes 5*n**3/3 + n*m*4 basic operations.
  Again, this is only approximate.
  However, this diverges the memory and 
  speed algorithms more as they now typically yield
  different partitions.
  
  Searching the space of possible partitions
  is now performed in parallel.

* Fully implemented the TRS approximation.

  In TRS G^R - G^A really is: 2G^R
  Hence we apply this approximation.
  For now the old way is saved and can be
  turned on using:
   -DTS_BROKEN_TRS
  They should yield identical results.

* Disallowed '.' in electrode names.
  Removed unneeded variables in the electrode.

* Generalized insert_Self_Energies for the full
  matrix solver. It now resides in
  m_ts_full_scat.F90

* Added explanation of several routines in
  m_ts_sparse_helper.F90
  Here is the snippet:

    - create_HS
      1. accepts a distributed matrix
      2. requires the output matrix to be globalized in the sense
         that the sparsity pattern is a UC sparsity pattern
         NO dublicate entries. 
         REQUIREMENT: each row MUST be sorted in column index
      3. Creates the transposed matrix in the output matrix
         A simple argument is that any traversal in the sparsity
         pattern will be faster if it is following fortran order.
         This reduces cache-misses
      4. The matrix is forced Hermitian
    - create_U
      1. accepts a globalized sparsity pattern of a matrix
      2. Creates a matrix in Upper Triangular form
         which directly can be inserted in LAPACK [dz]spgvd/[dz]spev
         routines.
      3. Symmetrization is not enforced by this routine
    - create_Full
      1. accepts a globalized sparsity pattern of a matrix
      2. creates the full matrix (with all the zeroes) which can
         be directly used for BLAS/LAPACK matrix operations
      3. Symmetrization is not enforced by this routine

modified:
  Src/Makefile
  Src/intrinsic_missing.f90
  Src/m_mat_invert.F90
  Src/m_region.F90
  Src/m_sparsity_handling.F90
  Src/m_trimat_invert.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_charge.F90
  Src/m_ts_debug.F90
  Src/m_ts_dm_update.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_full_scat.F90
  Src/m_ts_fullg.F90
  Src/m_ts_fullk.F90
  Src/m_ts_hartree.F90
  Src/m_ts_mumps_init.F90
  Src/m_ts_mumps_scat.F90
  Src/m_ts_mumpsg.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/m_ts_trimat_invert.F90
  Src/m_ts_weight.F90
  Util/Grimme/Makefile
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile

----------------------------------------------------
November 9, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-212
Added OpenMP support in SIESTA

* Several routines have recieved attention 
  with regards of OpenMP implementation.
  
  In particular:
    - dhscf
      Many grid operations could easily
      be performed in threaded environments.
    - diagg
      Creation of the Hamilton can be threaded
    - diagk
      Creation of the Hamilton can be threaded
    - diagkp
      Creation of the Hamilton can be threaded
    - m_timer
      Timing needs to be refined when dealing
      with OpenMP.
      instead of the intrinsic cpu_time,
      we use omp_get_wtime which does not
      over count thread timing.
    - Several class objects have gotten
      OpenMP in the initialization routines.
 
* Format for FDF code (not important)

* Leveraged some operations in the poisson
  solver.

* When running in threadded mode we also
  print out the number of threads at run-time.

* Changed rhoofd.F to rhoofd.F90 and re-programmed
  the OpenMP routine.
  Previously I could not get the results to be
  consistent.
  With this implementation it should be correct.

* Changed vmat.F to vmat.F90 and re-programmed
  the OpenMP routine.
  Previously I could not get the results to be
  consistent.
  With this implementation it should be correct.

removed:
  Src/rhoofd.F
  Src/vmat.F
added:
  Src/rhoofd.F90
  Src/vmat.F90
modified:
  Src/class_Data1D.T90
  Src/class_Data2D.T90
  Src/class_TriMat.T90
  Src/dhscf.F
  Src/diagg.F
  Src/diagk.F
  Src/diagkp.F
  Src/fdf/fdf.F90
  Src/m_timer.F90
  Src/poison.F
  Src/siesta_init.F

----------------------------------------------------
October 27, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-211
Update for preparing merging of tbtrans [3]

* Made part_index from class_TriMat global to
  query the part for a specific index.
  This makes it possible to easily determine
  the part-index of an orbital.

* Made SPC_PROJ generic for N-dimensional space.

* Converted my parts of the code to utilise the 
   file_exist 
  routine.
  It is general enough to be used several other places.
  I have placed this general function in m_io_s.
  It can be called:
    file_exist(fname, <Bcast = .true.|.false.> , &
                      <Comm = MPI_Comm_World> )
  which with Bcast b-cast the result to the communicator.

* Small bugfix in the region for creating/deleting a list.
  It now does so correctly if it already was empty.
  
* Changed "position" from buffer atoms to "atom"
  this makes MUCH more sense.
  This will also be the standard for tbtrans.
  It is shorter, more concise and has a clear intent.

* Added a sparse method to create a tri-angular upper
  matrix in Gamma/k-point for a sparse pattern.
  This could possibly be used elsewhere (cdiag!!!)
  for speeding up diagonalization routines.
  I have not checked but I would suspect it to be slightly
  faster. Nevertheless it reduces memory requirements 
  substantially.

modified:
  Src/Makefile
  Src/class_TriMat.T90
  Src/intrinsic_missing.f90
  Src/m_handle_sparse.F90
  Src/m_io_s.F90
  Src/m_ncdf_io.F90
  Src/m_region.F90
  Src/m_ts_electype.F90
  Src/m_ts_gf.F90
  Src/m_ts_io.F90
  Src/m_ts_iodm.F90
  Src/m_ts_method.f90
  Src/m_ts_options.F90
  Src/m_ts_sparse_helper.F90
  Src/state_init.F
  Src/ts_init.F90
  Util/Grimme/Makefile
  Util/TS/ts2ts/Makefile
  Util/TS/ts2ts/ts2ts.f90
  Util/TS/tshs2tshs/Makefile

----------------------------------------------------
October 19, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-210
Update for preparing merging tbtrans [2]

* Unused variables have been removed in these modules:
   - class_Sparsity
   - class_SpData2D
   - class_TriMat
   - m_integrate
   - m_sparsity_handling
   - m_ts_sparse_helper

* Initializing using bulk DM matrices from other
  calculations now allow to only take partial 
  segments. This is handy if having a similar
  "interface" segment with different molecules, etc.

  Added clarification why normalization is not needed.

  When copying from/to a non-supercell calculation
  cross boundary copying is tricky, we note to the 
  user that this is difficult and that they should
  be cautionous.

* Bugfix for m_region, handling regions with 
  zero elements might still pose some problems.

* Change in how Eta is recognized for equilibrium and
  non-equilibrium.
  
  We have completely removed the Eta in the
  equilibrium contours. They had no real physical
  meaning other than smearing out the entire DOS
  which in the Eq. case should be easy to handle.

  (Note to DEVS, maybe this can be introduced
   for certain cases of smearing out everything)

  In non-equilibrium the eta can now be selectively
  placed on each electrode.
  This means that one can play with "toy" models of
  electrodes which easily can be put in the WBA
  by adding a high enough Eta.
  Also, we initialize the Eta in the device region to
  0. 
  TS.Contours.nEq.Eta has the meaning of a global
  Eta value (as previously), but it is defaulted
  to 0, while the electrodes Eta now are 
  defaulted to the old value.
  Controlling the Eta value for electrodes are
  done using the 'Eta' flag in the 'Elec' block.
  It must NOT be 0.

  This Eta value is also used for the Fermi-level
  correction.
  
* Re-inserted the Simpson, Boole and mid integration
  scheme for the circle contour.

* Error handling of dis-connected contours have been
  improved.

* Removed timing the ts_GS routine. It is called 
  extensively in tbtrans, and timing is just
  a bottle-neck.

* When we check the electrode in transiesta
  we now print a warning if the transport-vector
  is not fully parallel to a single cell-vector.
  
* The basal-plane of the electrodes are now shifted
  0.5 bohr to not take the mean of a potential field
  right through an atom.
  This will most likely annoy some calculations
  as the basal-plane _HAS_ to be contained in the
  unit-cell.

* Removed erroneous check for controlling placement
  of electrodes inside unit cell.
  trunk-432-scf-40--ts-scf-207

  This is not needed, the only requirement is
  that everything is "connected" from one atom and forward.

  This is not being checked, and probably should.
  However, this makes no sense for a system setup.
  So I don't think this problem "should" occur :)

* Corrected spelling errors in printing options.

* Corrected the removal of cross terms crossing cell-boundaries
  by projecting the electrode transport vector to the 
  cell vectors before removal.

* Removed m_glob_sparse and TBTrans_rep.

* Tri-matrix recognition had some bugs with electrodes
  lying on the edge of the blocks. This has been fixed
  along side with a feature bug which made the search
  space for tri-diagonal matrices sub-optimal for
  large number of processors.
  
  Searching for BTD formats now searches correctly by
  checking with the first partition size in a consecutive
  manner. However, for large systems this might not introduce
  any changes. 

  Cleaned up the code and removed quite a bit of sparsity
  pattern references. 

* Bugfix for non GF files repeated cells and k-point.
  When using ucell R.k we need the repetition using a different
  k-point to correctly expand using Bloch.
  This has been fixed and checked for several cases.	
  
* Saved a bunch of multiplications of wq in cases of 
  repeated cells.
  Instead of doing wq * ph * A(iq) + ... + wq * ph * A(nq)
  we can add the weight into the phase using the real part of the
  exponential.
  This is because:
    wq * e^(i k.R) = e^(ln(wq)+i k.R)
  using the simple relation: x = e^ln(x)

removed:
  Src/m_glob_sparse.F90
  Util/TBTrans_rep/
  Util/TBTrans_rep/Makefile
  Util/TBTrans_rep/atompdos.F90
  Util/TBTrans_rep/coop.F90
  Util/TBTrans_rep/m_lowdin.f90
  Util/TBTrans_rep/m_tbt_iotshs.F90
  Util/TBTrans_rep/m_tbt_kpoints.F90
  Util/TBTrans_rep/m_tbt_options.F90
  Util/TBTrans_rep/m_tbt_out.f90
  Util/TBTrans_rep/tbt_init.F90
  Util/TBTrans_rep/tbt_reinit.F90
  Util/TBTrans_rep/tbtrans.F90
  Util/TBTrans_rep/transmission.f90
  Util/TBTrans_rep/tt_eig.f90
modified:
  Src/Makefile
  Src/class_SpData2D.T90
  Src/class_Sparsity.F90
  Src/class_TriMat.T90
  Src/m_handle_sparse.F90
  Src/m_integrate.f90
  Src/m_new_dm.F90
  Src/m_region.F90
  Src/m_sparsity_handling.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_contour_eq.f90
  Src/m_ts_contour_neq.f90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_gf.F90
  Src/m_ts_hartree.F90
  Src/m_ts_io_ctype.f90
  Src/m_ts_method.f90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/siesta_forces.F
  Util/Grimme/Makefile
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile

----------------------------------------------------
October 14, 2014 -- Nick P. Andersen    trunk-432-scf-40--ts-scf-209
Update for preparing merging tbtrans

* Added procedures in the m_iterator module
  to calculate the current step reached, and 
  also to return how many total steps that are required.
  This is used to control how far one have gotten in a loop

* Create a generic pivot_array module
  to contain pivoting array. 
  Nearly all transiesta routines have converted
  to this pivoting array module.
  It reduces the overhead of allocating pivoting
  arrays on the stack all the time.
  Could possibly be introduced other places.

  It has a built in counter to retain the number
  of times it has been called.
  Only at full reduction of this variable will
  the pivoting array be deallocated and the pivoting amount
  reset. (Else we needed to save the history)

* MPI routines in m_region did not fully function
  with the intention they were built for.
  The mpi routines have been fixed.

* Reduced the need for the glob_sparse module
  as it was tedious to use.
  I have completely removed it.

* In case transiesta was doing Bulk electrodes
  and IsVolt == .false.
  we could reduce the need for allocating the
  Hamiltonian and the overlap in the electrodes.
  This will further reduce memory requirement
  for non-bias calculations.

* The Gamma array in the electrode type has been
  converted to a 1D array. This conforms better with the
  routines in transiesta/tbtrans.
  This meant a reduced complexity of the Gamma saving in the
  ts_electrode module.

* Changed a few interfaces in sparsity2trimat to help
  tbtrans utilise the same routines.

* Changed a few things for the electrode type
  - Added tbt-E-imag flag, only to be read by tbtrans
  - Added a prefix input for the options to help 
    create application aware options for tbtrans
  - Removed bandbottom calculation, this should be
    the users responsibility.
  - Changed the printing of electrode settings
    to be fully situated in the electype code.
    This is easier to handle and it makes sense
    as the transiesta/tbtrans options are fully
    decoupled from this.

* Changed a few IRecv/ISend to regular Send/Recv
  as it did not make sense to do other wise.

* Changed the default DM-update option
  to update the cross-terms.
  This has been a long-lasting option
  that is safer to have like this.

* Added a flag to compile siesta in a testing
  environment for IO.
  Alberto suggested that writing in block-size orbital
  ranges would greatly speedup IO.
  Indeed this is the case.
  To test this compile using: 
    DEFS += -DTEST_IO
  which will do 3 different settings.
   1) My message passing method
   2) Alberto's method of block-size passing
      while retaining compatibility
   3) Alberto's method of block-size writing

added:
  Src/m_matio.F90
  Src/m_pivot_array.f90
  Src/m_test_io.F90
modified:
  Src/Makefile
  Src/m_io_s.F90
  Src/m_iterator.f90
  Src/m_mat_invert.F90
  Src/m_region.F90
  Src/m_sparsity_handling.F90
  Src/m_transiesta.F90
  Src/m_trimat_invert.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_gf.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri_init.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/m_ts_trimat_invert.F90
  Src/state_init.F
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile

----------------------------------------------------
October 9, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-208
Bugfix for Makefile

modified:
  Src/Makefile

----------------------------------------------------
October 8, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-207
Bugfix for non-optimal electrodes

* A remnent from the first version left the
  Hamiltonian and update sparsity patterns to
  include terms that cross the periodic cell
  and the opposite electrode.
  This could potentially lead to erroneous
  results.

* Added "spar_dim" for the SpData2D class
  to easily check the sparsity pattern dimension.

* Added an equivalent function to determine whether to
  sparsity patterns where exactly the same, be
  it ID or value wise.

* Changed the H_kin to the class_dSpData1D along side
  all other arrays.

* Expanding the DM from an electrode needed to be done
  with the correct sparsity pattern and supercell
  indices. This we can "only" do by reading in the 
  TSHS, correcting the xij array/nsc/list_col and then
  expand.
  We try to make sure every array is deallocated,
  or left in the same state as before the expansion
  took place.

* Expansion in SIESTA is now being performed more
  stringently, i.e. the repetition is "per-cell"
  and not as an electrode would see it.
  Hence, repetitions are saught as 
   do irep = ...
      do expand
      step atom
   end do
  
* The initialization of the electrode DM is now 
  only being performed in these 3 situations:

  1) when the diagon has finished
  and we start on transiesta.
  or 
  2) if we force it to start from transiesta
  or
  3) if we start from a TSDE

* Bugfix for block-tri-diagonal determination
  In certain cases could it lead to erroneous
  BTD format (however, it would have been captured)
  It can now not create any erroneous BTD format.

* Clarified that the Gamma's in elec_se are being
  saved in transposed format (as NetLIB BLAS is much
  faster when having the first matrix using the 'T'
  product.

* Cleaned up code in various places.

* Bugfix for reading the version of TSHS files.

* Added the m_region code to transiesta
  
  This code will be the basis of tbtrans
  (and possibly later the pivoting of transiesta).

  It basically is a module to handle lists of orbitals
  that refer to sparsity patterns.

  Using this generic module it is extremely easy to
  handle sparsity patterns.
  
  Say you want to remove all orbitals that connect to
  atom 1 and 2. This you can accomblish using this:

   call region_range(r,1,lasto(2))
   call Sp_remove_region(dist,sp_in,r,sp_out)

  In tbtrans this is a very handy module as it leverages
  a lot of handling of pivot tables.

  It also enables the processing of sorting regions.
  
* A code to help m_region is m_sparsity_handling
  which probably should be combined in a more generic
  way.
  I currently do not have time, but these modules could
  be the basis of a sparsity library for general purposes.

added:
  Src/m_region.F90
  Src/m_sparsity_handling.F90
modified:
  Src/Makefile
  Src/class_OrbitalDistribution.F90
  Src/class_SpData2D.T90
  Src/class_Sparsity.F90
  Src/compute_EKS_Harris.F90
  Src/compute_dm.F
  Src/create_Sparsity_Union.F90
  Src/m_handle_sparse.F90
  Src/m_io_s.F90
  Src/m_new_dm.F90
  Src/m_sparse.F90
  Src/m_transiesta.F90
  Src/m_trimat_invert.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_debug.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electype.F90
  Src/m_ts_global_vars.f90
  Src/m_ts_io.F90
  Src/m_ts_io_ctype.f90
  Src/m_ts_iodm.F90
  Src/m_ts_method.f90
  Src/m_ts_mumpsg.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_tri_init.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/m_ts_trimat_invert.F90
  Src/setup_H0.F
  Src/setup_hamiltonian.F
  Src/siesta_forces.F
  Src/sparse_matrices.F
  Src/state_init.F
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile
  Util/TS/tshs2tshs/tshs2tshs.f90

----------------------------------------------------
September 27, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-206
Allowed reduction of memory usage for repetition

* Now pre-expansions comes in 3 variants
   1. No expansion (least memory requirement,
      highest computational time)
   2. Expansion of GS matrix. Good balance
      between memory and efficiency. H, S
      are expanded at every loop, but they are
      easily expanded
   3. Expansion of everything, requires the 
      most amount of memory, but also takes
      the least time. (DEFAULT)

modified:
  Src/m_transiesta.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_gf.F90
  Src/m_ts_options.F90

----------------------------------------------------
September 26, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-205
Bugfix for linking in SIESTA

* Initializing from bulk requires a TSHS file,
  however, the m_ts_io.o file was not linked against
  SIESTA. It is now added.

modified:
  Src/Makefile

----------------------------------------------------
September 26, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-204
Bugfix for gamma and supercell, added generic Bulk DM init

* The user has full control over the supercell, hence
  we do not need to forcefully create the 	
  correct supercell for gamma calculations.

  However, if a user want to initialize the electrode
  bulk-density we need the auxilliary cell as the cell connections
  are calculated using the isc_off array.

* Initialization of the DM is now done in two different ways
  according to the situation.
  
  1) If the DM is initialized from atomically filled orbitals
     we are allowed to initialize the cross-terms with the
     device region. (and hence improves the convergence, 
     considerably)
  2) If the DM is read from a file we only allow writing to
     the elements that belong to the electrodes and buffers.

* Changed print-out of tri-diagonal partitioning, the lines
  could easily be excessively long.

* Assures nullification of sparse pattern arrays
  after resetSparseMatrices

modified:
  Src/Makefile
  Src/m_handle_sparse.F90
  Src/m_iodm.F90
  Src/m_new_dm.F90
  Src/m_ts_electype.F90
  Src/m_ts_iodm.F90
  Src/m_ts_tri_init.F90
  Src/save_density_matrix.F
  Src/siesta_init.F
  Src/sparse_matrices.F
  Src/state_init.F
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile

----------------------------------------------------
September 25, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-203
information printing had a slight error

* The repetition of the DM printed the "wrong" counts.
  I have corrected and added a printing of the
  [ diagonal, off-diagonal] updates in the routine

modified:
  Src/m_handle_sparse.F90
  Src/m_new_dm.F90

----------------------------------------------------
September 24, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-202
Fermi-correction for in-band calculations bugfix

* In case the Fermi-level lies in between two bands
  we will HEAVILY overestimate the changed Fermi-level.
  In this case we assign a maximum allowed change of the 
  Fermi level.

modified:modified:
  Src/Makefile
  Src/m_new_dm.F90
  Src/save_density_matrix.F
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile

----------------------------------------------------
September 23, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-201
Bugfix for module usage in m_new_dm

modified:modified:
  Src/Makefile
  Src/m_new_dm.F90
  Src/save_density_matrix.F
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile

----------------------------------------------------
September 23, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-200
Name change of TSDE in Elec block

* Changed from DE to TSDE in elec block,
  this is more intuitive.

modified:
  Src/m_ts_electype.F90
  Src/m_ts_options.F90

----------------------------------------------------
September 23, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-199
Allowed starting with transiesta, add DM-bulk

* Changed:
    TS.SaveTSHS
  to
    TS.HS.Save
  in order to comply with the new wording:
    TS.DE.Save
  note that the latter only has meaning for electrodes.

* I have added a code to enable the substitution of the
  bulk density matrix for electrode regions.
  This seems like is the best idea as the electrostatic
  potential in the leads will be "equivalent" to a real
  bulk example. 
  We read in the density matrix and copies the data
  based on coordinates and atomic orbital indexing.

  This code could be used in other instances if one wishes
  to interpolate a much larger structure from a single 
  run. 
  An example: 
     UC - graphene:
  -> huge graphene flake, 
     simply repeat the density matrix to this huge
     graphene flake

  In transiesta this is handled by an additional flag
  for the electrode:
    TS.DE.Save T
  which enables the saving of the density and energy
  density matrices in the TSDE format.

  In the TS calculation a few flags are needed,
  as they can be done in different ways.
    SCF.Initialize diagon|transiesta
  decides whether it should initialize using
  a diagon run or using transiesta.
  TODO: Here we could add differenc schemes for
        defining generic expansions of the DM
        from previous runs.

    TS.Elecs.DM.Bulk init
  tells transiesta that the density matrices
  for the electrodes will be bulk, in case
  SCF.Initialize diagon and a TSDE file
  exists it will overwrite the DM in the 
  electrode region (thus one can test this method
  by first doing a diagon relaxation, then add
  the above flag and restart.

  If you initialize using transiesta the Fermi-level
  will be very wrong, hence you are almost ALWAYS
  required to add this flag:
    TS.ChargeCorrection fermi

* The charge-correction Fermi has improved in that
  it can utilize the previous estimations to interpolate
  a better guess for the Fermi-level.
  It can now converge in 4 x 4 tries :)
  Before it could easily take as long as 4 x 100 tries.

* Bugfix for chargecorrection.
  When the fermi-level is changed we need
  to shift the energy-density matrix along as otherwise
  will the energy around the atoms in the electrodes not
  be "following the potential".
  This seems to stabilize a lot of the problems.

* Bug-fix for broad-casting in io_s module.
  Also MPI_Send/Recv had a wrong interface at certain
  points in the io_s code.

* Created a generic variable isc_off in siesta_geom
  which handles the supercell geometry.

* Changed the RepA[1-3] variable to an array,
  shortens some of the code.

* For Gamma calculations one still has a supercell (connections)
  hence I now calculate nsc for Gamma calculations unless
  naive-auxillary cell is used.
  However, calculating nsc is necessary for copying the DM
  from an electrode.

* Changed the interface for write_TSHS so that it only
  uses the isc_off array (it need not the xij array).
  Also corrected in tshs2tshs utility.

added:
  Src/m_handle_sparse.F90
modified:
  Src/Makefile
  Src/compute_dm.F
  Src/final_H_f_stress.F
  Src/m_io_s.F90
  Src/m_new_dm.F90
  Src/m_sparse.F90
  Src/m_transiesta.F90
  Src/m_ts_charge.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_gf.F90
  Src/m_ts_io.F90
  Src/m_ts_iodm.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/save_density_matrix.F
  Src/siesta_forces.F
  Src/siesta_geom.F90
  Src/siesta_init.F
  Src/state_init.F
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile
  Util/TS/tshs2tshs/tshs2tshs.f90

----------------------------------------------------
September 18, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-198
Changed the offset_xij routines to not allocate

* Allocating outside offset_xij allows using the
  class_<> objects for the xij array.

modified:
  Src/m_sparse.F90
  Util/TS/tshs2tshs/tshs2tshs.f90

----------------------------------------------------
September 18, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-197
Updated tshs2tshs to also conform with new io

modified:
  Util/Grimme/Makefile
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile
  Util/TS/tshs2tshs/tshs2tshs.f90

----------------------------------------------------
September 18, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-196
Restrained the send/recv messages

* Sometimes for very fast communication the 
  message was not fully send/recv while the
  program overwrote the quantities.
  We restrain this by using blocking
  send/recv only where needed.

* Asserted waiting for all non-blocking
  sends, the MPI layer allocates memory
  for the message which is only released
  on Wait.

modified:
  Src/Makefile
  Src/basic_type.inc
  Src/class_Data1D.T90
  Src/class_Data2D.T90
  Src/class_OrbitalDistribution.F90
  Src/class_Sparsity.F90
  Src/m_io_s.F90
  Src/m_iodm.F90
  Src/m_new_dm.F90
  Src/m_ts_io.F90
  Src/m_ts_iodm.F90
  Src/restructSpData2D.F90
  Src/state_init.F

----------------------------------------------------
September 17, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-195
Bugfix for pointer in m_io_s

* I accidentially left the gncol 
  in a state of => null() when passing
  it to the routine.

modified:
  Src/m_io_s.F90

----------------------------------------------------
September 17, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-194
Implemented block read/write to DM/TSDE files

* My routines have been altered for doing block
  recv/sends which greatly enhances the speed!
  Reading is now extremely fast.
  Writing is approximately twice as fast
  on 12 cores.

  I think this should compete very nicely with the
  blocking m_matio routines.

  TODO search for memory leaks...

modified:
  Src/m_io_s.F90
  Src/m_iodm.F90
  Src/m_ts_io.F90
  Src/m_ts_iodm.F90

----------------------------------------------------
September 17, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-193
Added my IO to DM, full capacity reached

* The DM files are now also read/written by my routines.
  Speeds up execution when dealing with large systems.

removed:
  Src/m_iodm.F
  Src/readSpData2D.F90
added:
  Src/m_iodm.F90
modified:
  Src/Makefile
  Src/m_new_dm.F90
  Src/m_ts_iodm.F90
  Src/save_density_matrix.F

----------------------------------------------------
September 17, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-192
Bugfix for restructData, removed writing q for nq == 1

* An offset was not taken into account in restructSpData2D

* When nq == 1 we do not write out the expansion q-points.

modified:
  Src/m_ts_electrode.F90
  Src/m_ts_options.F90
  Src/restructSpData2D.F90

----------------------------------------------------
September 17, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-191
New IO routines for sparse format, speed increase

* IO performance was limited by a lot of blocking
  send/recv and a new implementation was deemed necessary.
  Currently I am testing this new IO with only transiesta
  routines so that I can assure its correctness.
  
  Example for reading a sparse formatted with distribution
  attached:
   Old: Reading a row of content and doing a blocking send
        AND a blocking receive.
   New: All receiving ends post ALL their receive msgs,
        the IONode reads through the file and posts the
        send in a non-blocking fashion (with blocking before
	next read).
        As all receives are posted there is literally no 
	overhead here and the speedup is huge.
	For 2 processors reading is 4 times faster and
   	writing is 2 times faster.
	I will test this on my 12 core machine to assert 
	the speedup.

* To check IO speed I have added -DTIMING_IO as a possibility
  of checking the speed.
  It runs all IO routines 100 times and will immediately print 
  out the timing.

* All sparse arrays have moved to the class_<> types.
  I have generalized their names to incorporate their size,
  i.e. :
    H => H_2D
    DM => DM_2D
    S => S_1D
  etc.
  This meant a few things that needed editing, but it works.
  
  TODO: Check for memory leaks, especially in MD simulations.

* I have implemented a standard solution with my ncdf library.
  Currently extra flags are required for it to work, so it 
  is a work in progress.
  It however works for Netcdf4 files, with and without compression.
  A basic file will have this CDL:

netcdf SIESTA {
dimensions:
	one = 1 ;
	spin = 1 ;
	na_u = 10 ;
	nnzs = 109330 ;
	no_u = 90 ;
	no_s = 21870 ;
	xyz = 3 ;
variables:
	int nsc(xyz) ;
		nsc:info = "Number of supercells" ;
	int lasto(na_u) ;
		lasto:info = "Last orbital of equivalent atom" ;
	int n_col(no_u) ;
		n_col:info = "Number of non-zero elements per row" ;
	int list_col(nnzs) ;
		list_col:info = "Supercell column indices in the sparse format" ;
	double Ef(one) ;
		Ef:info = "Fermi level" ;
		Ef:unit = "Ry" ;
	double xa(na_u, xyz) ;
		xa:info = "Atomic coordinates" ;
		xa:unit = "Bohr" ;
	double cell(xyz, xyz) ;
		cell:info = "Unit cell" ;
		cell:unit = "Bohr" ;
	double fa(na_u, xyz) ;
		fa:info = "Atomic forces" ;
		fa:unit = "Ry/Bohr" ;
	double stress(xyz, xyz) ;
		stress:info = "Cell stress" ;
		stress:unit = "Ry/Bohr**3" ;
group: MD {
  variables:
  ... if doing MD simulation.
} // group MD

group: MATRIX {
  variables:
  	double S(nnzs) ;
  		S:info = "Overlap matrix" ;
  	double DM(spin, nnzs) ;
  		DM:info = "Density matrix" ;
  	double EDM(spin, nnzs) ;
  		EDM:info = "Energy density matrix" ;
  		EDM:unit = "Ry" ;
  	double H(spin, nnzs) ;
  		H:info = "Hamiltonian" ;
  		H:unit = "Ry" ;
  	double xij(nnzs, xyz) ;
  		xij:info = "Distance between orbital i and j" ;
  		xij:unit = "Bohr" ;
  } // group MATRIX

group: SETTINGS {
  variables:
  	double DMTolerance(one) ;
  		DMTolerance:info = "Tolerance for converging the density matrix" ;
  	double HTolerance(one) ;
  		HTolerance:info = "Tolerance for converging the Hamiltonian" ;
  	double NetCharge(one) ;
  		NetCharge:info = "Net charge of the system" ;
  	double MixingWeight(one) ;
  		MixingWeight:info = "Mixing weight" ;
  	int BZ(xyz, xyz) ;
  		BZ:info = "Grid used for the Brillouin zone integration" ;
  	double BZ_displ(xyz) ;
  		BZ_displ:info = "Grid used for the Brillouin zone integration" ;
  		BZ_displ:unit = "b**-1" ;
  	double ElectronicTemperature(one) ;
  		ElectronicTemperature:info = "Temperature for electrons" ;
  		ElectronicTemperature:unit = "Ry" ;
  	double MeshCutoff(one) ;
  		MeshCutoff:info = "Mesh cutoff for real space grid" ;
  		MeshCutoff:unit = "Ry" ;
  } // group SETTINGS
}

  
removed:
  Src/m_ts_iodm.F
added:
  Src/m_ncdf_io.F90
  Src/m_ts_iodm.F90
modified:
  Src/Makefile
  Src/class_OrbitalDistribution.F90
  Src/compute_EKS_Harris.F90
  Src/final_H_f_stress.F
  Src/kpoint_grid.F90
  Src/m_io_s.F90
  Src/m_new_dm.F90
  Src/m_ts_io.F90
  Src/restructSpData2D.F90
  Src/save_density_matrix.F
  Src/setup_H0.F
  Src/setup_hamiltonian.F
  Src/siesta_forces.F
  Src/siesta_init.F
  Src/siesta_options.F90
  Src/sparse_matrices.F
  Src/state_analysis.F
  Src/state_init.F
  Src/write_md_record.F

----------------------------------------------------
September 7, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-190
Gamma bugfix, and dEf only printing dQ

* When doing Gamma calculations we still used
  the xijo array, (to create the sc_off array).
  This has now been superseeded.
  We allocate a "dummy" sc_off with size 1 
  and then all phases will be generated from this.

  (TODO: an analysis shows that the sparse matrix does
  not shrink in size when changing a k-point to a Gamma
  point sampling. This must mean that the possible reduction
  has not been introduced.)

* The TS_FERMI now contains the dEf dQ which makes it easier
  to check (no need to remember how many charges we have, 
  it prints the difference.

modified:
  Src/m_transiesta.F90
  Src/m_ts_io.F90
  Src/m_ts_sparse.F90
  Src/state_init.F

----------------------------------------------------
September 3, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-189
Correction for dEf routines

* The dEf correction was calculating the linear 
  correction at each optimization, yet this
  was not needed (only at the first calculation).

  We rely on the spline interpolation afterwards and
  do not need to calculate the linear contribution.

* Bugfix for IO-closing.

* Also delete the TS_FERMI file on start
  TODO implement a charge correction based on the first
  entry for each segment.
  This requires reading in the entire file, yet
  will most likely be extrapolation (and hence
  a crude overestimation on the first shot).

modified:
  Src/m_transiesta.F90
  Src/m_ts_charge.F90
  Src/ts_init.F90

----------------------------------------------------
September 3, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-188
Added a new charge correction method which alters the Fermi level

* Instead of regarding the charge as "incorrect" (bad integration), 
  we regard the integration perfect and instead attribute the 
  missing/excess charge to a mis-alignment of the Fermi-level.
  In case of equilibrium this can be thought of as a normal Fermi-level
  shift, for non-equilibrium it is imposed as a shifting of the 
  electronic states in the junction.
  Remember that the Fermi-level is not a well-defined quantity
  for non-equilibrium.

* Added an interpolation algorithm:

  m_interpolate.f90
  
  It can do linear interpolation and a cubic spline
  interpolation.

  The advantage of this algorithm is that it does not
  require any sorting of the input, it calculates
  a pivoting array for aligning the quantities correctly.

  I have currently tested this on cos/sin functions in
  the range -.1 : 2*\pi + .1
  with points evaluated in the range 0 : 2*\pi.
  (remark we use linear extrapolation for out-of range
   points)
  
  It is not the fastest algorithm but provides the requirement
  that we need.
  For the Fermi-level interpolation we utilize this new module.

added:
  Src/m_interpolate.f90
modified:
  Docs/siesta.tex
  Src/Makefile
  Src/compute_dm.F
  Src/m_transiesta.F90
  Src/m_ts_charge.F90
  Src/m_ts_contour_eq.f90
  Src/m_ts_dm_update.F90
  Src/m_ts_gf.F90
  Src/m_ts_options.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/siesta_forces.F
  Src/ts_init.F90

----------------------------------------------------
August 29, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-187
Finalized m_io_s to handle distributions (in-line)

* By limiting the memory while reading we should be 
  able to reduce CPU time when reading/writing TSHS
  files.

modified:
  Src/m_io_s.F90

----------------------------------------------------
August 27, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-186
Added new weighting mechanism, removed unneeded arguments

* Removed unneeded arguments for number of electrodes
  in several weighting routines.
  This means a deletion of a routine in m_ts_countour_neq.
  
* The new weighting method is a simple mean which seams
  to behave similarly with the orb-orb weighting.
  This "assumes" a very good convergence for all parts of
  the integral.

modified:
  Src/m_ts_options.F90
  Src/m_ts_weight.F90

----------------------------------------------------
August 25, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-185
Reverted Saha papers weighting algorithm

* My calculation shows that Saha papers weighting algorithm is
  not the correct one (albeit they reduce to the same weight for	
  N_Elec == 2).
  It is also easier to handle.

  The multiplicity of any electrode is not needed.

  Fully removed the non-equilibrium weighting mechanism
  for k-correlated densities. Not necessary with yet another
  method.

modified:
  Src/m_ts_contour_neq.f90
  Src/m_ts_fullg.F90
  Src/m_ts_fullk.F90
  Src/m_ts_mumpsg.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_options.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/m_ts_weight.F90

----------------------------------------------------
August 25, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-184
Bugfix for oversubscription of nodes

* Instantiated a kill statement if one processor is carrying
  0 non-zero elements in the sparse pattern. Several places in the
  code is this not checked for and could behave badly.

* Instantiated tests to assure that the MPI_Wait is only called
  if the request is set. This is done using the MPIerror code
  as I do not know the range of requests. 

modified:
  Src/hsparse.F
  Src/m_io_s.F90
  Src/m_ts_io.F90

----------------------------------------------------
August 22, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-183
Bugfix for changed supercell, kill job

* The HALF correlated weighting has been removed.
  It is not implemented and probably should not be.

* Added a killing of the job when the number of 
  supercell orbitals has changed. This is a precaution
  as the supercell calculation has changed.

modified:
  Src/m_ts_fullk.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_options.F90
  Src/m_ts_trik.F90
  Src/m_ts_weight.F90
  Src/restructSpData2D.F90

----------------------------------------------------
August 20, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-182
Compilation fix for old gnu compilers

* The old compilers does not allow "::" in module procedure
  statements.
  Removed

modified:
  Src/geom_helper.f90
  Src/m_sparse.F90

----------------------------------------------------
August 20, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-181
Added writing to the m_io_s module

* Added writing sparsity pattern, dSp1D and dSp2D data
  to the module.
  This is mainly intended for future use.

modified:
  Src/m_io_s.F90

----------------------------------------------------
August 19, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-180
Supercell calculation update

* Sometimes the supercell calculation was
  erroneous. We have now corrected it to also pass
  a simple test (FCC-111 surface).
  It would be *much* better to calculate explicitly
  the used supercells in an array, there might
  be many "empty" supercells due to the diagonal
  entries.

modified:
  Src/m_sparse.F90
  Src/m_supercell.f90

----------------------------------------------------
August 18, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-179
Fixed calculations of iterations used in SE-calculation

* Showing the iterations used was only averaging for the last
  k-point, q-point. We now do the correct mean and std.
  We take all iterations into account.

modified:
  Src/m_ts_electrode.F90

----------------------------------------------------
August 18, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-178
Name changes in m_io_s

* Intel compiler is not so happy about variables
  with same name as 'use'd module routines. 
  Changed "name" to "tag"

modified:
  Src/m_io_s.F90
  Src/m_ts_io.F90

----------------------------------------------------
August 18, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-177
Fully implemented the sc_off arrays

* Reverted commit 615, it was an erroneous commit.

* The xij array has been fully superseeded by only using 
  the offset array. This means a small speed increase, but
  is obviously intended for TBTrans.
  It also has other advantages, the electrodes need not
  the xij arrays which are the arrays which takes up the
  most space.

  This means that the list_col array now handles the offsets
  for the supercell k.R phase. 
  
  NOTE: ideally all xij arrays can be deleted before entering
  transiesta, and recreated afterwards to limit memory usage.
  For 5.000.000 non-zero elements this totals a memory 
  consumption of 8 * 3 * 5M / 1024 ** 2 = 114 MB
  (Of course distributed)

* The IO routines has been fully restructured which means
  a memory reduction, and speed increase as b-cast is now
  changed to send/recv to the ionode.
  We utilize ISSend and Recv as we know the local
  buffer is not changing (thus no buffers are needed
  and all sends are returned immediately, still synchronous :))

* Utility tshs2tshs has followed the update.

* Added a generic sparse reader.
  It reads 3 different kind of input in a file:
  
  io_read_Sp -> reads a sparsity pattern:
    read(iu) ncol
    read(iu) l_col
    create l_ptr
    
    It does so with regards of b-casting if requested.
    
  io_read_d1D -> reads a 1D data segment in the file:
    do i = 1 , no
      read(iu) A(l_ptr(i)+1:l_ptr(i)+ncol(i))
    end do
    it is also distributed if requested

  io_read_d2D -> reads a 2D data segment in the file:
    This routine takes into account the two possible
    variants, sparsity_dim == 1 or sparsity_dim == 2.

    sparsity_dim == 1:

    do idim = 1 , dim2
      do i = 1 , no
        read(iu) A(l_ptr(i)+1:l_ptr(i)+ncol(i),idim)
      end do
    end do

    sparsity_dim == 2:

    do i = 1 , no
      read(iu) A(1:dim2,l_ptr(i)+1:l_ptr(i)+ncol(i))
    end do

    it is also distributed if requested

  In d[12]D reads we immediately assign the sparsity pattern
  and a distribution. Currently this reading can only handle
  non-distributed distributions. 

  Yet its usage can be immediately employed else where in the code.

  For TSHS reading S, H and xij, now becomes:

    call io_read_Sp(iu,no_u,sp,name=trim(lname),Bcast=Bcast)
    call io_read_d1D(iu,sp,S,'S',Bcast=Bcast)
    dit => dist(S) ! same distribution for the next read in stuff.
    call io_read_d2D(iu,sp,H,nspin,'H',Bcast=Bcast,dit=dit)
    call io_read_d2D(iu,sp,xij,3,'xij',sparsity_dim=2,dit=dit, Bcast=Bcast)

  pretty no?
  I think this method is more general than readSpData2D

added:
  Src/m_io_s.F90
  Src/m_sparse.F90
modified:
  Src/Makefile
  Src/compute_dm.F
  Src/create_Sparsity_SC.F90
  Src/geom_helper.f90
  Src/m_hs_matrix.f90
  Src/m_transiesta.F90
  Src/m_ts_dm_update.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_fullg.F90
  Src/m_ts_fullk.F90
  Src/m_ts_gf.F90
  Src/m_ts_io.F90
  Src/m_ts_mumpsg.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/m_ts_weight.F90
  Src/state_init.F
  Src/ts_init.F90
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile
  Util/TS/tshs2tshs/tshs2tshs.f90

----------------------------------------------------
August 16, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-176
Bugfix for self-energy calculation

* The wrong k.R was used for the calculation of the self-energy
  
modified:
  Src/m_ts_electrode.F90

----------------------------------------------------
August 16, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-175
Bugfix for k-points when doing in-core SE calculation

* The k-points for in-core calculations of the self-energy
  was erroneously calculated.
  The k-points was not in reciprocal units before transferring
  them to the new k-point

modified:
  Src/m_ts_fullg.F90
  Src/m_ts_fullk.F90
  Src/m_ts_gf.F90
  Src/m_ts_mumpsg.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90

----------------------------------------------------
August 16, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-174
Bugfix for weights of non-equilibrium contribution

* The non-equilibrium contribution was a factor of
  2 too high. 
  The bugfix means a slightly faster convergence,
  for obvious reasons.

modified:
  Src/m_ts_dm_update.F90
  Src/m_ts_fullk.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90

----------------------------------------------------
August 15, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-173
Changed supercell indices when converting read

* The supercells are now ordered according to a rigid
  loop and the unit-cell is not centered at the first
  index. I think this is better.

modified:
  Src/m_hs_matrix.f90
  Src/m_ts_io.F90

----------------------------------------------------
August 12, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-172
  Changed supercell calculation to capture slaps etc.
  
  * We now explicitly calculate the super-cell size.
    We do this in m_supercell.
    The algorithm is extremely naive and simple.
    Loop on all connections from the unit-cell to the
    neighbouring supercell. 
    And calculate the maximum supercell extend that is required
    to reach this atom again.
  
    This will correctly capture slap calculations where the previous
    algorithm would just add 3 supercells.
  
  removed:
    Src/m_check_supercell.f
  added:
    Src/m_supercell.f90
  modified:
    Src/Makefile
    Src/geom_helper.f90
    Src/siesta_init.F
    Src/state_init.F
    Util/TS/ts2ts/Makefile
    Util/TS/tshs2tshs/Makefile

----------------------------------------------------
July 29, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-171
Memory estimation bugfix

* One really should use 1024 and not 1000.
  At least for IO file size estimation (the majory
  of file systems uses 1024).

modified:
  Src/m_transiesta.F90
  Src/m_ts_electrode.F90

----------------------------------------------------
July 29, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-170
Bugfix for makefiles make dep with T90 files

* The dependency scheme for T90 files was not complete.
  We now insert a fix which should correct this.

* Moved transport direction to also exist for regular
  transiesta runs.
  This means that electrodes can be designated a transport direction.
  At the moment this is not used for anything.
  Yet, in the future it could be a nice way
  to tell transiesta that this is an electrode and how to
  check that it is correct.
  
modified:
  Src/Makefile
  Src/class_Fstack_Pair_Geometry_SpData2D.F90
  Src/class_Pair_Geometry_SpData2D.F90
  Src/m_trimat_invert.F90
  Src/m_ts_kpoints.F90
  Src/m_ts_options.F90
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile

----------------------------------------------------
July 29, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-169
Memory reduction + speed up for BTD bias calculations

* The method for calculating the Gf.G.Gf product has
  been reworked with memory in question.
  We now estimate the least (still the easiest method)
  amount of memory used by padding the tri-diagonal
  matrix with extra memory to allow for containing the 
  entire column AND simultaneously updating the 
  tri-diagonal entries.
  This means that the size of the padding will 
  minimum be the size of the last 2 parts.
  Nevertheless it proves to drastically reduce
  the memory required as we do not need to copy over 
  everything at the moment of a single element crossing.
  
  It is now based on the mininum memory while calculating
  the next column.

  ( NOTE to further devs:
  The best way to do this is to utilize all
  memory in the central tri-diagonal blocks of Mnn which
  at the moment is not utilized AT ALL)

* The notice of the dm-out error for bias calculations
  has been given an extra digit for denoting the supercell.
  This is needed due to the new algorithm which consequently
  overestimates the supercell size.

modified:
  Src/class_TriMat.T90
  Src/m_transiesta.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_mumps_init.F90
  Src/m_ts_sparse.F90
  Src/m_ts_tri_init.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/m_ts_trimat_invert.F90
  Src/m_ts_voltage.F90
  Src/m_ts_weight.F90

----------------------------------------------------
July 29, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-168
Bugfix for version initialization

* ts_io did not initialize version number
  As this version string is not communicated for
  non-IO nodes we need to initialize.

modified:
  Src/m_ts_io.F90

----------------------------------------------------
July 28, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-167
Implemented Jose Soler suggestion about xijo

* Implemented the "correct" supercell counts for siesta 
  which nearly always counts too large a supercell.
  TODO apply a correction which takes into account
  the minimum position along vectors and the maximum
  position along vectors, then calculate their overlap.

* Corrected tshs2tshs to also handle this.

modified:
  Src/m_hs_matrix.f90
  Src/m_ts_io.F90
  Src/siesta_init.F
  Util/Grimme/Makefile
  Util/TS/ts2ts/Makefile
  Util/TS/tshs2tshs/Makefile
  Util/TS/tshs2tshs/tshs2tshs.f90

----------------------------------------------------
July 27, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-166
Bugfix, no GF creation with onlyS

* When doing onlyS calculations we were 
  still creating the green's functions (which does
  not make any sense).
  We now check that the onlyS variable and skip any electrode
  dependencies with onlyS
  
modified:
  Src/m_ts_options.F90
  Src/ts_init.F90

----------------------------------------------------
July 18, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-165
Finalized new TSHS format

* The xijo correction is now done by correcting listh
  We calculate the number of supercells by finding
  the supercells from the xij array.
  We then construct xij from the offsets and the
  changed listh.
  listh in a TSHS file now corresponds to
  separate supercell coordinates. No two 
  supercells are located in the same transfer matrix
  coordinate (even though they can be equivalent by 
  symmetry reasons).
  I have deleted the indxuo array from the files.
  It has never provided any useful information as
  it can easily be regenerated.
  
  I thank Jose Soler for valuable information regarding
  the supercell implementation.

  This new format is extremely reduced.

  Implemented the new file format in tshs2tshs.
  
modified:
  Src/m_hs_matrix.f90
  Src/m_ts_electype.F90
  Src/m_ts_io.F90
  Util/TS/tshs2tshs/Makefile
  Util/TS/tshs2tshs/m_ts_io_version.f90
  Util/TS/tshs2tshs/tshs2tshs.f90

----------------------------------------------------
July 18, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-164
Created max/min column when finding BTD format

* When creating the BTD format we continuously calculated
  the max/min columns of each orbital.
  Instead we now calculate these once and pass the array
  around where needed.
  This should speed up the BTD finding algorithm for large systems

* Added some comments for the non-equilibrium contours so that	
  it is easier to figure out what is going on.

* The non-equilibrium contours now only prints out the real-value of the
  weight (it is never imaginary as we are not in the complex plane!)

modified:
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_contour_neq.f90

----------------------------------------------------
July 14, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-163
Bugfix for used-atoms < na, further reduced TSHS size

* By moving xijo to correct super-cell coordinates we 
  can fully reduce the size of TSHS to the mininum 
  size. We now completely rely on the supercell coordinate.
  
  When converting from old to newer format we have some troubles
  setting the correct super-cell connection. However, the
  user can read these of in the output of the simulation.
  Or just guess. :)

* Corrected a bug for used-atoms were a pivoting array 
  was not allocated to the appropriate size.

* Added WARNING for the user if any buffer atoms exist
  and are "close" to one of the electrodes.
  We define close as 12 Bohr.
  If any atom in the electrode is close to any one buffer atom
  it will HIGHLY suggest the user to enable DM-update [cross-terms|all]

modified:
  Src/Makefile
  Src/final_H_f_stress.F
  Src/m_hs_matrix.f90
  Src/m_mat_invert.F90
  Src/m_ts_electrode.F90
  Src/m_ts_io.F90
  Src/m_ts_options.F90
  Src/state_init.F
  Src/ts_init.F90
  Util/TS/tshs2tshs/m_ts_io_version.f90
  Util/TS/tshs2tshs/tshs2tshs.f90

----------------------------------------------------
July 7, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-162
Made repetition the preferred electrode usage

* The fact that we needed to not invert the matrix for non-repeated
  cells made repetition worse than non-repeated self-energies.
  We have now enabled the calculation of the self-energies and
  pre-expanding them before saving them to heavily reduce the
  SCF calculation time.

  However, this comes at the cost of a file size Rep(El)
  times larger than by not expanding it.

  If the user really wishes to not pre-expand it, due to
  disk-space limitations, one can add the flag:
    pre-expand F
  in the electrode.

  It is now highly advisable that users use repeated electrodes.

* Moved the GF read functions into code m_ts_gf.
  This makes more sense.

* Removed the title of the GF files. They were not used
  for anything and did not help anything.

* Removed a couple of routines directly related to the
  data in the Electype.
  They were superfluous function calls.

modified:
  Src/Makefile
  Src/m_transiesta.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_fullg.F90
  Src/m_ts_fullk.F90
  Src/m_ts_gf.F90
  Src/m_ts_kpoints.F90
  Src/m_ts_method.f90
  Src/m_ts_mumpsg.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_options.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Util/TS/ts2ts/ts2ts.f90

----------------------------------------------------
July 4, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-161
Changed TSHS format to new size-reducing format

* The new TSHS format does not utilise the isa array.
  It provided no information and could still be erroneous.
  I am now relying fully on the super-cell indices.
  The size reduction is quite dramatic:
    -spin==1:
      old: ( 8 * 5 + 4 ) * maxnh
      new: ( 8 * 2 + 4 * 2 ) * maxnh
      reduction: 45%
    -spin==2:
      old: ( 8 * 6 + 4 ) * maxnh
      new: ( 8 * 3 + 4 * 2 ) * maxnh
      reduction: 38%

* Bugfix for lasto in reading GF, lasto is one length longer

* Stringent test on Global2LocalOrb in glob_sparse.
  This should never occur, so just a precaution.

* Added new ts-fdf format to all transiesta tests

* Bugfix for ts2ts fdf creator. It did not print the
  repetitions for electrodes.

* Created a utility to convert TSHS formats to other
  formats.
  As isa is not existing in the format anymore this now
  becomes a "wrong" array when converting the files. 
  Yet, I have never seen any code use that array.

  In directory: 
     Util/TS/tshs2tshs
  type make and copy tshs2tshs to a directory in your
  path.

added:
  Util/TS/tshs2tshs/
  Util/TS/tshs2tshs/Makefile
  Util/TS/tshs2tshs/m_ts_io_version.f90
  Util/TS/tshs2tshs/tshs2tshs.f90
modified:
  Src/Makefile
  Src/create_Sparsity_SC.F90
  Src/final_H_f_stress.F
  Src/geom_helper.f90
  Src/m_glob_sparse.F90
  Src/m_hs_matrix.f90
  Src/m_ts_electype.F90
  Src/m_ts_gf.F90
  Src/m_ts_io.F90
  Src/state_init.F
  Tests/TranSiesta-TBTrans/ts_au/au_111_capacitor.fdf
  Tests/TranSiesta-TBTrans/ts_au/bulk_au_111.fdf
  Tests/TranSiesta-TBTrans/ts_au/elec_au_111_abc.fdf
  Tests/TranSiesta-TBTrans/ts_au_100/au_100.fdf
  Tests/TranSiesta-TBTrans/ts_au_100_0.25V/au_100.fdf
  Tests/TranSiesta-TBTrans/ts_au_100_repetition/au_100.fdf
  Tests/TranSiesta-TBTrans/ts_au_100_repetition_0.25V/au_100.fdf
  Tests/TranSiesta-TBTrans/ts_au_repetition/au_111_capacitor.fdf
  Tests/TranSiesta-TBTrans/ts_fast/scat.fast.fdf
  Util/TS/README
  Util/TS/ts2ts/Makefile
  Util/TS/ts2ts/ts2ts.f90

----------------------------------------------------
June 26, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-160
Ensured no temporary arrays were created in IO routines

* When writing the TSHS a rare case of erroneous IO
  was implicit. This has finally been fixed (it was a remnant
  from Federico).

* Made transiesta transport direction and k-point sampling be 
  fully deterermined by the electrodes.

* When having few optimizations it could have problems passing
  an unallocated array, even though it is never used in the	
  subroutine. This has been fixed.

modified:
  Src/m_ts_io.F90
  Src/m_ts_kpoints.F90
  Src/m_ts_sparse.F90
  Src/ts_init.F90

----------------------------------------------------
June 26, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-159
Bugfix for buffer atoms in transiesta and added new updating scheme

* Loops were not traversing the entire sparsity pattern of
  the system when buffer atoms was used.
  This resulted in bad creating of the LHS before calculating
  the Greens function.

* Renamed idx_n[ao] to idx_[ao] for consistency.
  It is the index of atom (a) or orbital (o).

* Renamed projections into a space projector and vector
  projector. This enables both projections.

* Added a new update method which enables the updating of
  every element of an electrode even though bulk electrodes
  are used. This seems to heavily increase the charge
  conservation. The calculation is just as heavy as using
  cross-terms.
  This can be input via these constructs:
    TS.Elecs.DM.Update none|cross-terms|all
  or electrode locally:
    DM-update none|cross-terms|all
  It is encouraged for N/=2 electrode systems as charge
  conservation is bad in those cases.

* Cleaned up in Sparsity2trimat by changing an
  interface to a more generic one considering the trimat.

* The intel-compiler suggested to remove ZBulkDOS from 
  create_Green.
  I have done this to ensure that any access to an unallocated
  array is never done. It is now an optional array,
  if present it will return the DOS, otherwise nothing will be
  done.

* Made a k-point parameter for Gamma transiesta calculations.
  This prohibits an temporary array.

* Ensured that no k-points exists in any of the electrodes transport
  direction.
  TODO this should be enforced in every cell direction where
  the electrode unit-cell transport direction has any weight.
  Currently it only removes k-points in the most contributing 
  direction.

* Update utilities for changing updating mechanism. 

modified:
  Src/create_Sparsity_Union.F90
  Src/geom_helper.f90
  Src/intrinsic_missing.f90
  Src/m_transiesta.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_full_scat.F90
  Src/m_ts_fullg.F90
  Src/m_ts_fullk.F90
  Src/m_ts_gf.F90
  Src/m_ts_kpoints.F90
  Src/m_ts_method.f90
  Src/m_ts_mumps_init.F90
  Src/m_ts_mumpsg.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_tri_init.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/m_ts_trimat_invert.F90
  Src/m_ts_voltage.F90
  Src/m_ts_weight.F90
  Src/ts_init.F90
  Src/ts_show_regions.f90
  Util/TS/ts2ts/ts2ts.f90
  Util/TS/tselecs.sh

----------------------------------------------------
June 25, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-158
Added a projection function in intrinsic_missing

* Added the PROJ function in intrinsic_missing.
  It allows to project a vector from the Euclidian space into another 
  space direction.

* Cleaned a little up

modified:
  Src/dhscf.F
  Src/intrinsic_missing.f90
  Src/m_ts_electype.F90
  Src/m_ts_hartree.F90
  Src/m_ts_options.F90

----------------------------------------------------
June 25, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-157
Fixed multi-terminal Hartree potential fixation

* The Hartree potential needs a constant potential somewhere in the
  simulation cell.
  We now select the largest electrode basal plane to be the plane of 
  constant potential.
  I suspect that this fixation of the Hartree potential
  is the main cause of charge fluctuation as the potential is slightly
  changing doing SC.
  TODO Check if other methods exists to fixate the Hartee potential offset.

* Added write-out of distance error in the electrode.
  It basically shows the length of the vector between the two positions.

* Cleaned a little up in k-points routine. It could do with some more 
  cleaning.

modified:
  Src/Makefile
  Src/dhscf.F
  Src/m_ts_electype.F90
  Src/m_ts_hartree.F90
  Src/m_ts_kpoints.F90
  Src/m_ts_mesh.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_voltage.F90
  Src/ts_init.F90

----------------------------------------------------
June 16, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-156
Require well defined transport direction for 2 electrodes

* We require that the user only uses 1 transport direction
  for two electrodes. Else the electrostatic potential 
  will not be well defined.

modified:
  Src/m_ts_options.F90

----------------------------------------------------
June 13, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-155
Completed MUMPS non-equilibrium calculation, now 3 methods!

* Using MUMPS for non-equilibrium calcuations has now
  been enabled. I suspect it to have the same performance
  vs. the BTD method, i.e. one should revert to the MUMPS
  method if the blocks of the tri-diagonal matrix are "bad".

  The matrix product is done using the already allocated 
  work-array in MUMPS. This means that we do not need 
  to allocate any more memory for calculating the:
    Gf.Gamma.Gf^\dagger
  
  The only way I see an optimized version of the 
  triple-matrix product above (for MUMPS, and full) is to
  restrict the product in each row/column in the range of
  interaction orbitals. However, this would require that
  the product is done on a per-row/column basis possibly
  loosing some of the performance gained from the fast BLAS.
  (only if the overhead of our loops and starting BLAS is
  larger than the calculation itself).

  I look forward to (if I get/have the time) to make this fully
  distributed as MUMPS uses quite a bit of memory. :)

added:
  Src/m_ts_mumps_scat.F90
modified:
  Src/Makefile
  Src/m_ts_electype.F90
  Src/m_ts_full_scat.F90
  Src/m_ts_mumps_init.F90
  Src/m_ts_mumpsg.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_options.F90

----------------------------------------------------
June 12, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-154
Weighting method revised so high charge => high weight

* For sum/tr-atom-? we have revised the algorithm to take into account
  each of the atoms total charge, rather than their individual mean.
  This means that the weighting method has larger influence on atoms
  with high charge. 

modified:
  Src/m_ts_weight.F90

----------------------------------------------------
June 12, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-153
Added MUMPS blocking factor to be user defined

* The blocking factor has great performance gains by utilising a larger
  block for MUMPS.
  It is highly advisable for the user to set this at run-time.
  Currently it is the MUMPS default (8), but I suspect that a better
  default would be around 50 or 100.

modified:
  Src/m_ts_mumps_init.F90
  Src/m_ts_mumpsg.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_options.F90

----------------------------------------------------
June 12, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-152
Reverted to ts_Gamma instead of SIESTA-Gamma only

* I had completely forgotten that if it is SIESTA
  non-Gamma, the calculation for the supercell
  contributions are defined exactly the same as if it
  was a Gamma calculation. Hence, we now use
  ts_Gamma to determine whether we are dealing with 
  a Gamma calculation or not.
  Many calculations will now reduce to Gamma calculations
  if it is ts_Gamma and not Gamma.

* The MUMPS solver now prints out some estimated memory
  sizes in the log files.

* Changed ts_Gamma_scf to ts_Gamma.

modified:
  Src/final_H_f_stress.F
  Src/m_transiesta.F90
  Src/m_ts_dm_update.F90
  Src/m_ts_kpoints.F90
  Src/m_ts_mumps_init.F90
  Src/m_ts_mumpsg.F90
  Src/m_ts_mumpsk.F90
  Src/m_ts_sparse.F90
  Src/state_init.F

----------------------------------------------------
June 11, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-151
Bugfix for buffer atom definitions

* When reading in single atomic positions in the
  TS.Atoms.Buffer block it was not wrapped around
  for negative positions.
  I have now also fully removed the 
   - TS.BufferAtomsRight
   - TS.BufferAtomsLeft
  keywords.

* Added printout of optimal energy-points choice.
  The user is now encouraged to optimize the number of
  contour points. Both in the equilibrium and non-equilibrium
  contour.

* Added a write-out of the maximal mismatch vector when the 
  atomic coordinates of the electrode/system does not match.

modified:
  Src/m_ts_electype.F90
  Src/m_ts_method.f90
  Src/m_ts_options.F90

----------------------------------------------------
June 11, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-150
Added MUMPS solution method for TRANSIESTA

* Added the MUMPS solver for calculating the Green's function.
  Currently, this method only works with the equilibrium 
  contour. 
  The only thing that is needed is to modify GF_Gamma_GF
  to handle the sparsity resulting array. 
  The code should have been finalized to be able to calculate
  the desired GF-columns.

  The compilation of this is enabled using the MUMPS-flag
  So the arch.make file needs at least to have these flags:
  
  FPPFLAGS += -DMUMPS
  LIBS += -lzmumps -lmumps_common -lpord [[-lparmetis] -lmetis] [-lscotch]

  with correct linking of the MUMPS library.

  the libraries:
    - parmetis, metis
    - scotch
  are not necessary but are if MUMPS has been compiled with them.

  The MUMPS library only calculates the necessary elements of the 
  Green's function. 
  It will not pay of to utilise this for systems below 4000 orbitals.
  There I would suggest to use the tri-mat method.

  To use the MUMPS library simply do this:
    TS.SolutionMethod MUMPS

  There are a couple of pitfalls related to how MUMPS
  works.

  1. Output files for the MUMPS routines are created according to:
     TS_MUMPS_<Node>.dat
     They contain relevant information from MUMPS and should be
     consulted always. If INFOG(1) /= 0, an error has occured.
  2. They are overwritten at every SCF cycle and contain the 
     messages that MUMPS provides.
  3. If you experience an error:
      INFOG(1) = -9
     you probably have too little memory allocated.
     The memory utilised can be handled through this:
       TS.MUMPS.Mem <integer>
     the default is 20, which is the MUMPS default.
     This can be raised until the above error disappears.
     Else the matrix factorization proves extremely difficult and 
     I don't know what can be done.
     If any other error messages pops up, please consult the
     MUMPS documentation.
  4. The ordering can significantly reduce analysis step and memory usage.
     Currently these are allowed:
       TS.MUMPS.Ordering <string>
     <string> being:
        auto : MUMPS decides
        AMD  : use the AMD ordering
        AMF  : use the AMF ordering
        SCOTCH : use scotch library (MUMPS needs to be compiled with it)
        PORD : use the PORD ordering
        METIS : use METIS ordering (MUMPS needs to be compiled with it)
	QAMD : use the QAMD ordering (for long range basis this could be good)
   
   Notice the MUMPS library has a print-statement:
    "Processing the RHS in post-order"
   which apparently is not directed into the message files.
   I can't change this, so stick with it. :)

   If you think MUMPS is using too much memory you can reduce this:
       TS.MUMPS.Mem <integer>
   however notice point 3 above.

added:
  Src/m_ts_mumps_init.F90
  Src/m_ts_mumpsg.F90
  Src/m_ts_mumpsk.F90
modified:
  Src/Makefile
  Src/m_transiesta.F90
  Src/m_ts_method.f90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/state_init.F

----------------------------------------------------
June 9, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-149
Finalised 5 different weighting schemes

* The weighting can now be performed like:
   - orb-orb
     each orbital calculates its own weight
   - trace of atom-atom
     each atoms trace of the correction is used
   - trace of atom-orb
     each atoms trace of the correction is used together
     with the local orb-orb weight
   - sum of atom-atom
     each atoms total correction with itself is used
   - sum of atom-orb
     each atoms total correction with itself is used
     with the local orb-orb weight

  The 4 latter weighting schemes provide very similar
  results. However, the difference for the last 4 and
  the default one is relatively big.

modified:
  Src/m_ts_options.F90
  Src/m_ts_weight.F90

----------------------------------------------------
June 6, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-148
Added yet another weighting method, cleaned up fdf keys

* The weighting can now be performed like:
   - orb-orb
     each orbital calculates its own weight
   - trace of atom-atom
     each atoms trace of the correction is used
   - sum of atom-atom
     each atoms total correction with itself is used

  This was rather easy to implement as trace and sum 
  are very similar.

  They also seem to provide a similar result.

* The keywords for using the weighting methods have changed
  to something more generic:
    TS.Weight.k.Method
      - correlated
      - uncorrelated
  to determine which type of weight for each k-point.
  
    TS.Weight.Method
      - orb-orb
      - tr-atom-atom
      - sum-atom-atom 
  is then used to determine the how the weighting is done
  for each k-point.

modified:
  Src/m_ts_fullk.F90
  Src/m_ts_options.F90
  Src/m_ts_trik.F90
  Src/m_ts_weight.F90

----------------------------------------------------
June 5, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-147
Added a utility convert an old TS-fdf to new TS-fdf

* In the folder Util/TS I have added a utility
  to convert an fdf file from the old input format
  to an equivalent new format.
  It is located in the folder:
    Util/TS/ts2ts/
  It needs to be compiled like any other utility for SIESTA.

  It can be called like:
    ts2ts <fdf file>
  and should not be piped.
  For help on the utility call:
    ts2ts -h
  for a brief explanation of options.

  However, it is useful to pipe it into another file. 
  Say your fdf-file is "run.fdf" you call this:
    ts2ts run.fdf > new.fdf

* Bugfix in Makefile for Util/Grimme utility.

added:
  Util/TS/README
  Util/TS/ts2ts/
  Util/TS/ts2ts/Makefile
  Util/TS/ts2ts/ts2ts.f90
modified:
  Src/m_ts_options.F90
  Util/Grimme/Makefile

----------------------------------------------------
June 5, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-146
Forces the user to create their own input for Elec /= 2

* Transiesta now stops if any input has not been given and the 
  number of electrodes/chemical potentials are
  different from 2.
  Say the user inputs 3 electrodes and expects Transiesta
  to auto-generate input. This is not allowed.

* Changed the default energy separation in the non-eq tail
  to delta 0.01 eV instead of 1 kT.
  (I really should implement a "min" function to handle 
  min(0.01 eV,1 kT)).

modified:
  Src/m_ts_contour_eq.f90
  Src/m_ts_contour_neq.f90
  Util/TS/tselecs.sh

----------------------------------------------------
June 5, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-145
Added weight function per atom for the non-equilibrium part

* When weighting the non-equilibrium contribution it can be
  performed using 2 methods now:
   1) Per orbital interaction
   2) Per atom    interaction (trace of DMneq at atom i)
  (combining with correlated/uncorrelated weighting is a
   permutational choice)

  The weighting is performed by calculating the variance
  contribution for each chemical potential corresponding to
  each orbital/atom. 

  For orbitals it is as in the original paper.

  For atomic weighting we calculate the geometric mean
  for the two resulting in the same weighting for all
  orbitals \mu,\nu for \mu\in ia and \nu \in ja.
  This can improve the convergence if many of the orbital
  interactions are very weak so that the variance can be 
  ill defined.
  What will typically happen is that the weight will be 
  "spread" more out, but held constant for all atom-atom
  interactions.

modified:
  Src/Makefile
  Src/m_transiesta.F90
  Src/m_ts_fullg.F90
  Src/m_ts_fullk.F90
  Src/m_ts_options.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/m_ts_weight.F90

----------------------------------------------------
June 4, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-144
Fermi fraction in cross-terms bugfix, and inf-tail bugfix

* When the user accidentially used:
    "delta 0.01 eV"
  with a boundary at infinity it did not error out.
  This has been fixed, it is now not possible to 
  use delta with infinity.

* The fractional cross-term fermi level is now not
  allowed when updating the cross-terms.
  The concept is that it should be used to compensate
  for the missing updated elements, and if we update
  we are pushing the Hamiltonian elements further out of their 
  basin.
    
modified:
  Src/m_ts_electype.F90
  Src/m_ts_io_ctype.f90

----------------------------------------------------
June 3, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-143
Enabled bandwidth reduction of the transiesta method

* The bandwidth reduction of the scattering region has 
  been re-enabled.
  It still does not consider the electrodes as that
  poses some logistic problems in the code.
  I suspect that the electrodes are really necessary
  when dealing with N_Elec > 2.

modified:
  Src/m_bandwidth.f90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/state_init.F

----------------------------------------------------
June 3, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-142
Bugfix for ts_show_regions

* In case the buffer regions were ending it printed
  an erronous line.
  This has been fixed to handle arbitrary types.

modified:
  Src/ts_show_regions.f90

----------------------------------------------------
June 3, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-141
Made buffer atoms be where they are needed

* When adding more electrodes it becomes cumbersome
  to track the placement of the buffer atoms.
  The buffer atoms can now be defined using this block:
  %block TS.Atoms.Buffer

  which is constructed much similar to GeometryConstraints

* A buffer atom is now handled careless of its position
  in the fdf file. Hence you can have buffer atoms in the 
  middle of the fdf.

  This required some minor restructuring of the code.

  Currently I have tested this with 1 buffer atom:
    - at the start
    - in the middle
  and got the same result. 
  It needs more testing.

* The printing of the regions are corrected to
  handle the above cases. It will print out /
  around all buffer atoms in clusters.

* The faster_parts algorithm has been improved.
  It now determines the fastest parts on the basis
  of number of elemental operations in the inversion 
  routines.

* Bugfix for V = 0 and several chemical potentials
  The number of poles were not correctly passed over
  this meant that N_poles was zero.
  We now check all contours for 0 points in the contour.
  It will not be tolerated.
  This bug was introduced in:
    rev-580

* Bugfix for the bandwidth calculation. The reverse algorithms
  had always been wrong.
  The goal is that it should pivot together with the electrode.
  Very little code is needed to do this.

modified:
  Src/Makefile
  Src/create_Sparsity_Union.F90
  Src/intrinsic_missing.f90
  Src/m_bandwidth.f90
  Src/m_transiesta.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_charge.F90
  Src/m_ts_chem_pot.f90
  Src/m_ts_contour.f90
  Src/m_ts_contour_eq.f90
  Src/m_ts_contour_neq.f90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_full_scat.F90
  Src/m_ts_fullg.F90
  Src/m_ts_fullk.F90
  Src/m_ts_gf.F90
  Src/m_ts_hartree.F90
  Src/m_ts_mesh.F90
  Src/m_ts_method.f90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri_init.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/m_ts_trimat_invert.F90
  Src/m_ts_voltage.F90
  Src/m_ts_weight.F90
  Src/siesta_forces.F
  Src/state_init.F
  Src/ts_init.F90
  Src/ts_show_regions.f90
  Util/TS/AnalyzeSort/tsanalyzesort.py

----------------------------------------------------
May 22, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-140
Refactored contour/chemical potential setup for easy start

* The very elaborate fdf-system for inputting the chemical
  potential and the contours has now been eased by a 
  default system for regular transiesta.
  If the code does not find any chemical potentials and/or
  contours it will create contours for a 2-electrode system  
  automatically.

  This lets the user run an fdf file, copy a sample fdf
  from the output and customize to ones needs.
  All information needed to extend ones own setup system 
  is now included in the print-out of the fdf-setup.

  However, the user still needs to setup the electrodes
  manually (however this should be more intuitive).

* The number of poles is now per-chemical potential.
  This was just so easy to add, that it was added.
  It will correctly error out if the user overlays
  two contour-segments with different number of 
  poles.

* Added print-out of the chemical potential setup in
  ready to copy format into fdf.

modified:
  Src/m_ts_chem_pot.f90
  Src/m_ts_contour.f90
  Src/m_ts_contour_eq.f90
  Src/m_ts_contour_neq.f90
  Src/m_ts_electype.F90
  Src/m_ts_io_ctype.f90
  Src/m_ts_options.F90

----------------------------------------------------
May 22, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-139
Clean up in electype, changed some fdf-keywords for the electrode

* Many of the elemental routines from elec_type where not helping
  the code factoring. Hence all single return value routines
  have been deleted. This should make the code less cluttered.

* Changed the keyword name semi-inf-dir to both have the
  transport direction and the infinite direction.
  The format of such an input is:
    [-+][a-c|a[1-3]]

* Changed tselecs.sh to conform with the changes, also
  made it print a working copy if doing:
  tselecs.sh -2
  Then one only needs to change the TSHS file

modified:
  Src/m_transiesta.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_gf.F90
  Src/m_ts_options.F90
  Util/TS/tselecs.sh

----------------------------------------------------
May 3, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-138
Bugfix for transiesta work-size array estimation

* The work-array estimation incorrectly determined the
  size required.
  
  However, the code has an automatic check so that it
  will be caught no matter what.

modified:
  Src/m_ts_tri_scat.F90

----------------------------------------------------
April 16, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-137
Bugfix for transiesta transition, pulay not reset if fire/broyden

* When changing from diagon to transiesta we automatically reset
  the pulay arrays. 
  However, if fire_mix or broyden mixing is used we don't need 
  to do this. 
  We now check which type of mixing is performed and only reset
  the pulay mixing if that is used.

modified:
  Src/siesta_forces.F

----------------------------------------------------
April 15, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-136
Enabled E-field for transiesta if they are perpendicular

* If the electric fields are perpendicular to the transport 
  direction we can in principle allow electric fields.
  It should not violate the periodicity of the system.
  However the handling of the electrode-device region
  is blurred by this concept. 
  Hence any usage of electric fields with transiesta
  is given a warning.
  
* The transport-direction variable is now also an error-handler.
  For negative values it describes the number of electrodes.
  And any N_Elec /= 2 will mean ts_tdir = - N_Elec.
  This makes transiesta checks across the code more stringent
  as we can easily check for the validity of Hartree potential
  for the electrode setup.

modified:
  Src/Makefile
  Src/dhscf.F
  Src/m_ts_hartree.F90
  Src/m_ts_kpoints.F90
  Src/m_ts_options.F90
  Src/m_ts_voltage.F90

----------------------------------------------------
April 3, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-135
Bugfix for intel compiler

* The intel compiler cannot handle pointer/target
  assignments (see m_ts_hartree)
  We did:
    integer, target :: i1,i2
    integer, pointer :: iT
    
    if ...
      iT => i1
    else if ...
      iT => i2

  apparently the above lead to memory leaks.
  I tried using the exact same thing without pointer/target
  and that worked perfectly.
  Hmm...

* Fixed the case of non-bulk electrodes and the position of
  the potential field.
  I.e. it should not be moved to the electrode boundary.

* Changed references to Name(this) in electrode file

modified:
  Src/dhscf.F
  Src/m_ts_electype.F90
  Src/m_ts_hartree.F90
  Src/m_ts_mesh.F90
  Src/m_ts_voltage.F90
  Src/ts_init.F90

----------------------------------------------------
April 2, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-134
Further reduced the Gf.G.Gf triple product

* Redid the triple product for the non-equilibrium
  contour. 
  This made restricts the calculation further and increases
  the throughput without any loss of accuracy.
  We are merely calculating the needed quantities.

modified:
  Src/m_ts_tri_scat.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90

----------------------------------------------------
March 30, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-133
Implemented the restrictive tri-mat inversion

* In my original implementation we only calculated the 
  needed blocks. 
  I have now re-implemented this to get the full
  speed-up that the algorithm deserves.

* I believe that some optimization can still be found
  in the non-equilibrium contour. I need to look into
  this later on.

modified:
  Src/m_trimat_invert.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/m_ts_trimat_invert.F90

----------------------------------------------------
March 28, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-132
Index lookup in tri-diagonal matrices are now easier

* The calculation of the indices for looking up values in the
  tri-diagonal matrix was not optimal.
  I have re-implemented some of the routines to ease the 
  look-up.
  It does not provide that much of speed-up (which suggests
  that its quite fast even before).
  So that is a comforting aspect.

* When the sparsity pattern is evened out we now start by taking the 
  largest block and "smear" that out. 
  This will typically not mean anything. But I have a hunch that
  for certain (wide @ middle) systems this could be useful

modified:
  Src/class_TriMat.T90
  Src/m_ts_Sparsity2TriMat.F90

----------------------------------------------------
March 23, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-131
Added informational output and moved TSmode to global_vars

* When the user has unwieldingly chosen a prime as a sampling
  of the system in question and does not wish to degrade the 
  sampling, one can not use the repetition. 
  However, in certain cases (where the k-point sampling is 
  more than enough) the electrode k-point sampling does
  not introduce any noticeable changes to the TB-Hamiltonian.
  In these cases it could be useful to not force the exact 
  k-point overlaying the Bloch-states.
  I would never recommend users to do this unless they know
  what they are doing. Hence, I don't think we should document
  this feature.

* Added more output wrt. to electrode setups.
  A couple of warnings has been added.

* Added a print-out of the size requirement for the 
  Green's function file.
  This will enable users to quickly analyze their 
  disk-utilization.

* Moved the TSmode from ts_options to ts_global_vars
  which makes more sense as it in total determines 
  the transiesta usage.

modified:
  Src/Makefile
  Src/compute_dm.F
  Src/dhscf.F
  Src/m_new_dm.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_global_vars.f90
  Src/m_ts_kpoints.F90
  Src/m_ts_options.F90
  Src/siesta_forces.F
  Src/ts_init.F90

----------------------------------------------------
March 21, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-130
Bugfix for tri-mat creation for small systems

* When the systems was very small the initial tri-mat blocks
  could be the "best" but a non-valid block division.
  The blocks are now correctly handled.

* A consistent check of the entire tri-mat block is now made.

  Before it was all but the last block that was checked.
  The last block should be apparent from the sparsity setup.
  However, for consistency we add the full check.

* Added more output in case of errors in the tri-mat setup

modified:
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_tri_init.F90

----------------------------------------------------
March 19, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-129
Fixed potential field placement for uneven Fermi shift

* In case the regular convention \mu_L = V/2, \mu_R = - V/2
  is not used the correct potential is now inserted.
  It thus takes into account the chemical potential in the
  leads.

* Clarified the output of the super-cell orbitals when the 
  electrode is not big enough.
  I.e. people who knows the sparsity layout can read the
  Hamiltonian and read of the element.

* A bug is present in the in-core calculation of the 
  self-energies with bias applied.
  I tried to find the bug, but to no avail.
  TODO bug in in-core calculation with bias

modified:
  Src/m_mat_invert.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_voltage.F90

----------------------------------------------------
March 18, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-128
Bugfix for makefile

modified:
  Src/Makefile

----------------------------------------------------
March 18, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-127
Tri-mat memory optimization routine now takes into account the workarray

* In case of bias calculation the memory required for the work
  array is now taken into account.
  This was unlike the previous method. However, for very long systems
  this should not matter much.

* Fixed a bug which showed the memory only half of what it was.

* Added a rotation matrix for vectors in 2D and 3D (in intrinsic_missing)

modified:
  Src/intrinsic_missing.f90
  Src/m_transiesta.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_tri_init.F90
  Src/m_ts_tri_scat.F90

----------------------------------------------------
March 17, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-126
Allowed to shift the fermi level arbitrarily

* Allowed electrode fermi-shifts to be shifted as wanted 
  i.e. the user can now have the bias convention:
    0 -- V 
    -V -- 0
    -V/2 -- V/2
  etc.
  However, the requirement is that the chemical potential
  should not exceed the total potential across the junction.
  I.e.:
    V -- 2V
  etc. are not allowed.
  I have not fully worked out the equations, but I don't see
  that it should behave differently.

* When requesting memory reduced calculations with tri-mat
  we now also take into account the work-size when doing bias
  calculations.

modified:
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_options.F90
  Src/m_ts_trimat_invert.F90

----------------------------------------------------
March 17, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-125
With 1 electrode the tri-mat always made an empty part

* Bugfix for the creation of the tri-diagonal matrix
  creation with respect to 1-electrode systems.
  It now works with the tri-mat and the sparse.
  Have tested it on a gold-111 slab and it seems to
  work expected.

modified:
  Src/m_ts_Sparsity2TriMat.F90

----------------------------------------------------
March 14, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-124
Bugfix in Makefile, removed the link to the libraries

modified:
  Util/Grimme/Makefile

----------------------------------------------------
March 14, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-122
Added a tool to convert a species list to a Grimme MM input

* In Util/Grimme I have created a program which
  can be compiled as:
    cd Util/Grimme
    make
  and the executable:
    fdf2grimme
  is created.
  This executable is called as this:

    fdf2grimme [fdf-file]
  where it will read the ChemicalSpeciesLabel block
  and create an output to the command line which sets 
  all the Grimme parameters ready for vdW forces.
  It also handles correctly the floating orbitals, i.e. it
  disregards those as the forces on those does not really make sense.

added:
  Util/Grimme/
  Util/Grimme/Makefile
  Util/Grimme/grimme.f90

----------------------------------------------------
March 14, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-121
Fixed MM reading to dynamic allocation and also allowed better units

* MM.Potentials was not dynamically allocating required potentials
  
  This has been fixed

* An instability in the units conversion for the MM potentials 
  was not consistent which made it extremely error-prone regarding
  the fdf philosophy.
  The keywords were not case sensitive and the only allowed energy
  was eV, everything else (including ev) was regarded as Ry.
  
modified:
  Src/molecularmechanics.F90

----------------------------------------------------
March 13, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-120
Added the possibility of having only 1 electrode

* For slap calculations it could be handy to calculate the electronic
  structure using the Green's function technique to fully capture the
  semi-infinite system.
  For non-metallic systems long range surface potentials could be crucial.
  1-electrode calculations are not allowed to supply a bias.
  
modified:
  Src/m_ts_options.F90

----------------------------------------------------
March 5, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-119
Bugfix for tselecs.sh and added t-dir for electrodes

* tselecs.sh is still not optimal, the chemical potentials
  should most likely be posted inversely.

modified:
  Src/m_ts_electype.F90
  Util/TS/tselecs.sh

----------------------------------------------------
February 23, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-118
Changed names for electrode options

* The electrode options where not properly defined.
  We now have a bit more regularity in naming scheme and
  a bit more short-hands for options.

modified:
  Src/m_ts_electype.F90
----------------------------------------------------
February 28, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-117
Bugfix for tselecs.sh

modified:
  Util/TS/tselecs.sh

----------------------------------------------------
February 28, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-116
Enabled chemical potential position to be dependent on TS.Voltage

* Added the option of using the TS.Voltage flag again.
  Now, the chemical potentials should preferably be used like this:
   %block TS.ChemPot.<Name>
     mu V/2
     ...
   %endblock
  which makes input more flexible.

  Currently we don't allow the user to add temperature dependent bias.

  I have also updated the tselecs.sh script accordingly.
  It is not so stringent any-more and a few edits are needed afterwards.
  (the user is notified if using the program.)

modified:
  Src/m_ts_chem_pot.f90
  Src/m_ts_options.F90
  Util/TS/tselecs.sh

----------------------------------------------------
February 23, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-115
Moved TSAnalyzeSort to TS folder

* Moved TSAnalyzeSort utility to TS folder
  and renamed it to AnalyzeSort.
  This will let me better control the utilities that
  should be present for transiesta.

renamed:
  Util/TSAnalyzeSort/ => Util/TS/AnalyzeSort/

----------------------------------------------------
February 22, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-114
Added in-core calculation of surface Green function

* Enabled the calculation of the surface Green function
  "in-core" which means that we have prepared for tbtrans
  re-coding.
  It can be used for extreme number of contour points, but
  should in general not be used. It is very slow as it does
  a lot of operations twice as many times.
  However, if one were to use it the penalty of using this
  feature would drastically decrease if one uses the 
  repetition.
  
  I have tried to limit the memory usage as much as possible,
  for very large systems, we will not use more memory as the
  entire work-array should be able to have 8-9 times the 
  electrode-size.

* Made m_mat_invert capable of handling levels of inversions.
  I.e. it should be able to handle
  
  .. 
     call init_mat_inversion(<size1>)
  ..
     call init_mat_inversion(<size2>)
  .. 
     call clear_mat_inversion()
  ..
     call clear_mat_inversion()

  it will only clear the pivoting array after the last level
  has been cleared.     

* Enabled a per-electrode need for reusegf option.
  Probably never will be used, however, it can leverage calculation
  for many electrode systems.

* A fractional method for "spilling in the fermi-level" from the
  electrodes has been enabled.
  It should be considered highly experimental as it exposes
  the electrode chemical potential with the central region chemical
  potential.
  The original (frac == 0) method:
    H_LL = H - (E - mu_L) S  
    H_LC = H - E S  
  the frac /= 0 method:
    H_LL = H - (E - mu_L) S  
    H_LC = H - (E - <frac> * mu_L) S  
  
  I have not tested this vigorously, and its physical meaning can be
  questioned. However this is also the case for the original method.

* Fully indented and cleaned a little up in the m_ts_options module

modified:
  Src/Makefile
  Src/m_mat_invert.F90
  Src/m_transiesta.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_fullg.F90
  Src/m_ts_fullk.F90
  Src/m_ts_gf.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
  Src/m_ts_trimat_invert.F90
  Src/ts_init.F90

----------------------------------------------------
February 16, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-113
Added transiesta script to create electrode/contour input

* A script Util/TS/tselecs.sh can create input for the
  new transiesta method.
  It has several options to ease the initialization of the
  input FDF files.
  The most useful thing must be the direct calls:
   tselecs -2
  which creates output that associates the original transiesta
  settings. One can call the command with many options to 
  ease the creation of the contours etc.
  In fact:
   tselecs -2 
  is equivalent to this:
   tselecs -el1 pos=1,inf-dir=-a3,mu=Left,name=Left \
           -el2 end-pos=-1,inf-dir=+a3,mu=Right,name=Right \
	   -mu1 name=Left,mu=0.25 -mu2 name=Right,mu=-0.25
  The help menu for the command is quite instructive with
  the available options.

added:
  Util/TS/
  Util/TS/tselecs.sh

----------------------------------------------------
February 13, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-112
Cosmetic fix

* A print-out was not placed as intended.

modified:
  Src/m_transiesta.F90

----------------------------------------------------
February 13, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-111
Detection of tri-diagonal matrix for N_Elec > 2 was buggy

* Bugfix for the inital creation of the tri-diagonal matrix.
  It did not sum up to the actual number of orbitals, which 
  made it crash.

* Detection of overlapping electrodes was wrong. It now correctly
  detects whether electrodes overlap or not. (i.e. it is not allowed)

modified:
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_options.F90

----------------------------------------------------
February 10, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-110
Fixed weight of right/left contour types it is also faster

* Bugfix for the weights of the left/right assignment of the
  even weight functions.
  As the bounds were set to double the distance the weights 
  were correct.

modified:
  Src/m_ts_contour_eq.f90

----------------------------------------------------
February 5, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-109
Added memory print-out and a bugfix for non-existing contour

* A memory print-out of the estimated memory usage per processor
  has been added.
  It only prints out the memory used for the 3 electrode arrays,
  the sparse matrices in transiesta and the matrices used
  for inversion of the Green's function

modified:
  Src/m_transiesta.F90
  Src/m_ts_contour_neq.f90
  Src/m_ts_io_ctype.f90

----------------------------------------------------
February 4, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-108
Enabled electrode position by end, absolute V in contour enabled

* When specifying the contour layout the bias was never used
  as is. Now input is differentiated between:
    |V|/2 and V/2
  from the obvious numeric meaning.
  Input using the |V| is important in the bias non-equilibrium
  contour which ALWAYS must be put in increasing order.
  
  This required an edit to fdf to handle | as a regular token.

* The electrode positions can now be determined using:
  %block ..
   electrode-position end -4
  %endblock
  which means that the "na_u - 4"'th atom is the last one
  in the electrode

* A bugfix for printing out spin-polarized charge when entering the transiesta

* Both equilibrium and non-equilibrium contours now show different output
  when dying. 
  It prints what has so far been put in the c_io types
  so that debugging the input is easier to read.

modified:
  Src/fdf/parse.F90
  Src/m_ts_charge.F90
  Src/m_ts_contour_eq.f90
  Src/m_ts_contour_neq.f90
  Src/m_ts_electype.F90
  Src/m_ts_io_ctype.f90

----------------------------------------------------
January 30, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-107
Added TS_timings through -DTRANSIESTA_TIMING

* Added timing for transiesta, now the partition of timing is
  very stringent.

* Removed unnecessary file m_ts_full.F90 which was a left-over

removed:
  Src/m_ts_full.F90
modified:
  Src/Makefile
  Src/m_ts_fullg.F90
  Src/m_ts_fullk.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90

----------------------------------------------------
January 29, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-106
Bugfix for non-equilibrium weights of "wrong" chemical potential order

* The contribution to the non-equilibrium contour was wrong in 
  certain cases of the chemical potential ordering.

* The actual contribution to the weights was far more simple
  than first anticipated. 
  Thus a routine from m_ts_contour_neq has been removed.

modified:
  Src/m_ts_contour_neq.f90
  Src/m_ts_options.F90
  Src/m_ts_voltage.F90
  Src/m_ts_weight.F90

----------------------------------------------------
January 28, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-105
Can detect the sign of the bias in transiesta

* The placement of the potential profile now works irrespective 
  of the order of the electrodes.
  We also limit the atomic coordinates in the transport direction
  to be limited within the unit-cell.

modified:
  Src/m_ts_options.F90
  Src/m_ts_voltage.F90

----------------------------------------------------
January 28, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-104
fixed.F recreated to be able to check if atom is fixed

* When transiesta wants to do relaxation we must enforce that
  buffer atoms and electrodes are restrained.
  Hence we needed to add a check against fixed atoms.
  This meant a restructure of the fixed.F code with a separate
  init_fixed routine and an additional "is_fixed(ia)" function.
  
  ts_init checks that the buffers and electrodes are restrained
  when running a structural relaxation/MD

* The FDF debugging has been troubling me for quite some time,
  it now also prints out the line 
  NOTE/TODO I believe the check for available tokens is wrong
  in "parse/characters"
  It should be:
    if (      (loc_init .lt. 1)                   &
           .OR. (loc_init .gt. pline%ntokens)       &
           .OR. (loc_final .lt. 1)                  &
           .OR. (loc_final .gt. pline%ntokens)      &
           .OR. (loc_final .lt. loc_init)           &
         )  then
	 > wrong limits

* Fixed print-out of transiesta timing when doing relaxation.
  Will now print right after IterSCF printout

* Bugfix for checking same valued chemical potentials
  The check is now as strict as the IsVolt check, which makes sense

modified:
  Src/Makefile
  Src/fdf/parse.F90
  Src/fdf/utils.F90
  Src/fixed.F
  Src/m_transiesta.F90
  Src/m_ts_options.F90
  Src/m_ts_trimat_invert.F90
  Src/siesta_forces.F
  Src/siesta_init.F
  Src/ts_init.F90

----------------------------------------------------
January 27, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-103
Creation of 2D array with zero elements should be allowed

* Re-enabled the creation of 0-length 1D/2D sparse data arrays
  as it is necessary if some systems have no update elements in 
  their local sparsity pattern. (in TS)

modified:
  Src/class_Data1D.T90
  Src/class_Data2D.T90

----------------------------------------------------
January 23, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-102
Will not allow several chemical potentials with the same value

* Check for same value of chemical potentials is now correct

* Changed the limit for bias calculation to 0.01 mV

* Cleaned some option

modified:
  Src/m_ts_options.F90

----------------------------------------------------
January 21, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-101
Bugfix for determining work-size

* The work-size array was referencing out-of-bounds, this could
  result in too much, or too little memory allocated.

modified:
  Src/m_ts_tri_scat.F90

----------------------------------------------------
January 21, 2014 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-100
Added both the tri-diagonal Gamma-only and k-point transiesta routine

* Have recreated the tri-diagonal routine in both Gamma-only and k-only
  routines.
  - Currently the routines uses a work-array to handle the Gf.G.Gf
    product. It is not really saving a lot of memory currently, however
    it saves a bunch of time as the Gf calculation is now performed only 
    once.
    This could be leveraged at the expense of re-calculating the Gf
    for each electrode.
  - The new tri-diagonal routine is easier to read (especially for the
    Gf-column calculation)
  - Removed the old tri-diagonal routine for only 3-parts.
    We would like to re-instantiate it somehow... But not now.

  I still need to check the multi-electrode case.

* Made the non-equilibrium ID also contain an equilibrium ID
  so that look-ups are much easier (faster)

* Currently some code is left over from the development check

* Bugfix in contour check for circle contour on the correct side of the 
  fermi-level

* Added so that electrodes can get "start" or "end" as position
  in device.

* Cleaned interfaces for transiesta routines

* Removed the need for sorting the electrodes

* Made the code handle correctly if there is no applied bias

* Removed all references to the monitor function.
  It is too obscure. Instead we should do something else.
  (It will be easier when the NetCDF is up and running)

* Split up the hartree potential fixing and the potential drop
  inclusion into two modules.
  We have further added a "mesh" module which takes care of
  calculating the necessary quantities for the Hartree fix and
  Voltage routines.
  This will also make a good base for the further development of
  the Poisson equation solver.
  Routine names have changed accordingly.

removed:
  Src/m_ts_tri.F90
added:
  Src/m_ts_hartree.F90
  Src/m_ts_mesh.F90
  Src/m_ts_tri_init.F90
  Src/m_ts_trig.F90
  Src/m_ts_trik.F90
modified:
  Src/Makefile
  Src/dhscf.F
  Src/m_transiesta.F90
  Src/m_trimat_invert.F90
  Src/m_ts_cctype.f90
  Src/m_ts_charge.F90
  Src/m_ts_chem_pot.f90
  Src/m_ts_contour.f90
  Src/m_ts_contour_eq.f90
  Src/m_ts_contour_neq.f90
  Src/m_ts_dm_update.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_fullg.F90
  Src/m_ts_fullk.F90
  Src/m_ts_io_contour.f90
  Src/m_ts_io_ctype.f90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_trimat_invert.F90
  Src/m_ts_voltage.F90
  Src/m_ts_weight.F90

----------------------------------------------------
December 16, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-99
Added a k-point full transiesta routine

* Have added a k-point calculation of transiesta with same usability as the
  Gamma calculation.

* Added both the correlated and the k-uncorrelated weight function
  for the non-equilibrium contour
  
* I have leveraged the need for having the chemical potentials in 
  increasing order. They are now as the user has put them.

* Made sure that there was enough room for character retrieval 
  of fdf_? in various places (probably some more are missing)

* Removed the ID passing when setting up the equilibrium contour,
  it is already associated with the chemical potential that is passed.

* Bugfix for the angle calculation for the circle contour.

* Changed default non-equilibrium Eta to 0.00001 eV

* Made non-equilibrium weight function return the weight
  with a -i factor. This leverages the need to dublicate alot of routines.

* Reduced overhead in the expansion routine of elec_se, all integers
  are now explicitly set and not retrieved by the electrode type

* When used-Atoms < Atoms
  We had several bugs:
  - lasto was constructed erroneously
  - Rep(El) == 1 for the electrode the 
    self-energy passed was erroneous.

* Made the elec-reading implicit to read a lot of the information from
  the TSHS file. This has leveraged the need for a check_HSfile in the
  ts_options reading.
  Also a check of electrode Gamma calculation was using the TS-gamma 
  and not the SIESTA-gamma.

* Fixed calculating the Green's function:
  - in bias-part the number of used orbitals was counted wrong.
  - in part-calculation the identity matrix is now setup correctly

* Removed some references to TRANSIESTA_DEBUG. They cannot be used
  anymore.

* Moved all calc_forces references into the corresponding routines
  by checking if the spEDM array exists, if not we surely will
  not update the forces.

* Removed the add_Bias_DM, it is not needed

* Made a name change in ts_io from Gamma_SCF to Gamma_TS
  To be clear:
    Gamma => SIESTA Gamma calculation
    Gamma_TS => transiesta Gamma calculation

* Changed interface of ts_voltage to use full implicit shape 
  Vscf arrays instead of deferred Vscf passing.

* Cleaned the ts_init routine (still needs more attention)

added:
  Src/m_ts_fullk.F90
modified:
  Src/Makefile
  Src/compute_dm.F
  Src/dhscf.F
  Src/m_transiesta.F90
  Src/m_ts_chem_pot.f90
  Src/m_ts_contour_eq.f90
  Src/m_ts_contour_neq.f90
  Src/m_ts_dm_update.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_full_scat.F90
  Src/m_ts_fullg.F90
  Src/m_ts_io.F90
  Src/m_ts_io_ctype.f90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_voltage.F90
  Src/m_ts_weight.F90
  Src/ts_init.F90

----------------------------------------------------
December 15, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-98
Added proper coordinate checks of the electrodes

* Added check of the coordinates consistency in the system
  with regards to the electrodes.
  This has been generalized to all directions of the semi-infinite
  direction.
  
* Cleaned up a lot of the unused variables in several of the
  transiesta routines

modified:
  Src/Makefile
  Src/m_ts_contour_eq.f90
  Src/m_ts_contour_neq.f90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_gf.F90
  Src/m_ts_io_contour.f90
  Src/m_ts_io_ctype.f90
  Src/m_ts_options.F90
  Src/m_ts_weight.F90
  Src/ts_init.F90

----------------------------------------------------
December 13, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-97
Easy way to handle the different arrays, redid GF creation

* The handling of the electrodes are now fully conforming with the
  left/right 0-1/01 Hamiltonians. This generalizes a lot of the 
  routines.

* Renamed surface green function routines to incorporate the
  method used. 
  This might be useful when other methods are added.

* Added some final routines for the electrode type which eases 
  the handling of the electrodes.

* Can now successfully create the electrodes for all supplied
  electrodes
  Also:
   1) checking the electrodes matches the new out-put format
   2) reading in the header of the Green's function is also redone

modified:
  Src/Makefile
  Src/m_ts_cctype.f90
  Src/m_ts_contour.f90
  Src/m_ts_contour_eq.f90
  Src/m_ts_contour_neq.f90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_full.F90
  Src/m_ts_gf.F90
  Src/m_ts_options.F90
  Src/m_ts_tri.F90
  Src/ts_init.F90

----------------------------------------------------
December 12, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-96
Created a new contour method for input

* Preparing for multiple electrodes requires a new input method of 
  the contour methods. 
  Most importantly we can reduce the number of contour points on the 
  equilibrium contour.
  
* We do this by separating the equilibrium contour to the non-equilibrium
  and associate a weight for each of the electrodes.
  This is because the circle contour can now be allocated to all the electrodes
  if the appropriate edges are set correctly.

* I am not particularly proud of the complexity level of the contour 
  specification. However, I plan to generate a small shell script which 
  creates the contours for you. (just by specifying the different
  chemical potentials)
  
* Each of the electrodes now have a lot of options for specifying the 
  usage of that particular electrode.
  These options are now electrode specific:
    UseBulk
    Update cross-terms
    Calculate band-bottom

* Cleaned up in some of the files.
  The old gaussian weights are now discarded.

* NOTE this revision does not work!
  It is a work in progress.

added:
  Src/m_ts_contour_eq.f90
  Src/m_ts_contour_neq.f90
  Src/m_ts_io_ctype.f90
modified:
  Src/Makefile
  Src/dhscf.F
  Src/m_gauss_quad.f90
  Src/m_ts_aux.F90
  Src/m_ts_cctype.f90
  Src/m_ts_contour.f90
  Src/m_ts_electype.F90
  Src/m_ts_full.F90
  Src/m_ts_io_contour.f90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_tri.F90
  Src/m_ts_voltage.F90
  Src/state_init.F
  Src/ts_init.F90

----------------------------------------------------
October 11, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-95
Changed the ElLeft/ElRight to a generic electrode type

* Instead of using a separate electrode for left/right, we now employ
  a fully self-compliant electrode type which contains information about its
  implementation.
  I.e. they can be differentiated by UseBulk, UpdateDMCROnly, transport-direction
  etc.

* Reading in the electrode can now also be performed via the blocks:
  %block TS.Elec
    	Name1
	Name2
  %endblock

  %block TS.Elec.Name1
         <settings>
  %endblock
  %block TS.Elec.Name2
         <settings>
  %endblock

  This makes it a bit more consistent and leverages a lot of the 
  static read-ins.

* Instead of having static fields of the orbitals position in the 
  regions we now use a look-up table to decipher each orbitals type
  dynamically.

* Fixed coordinates of electrodes, we can now do a check of the electrodes
  in the options. (TODO)

modified:
  Src/Makefile
  Src/compute_dm.F
  Src/create_Sparsity_Union.F90
  Src/geom_helper.f90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_charge.F90
  Src/m_ts_contour.f90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_full.F90
  Src/m_ts_gf.F90
  Src/m_ts_io.F90
  Src/m_ts_method.f90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_tri.F90
  Src/m_ts_voltage.F90
  Src/siesta_forces.F
  Src/state_init.F
  Src/ts_init.F90
  Src/ts_show_regions.f90

----------------------------------------------------
October 11, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-94
Added a fdf_bboolean to read in booleans from blocks

* Simply added the fdf_bboolean.
  We note that it will be not the best thing to distinguish between
  labels and boolean values as they essentially are the same.
  Hence an fdf_bnboolean does not exist.

modified:
  Src/fdf/fdf.F90

----------------------------------------------------
October 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-93
Surface Green's functions are now fully created by the electrode type

* Made the type Elec fully compliant to contain all the information
  required to make the surface Green's function.
  This should leverage some space required to retain all information 
  about the electrode.

* Changed the name of the cell_xyz to cell_abc to not refrain the 
  programmer from interpreting as a direction in the Cartesian 
  coordiante system.

* Removed indxuo from the m_HS_matrix module.

* TODO we do not check the range of the electrode yet.
  We could do this by creating the sp02 sparsity pattern.

* Removed the calculation of the band-bottom eigenvalue.

* Speeded up the surface-GF creation by retaining the Hamiltonian
  and overlap separately.
  Should make it much faster for many E-points.

modified:
  Src/Makefile
  Src/create_Sparsity_SC.F90
  Src/geom_helper.f90
  Src/m_hs_matrix.f90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_full.F90
  Src/m_ts_gf.F90
  Src/m_ts_io.F90
  Src/m_ts_options.F90
  Src/m_ts_tri.F90
  Src/ts_init.F90

----------------------------------------------------
October 4, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-92
Made transport possible in any direction 

* Instead of forcing the user to use the A3-direction as the transport
  direction, the wanted direction can be be used.
  I have fully implemented this for repetition and anywhere needed in the code.
  I have tested this with the ts_au_100_repetition_0.25V test case and found
  a similar convergence. 

  A couple of routines has changed interface to account for the change in 
  behaviour.

  All in all this addition should make it easier to implement a future
  multi-terminal transiesta.

  The transport direction is defaulted to the regular scheme (a3-direction)
  and can be controlled via:
  TS.TransportDirection [1-3]

added:
  Src/m_ts_tdir.f90
modified:
  Docs/siesta.tex
  Src/m_integrate.f90
  Src/m_ts_contour.f90
  Src/m_ts_electrode.F90
  Src/m_ts_gf.F90
  Src/m_ts_kpoints.F90
  Src/m_ts_options.F90
  Src/ts_init.F90

----------------------------------------------------
September 17, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-91
Added coordinate check when dealing with bias, small changes to variables

* When applying a bias we do not allow the atomic coordinates to not be centered
  with respect to origo (in the z-direction).
  This is a "feature" of the Hartree potential which is placed in the unit-cell
  rather than according to atomic coordinates.
  This might have causes quite some frustration with users, and also caused some
  wrong simulations.

* Re-indented the transiesta k-point module

* Added different titles for left/right GF file
  And cleaned output of different electrodes

* Renamed new flag: TS.Voltage.Position to the more meaningful
  TS.HartreePotential.Position

modified:
  Src/m_integrate.f90
  Src/m_ts_contour.f90
  Src/m_ts_electrode.F90
  Src/m_ts_gf.F90
  Src/m_ts_kpoints.F90
  Src/m_ts_options.F90
  Src/ts_init.F90

----------------------------------------------------
August 23, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-90
Bugfix for warning about parallel optimal energy points

* The number of poles was not included when warning against optimal
  energy points

modified:
  Src/m_ts_io_contour.f90
  Src/m_ts_options.F90

----------------------------------------------------
August 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-89
Bugfix for reverse GF reading. Added methods of bandwidth reduction

* The Green's function reading was buggy in case on non divisable by 
  number of processors. This has been corrected.

* Instead of the reverse Cuthill-Mckee algorithm we have added 2 more
  algorithms for reducing the bandwidth of the matrix.

  We now have:
   - Cuthill-Mckee
   - reverse Cuthill-Mckee
   - Cuthill-Mckee with z-priority
   - reverse Cuthill-Mckee with z-priority
   - Papior
   - reverse Papior

  The Cuthill-Mckee with z-priority and the Papior
  algorithms are not stable. 
  Consecutive usage of these bandwidth reductions gives new sortings.
  However, I have seen occasions were they where outperforming the 
  Cuthill-Mckee algorithm.
  As such they are merely there for testing purposes.

  The Papior algorithm was intuitively customized by Nick Papior Andersen,
  and proves to be best after an initial Cuthill-Mckee pass.

added:
  Src/m_bandwidth.f90
modified:
  Src/Makefile
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/state_init.F

----------------------------------------------------
August 13, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-88
Added MPI_PACKED in MPI, speeded up GS creation, TSHS-read improvement, bugfixes

* In order to go to more advanced MPI routines I have added the MPI_PACKED variable
  which is added since OpenMPI 1.4.5 (as far as I can tell).
  If the user uses a legacy MPI version, one should add the flag: -DMPI_OLD.
  I have added a small remark about this in the manual.

* Surface Green's function creation has recieved an overhaul. It is now faster and uses
  roughly half the memory. This is mostly so that we will be able to do in-line
  GF calculations to skip the huge GF files.
  
  The routines are split in two versions, one which calculates the DOS and one
  only calculates the required surface Green's function.

* When having no repetitions there was no need to invert the surface Green's function.
  (this was needed to do a Bloch expansion)
  The surface Green's function is saved "as is" when having NRepA1 == NRepA2 == 1.
  This should speed up the execution of large electrodes by quite a bit.
  This also makes it far more convincing to do full electrodes as they are faster.

* Bugfixes in the mat_invert module.
  Now the user can request the return value of the lapack calls without it
  crashing.

* The electrode type now has both the Fermi-level and the unit-cell attached.
  This should come in handy when transfering to inline GF computations.

* ts_read_TSHS has gotten a new routine ts_read_TSHS_opt
  which reads in the requested values (if supplied through the optional
  arguments).
  Currently the interface is this:
    ts_read_TSHS_opt(TSHS,DUMMY,na_u,no_u,no_s,nspin,maxnh, &
         xa,isa,ucell, Qtot, Temp, Ef, &
         Gamma,Gamma_SCF,OnlyS,lasto, &
         Bcast)
  where everything beyond DUMMY should be referenced by explicit names.
  Also Bcast is attached so that the routine will automatically broad
  cast the values to all nodes (using the MPI_PACKED format)

  Thus the older versions which explicitly dealt with one read-in has been 
  made obsolete and deleted.

* Name changes of a few routines
  filename_TSHS is too long, fname_TSHS is the new name.
  In general I think that using fname is a good choice with the needed 
  verbosity for the coder.

* Bugfixes for doing electrode calculations.
  The contours was checked even though they were never used.
  This has been corrected, TODO this still needs a clean-up.

modified:
  Docs/siesta.tex
  Src/MPI/mpi__include.f90
  Src/MPI/mpi_siesta.f90
  Src/final_H_f_stress.F
  Src/Makefile
  Src/m_mat_invert.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_electype.F90
  Src/m_ts_full.F90
  Src/m_ts_io.F90
  Src/m_ts_io_contour.f90
  Src/m_ts_options.F90
  Src/m_ts_tri.F90
  Src/state_init.F

----------------------------------------------------
August 11, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-87
Fixed NoEmptyCycles and reversed GF-reading

* The GF reading is now performed backwards, i.e. the ROOT
  node is the last to receive the energy-point.
  This should in cases of uneven energy-points be a little bit
  faster.

  Implemented this in full and tri.

* Added another test to check that the integrals are connected, 
  i.e. that \int_a^b+\int_c^d ... and b == c.

* FixSpin is now allowed is saveTSHS is false.
  This will allow for easier full implementation of transiesta
  and siesta.

* When transiesta automatically corrects the number of used
  energy-points, it now distributes them among all the allowed
  contours according to each of the segments. (not Gauss-Fermi
  contours).

modified:
  Src/m_ts_contour.f90
  Src/m_ts_elec_se.F90
  Src/m_ts_full.F90
  Src/m_ts_io_contour.f90
  Src/m_ts_options.F90
  Src/m_ts_tri.F90

----------------------------------------------------
August 10, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-86
Added monitoring of DM-updating for transiesta

* Added a general monitor module which enables one
  to read in a block
    %block <block-name
      <orbital 1> <optional orbital 1>
      <orbital 2> <optional orbital 2>
      ...
      <orbital n> <optional orbital n>
    %endblock
  will monitor the orbitals and if the second orbital is present
  it will monitor the cross term of the orbitals.
  If not present it will be an onsite monitor.

* In order to figure out how the integral is behaving I have added 
  a method to show the contribution from each contour point.
  A general block can be read by transiesta which prints out in
  files how the density matrix elements are updated.

  We use the monitor module to read block TS.DM.Monitor
  
  It will be printed in files named:
     <system label>.TSMON{L,R,LN,RN}_<orbital>_<optional orbital>
  and it will print out the energies (both real and imaginary part)
  and the DM contribution for that energy. In effect one can plot
  the density contribution for each contour point and enables one
  to figure out where the "most important" part of the contour is.
  Especially this should be useful for the non-equilibrium contour 
  at high bias.

  Currently the monitor feature is only possible in the tri-solver.
  It is expected to be negliegeble in computation time and memory
  consumption.  

* A faster short look-up for the sparsity patterns has been enabled:

    val(<data>,<idx>)

  returns the value in the sparsity matrix in the corresponding index.
  Enabled for Data[12]D and SpData[12]D.

* Fast creation of filenames is made possible in the spin module 
   fname_spin
  is a general routine for generating filenames with suffix 
  and will attach appropriate spin labels.

* Print-out improvements for the transiesta contour.

added:
  Src/m_monitor.F90
modified:
  Src/Makefile
  Src/class_Data1D.T90
  Src/class_Data2D.T90
  Src/class_SpData1D.T90
  Src/class_SpData2D.T90
  Src/compute_dm.F
  Src/m_spin.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_io_contour.f90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_tri.F90
  Src/m_ts_weight.F90
  Src/state_init.F

----------------------------------------------------
August 2, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-85
Full customisable contour segment FDF keys, streamlining for the tanh-sinh algorithm

* The Tanh-Sinh quadrature has been optimized, the calculation of the weights could
  lead to problems in certain cases.

* The contour types has been revised so that one can from an input-string get
  the type and vice versa.
  - type2input
  - input2type

* Added a new module which sole purpose is to read in the contour information
  for the complex and non-equilibrium contours for transiesta.
  It enables one to use a block which can consist of as many contour segments
  as one wish.
  This block has precedence over all other options for the contour.

  A typical example is this:
     %block TS.Contour.Eq
      # First item is ALWAYS the circle part of the contour
       - 3. Ry to - 8. kT with
          points 24 using
             method Tanh-Sinh

      # Last item is ALWAYS the tail part of the line contour
       prev to inf with
          points 6 using
             method g-fermi
     %endblock TS.Contour.Eq

  (in principle can the lines be interchanged at will)

  The bias contour should "always" be given from -inf -- inf
  hence, the sign of V means nothing in this regard.

  It will always print out how it interprets the block so that any
  discrepancies found will be eliminated.
  Hence the procedure should be:
   1) Build contour
   2) run transiesta, stop immediately
   3) copy contour blocks into the FDF files
   4) continue run

  The main advantage is that it can be used to increase points in specific energy
  ranges so that a better convergence will be acheived.

  Another advantage is that one can easily alter the position of the contours from
  an already existing block.

  It is to be considered an expert-feature and its usage lies mainly in the high-bias
  regions.

* Currently the Gauss-Fermi quadrature is only allowed

* Added check of the poles placement to the complex plane energy shift.
  If a pole is very close to a pole (within 10 Kelvin) it will print a notice.
  However, it will not stop. So any users should notice the output from transiesta.

* transiesta options are now printed a bit more stringent.

* FixSpin is now not allowed to be run using the transiesta executable.
  The electrodes can not be created with FixSpin either.

added:
  Src/m_ts_io_contour.f90
modified:
  Src/Makefile
  Src/m_gauss_quad.f90
  Src/m_ts_cctype.f90
  Src/m_ts_contour.f90
  Src/m_ts_options.F90
  Src/ts_init.F90

----------------------------------------------------
July 29, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-84
Error estimate now shows DM_out and delta left/right non-equi

* The print-out of the error estimates is now directly related to the
  density matrix element. 
  Thus the difference between the left/right integral is printed
  together with the out-put density matrix element.
  I.e. something like this:
  ts: int. EE.: DM_out(  766,  595) = 0.21450    , d_LR|(  766,  595)| = 0.44764E-4
  which tells that the difference between left/right (DM_L - DM_R) is
  4 orders of magnitude smaller than the DM output.

* Changed some FDF-flags which still needs to be documented.

* TODO consider adding a flag to disable the calculation of the EDM matrix
  in transiesta.
  This will also enable the calculation of the DM by immediately going to
  transiesta.

modified:
  Docs/siesta.tex
  Src/m_ts_options.F90
  Src/m_ts_weight.F90

----------------------------------------------------
July 29, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-83
Added a proper iEta for the equilibrium contour, FixSpin check bugfix

* The equilibrium contour was not performed at an eta value. 
  Now the user can specify the shift into the complex plane by:
  TS.Contour.Eq.Eta
  which will shift the circle contour into the complex plane.
  Note that the line-contour is well defined by the highest pole position.
  In case the Eta is larger than the smallest pole position the
  integral will not take into account the poles below the Eta shift.
  And thus the poles will be shifted to the higher poles for consistency.

  It is defaulted to 0.0 which is the same as the original implementation.

* A FixSpin check was performed outside the TSmode if-statement which
  was wrong. (an electrode can have fixed spin)

modified:
  Src/m_ts_contour.f90
  Src/m_ts_options.F90

----------------------------------------------------
July 18, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-82
Ensured correct bias Hamiltonian for first transiesta iteration

* The Hamiltonian was not setup with the potential added for the first
  iteration.
  This has now been correctd by calling setup_hamiltonian after
  mixing.

* Changed the default weight for the non-equilibrium transiesta
  to the correlated.

modified:
  Src/m_ts_options.F90
  Src/siesta_forces.F

----------------------------------------------------
July 17, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-81
Changed the Gauss-Fermi contours only up to 17 points

* Removed points 18-20 in the Gauss-Fermi quadratures.
  We could not acknowlegde their precision.

* Added more tail ending integrations:
   from 20 to 30 in steps of 2kT
   and 17, 18 and 19 kT
  This should provide more than enough selection for the user
  to control the integral.

removed:
  Src/m_gauss_fermi.f90
  Src/m_gauss_fermi_16.f90
added:
  Src/m_gauss_fermi_17.f90
  Src/m_gauss_fermi_19.f90
  Src/m_gauss_fermi_22.f90
  Src/m_gauss_fermi_24.f90
  Src/m_gauss_fermi_26.f90
  Src/m_gauss_fermi_28.f90
  Src/m_gauss_fermi_30.f90
  Src/m_gauss_fermi_inf.f90
modified:
  Src/Makefile
  Src/m_gauss_fermi_18.f90
  Src/m_gauss_fermi_20.f90
  Src/m_ts_cctype.f90
  Src/m_ts_contour.f90

----------------------------------------------------
July 17, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-80
Changed to the reverse Cuthill-Mckee algorithm and added block printout

* The Cuthill-Mckee algorithm has been changed to the reverse method.
  It provides a better bandwidth minimization as also noted by several
  papers.
  
* Added a flag for the analyzation script to also print out the
  FDF block designators. By this the user can easily create a
  proper FDF file from just piping:
  tsanalyzesort.py -s STRUCT.fdf -A RUNTS.out -b > new_struct.fdf

modified:
  Src/m_ts_sparse.F90
  Util/TSAnalyzeSort/tsanalyzesort.py

----------------------------------------------------
July 17, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-79
The Cuthill-Mckee algorithm should not print out for the electrodes, added script for pivoting

* Added a python script which requires two inputs:
   1) FDF which contains the block AtomicCoordinatesAndAtomicSpecies
   2) Out file of a transiesta run with TS.Analyze set to true.
  It will then print out (to stdout) the optimized structure for the
  smallest BTD block sizes.

  It is implementing a slightly modified Cuthill-Mckee algorithm with
  the starting parent as the last electrode atom. Hence one could optimize
  the electrodes first, and then the central region. But often the electrodes
  are fixed due to the electrode run.

  I have not tested this algorithm with an unconnected tree.

  The script can be found in TSAnalyzeSort and should be runned like this:
  tsanalyzesort.py -s STRUCT.fdf -A RUNTS.out
  or more verbose:
  tsanalyzesort.py --struct STRUCT.fdf --analyze RUNTS.out

  It will quit if it sees an obscure pivoting. In this case it returns with
  return value 1 instead of 0
  Notice that it does not alter the lines in anyway. Hence, comments etc. should
  be retained.

added:
  Util/TSAnalyzeSort/
  Util/TSAnalyzeSort/tsanalyzesort.py
modified:
  Src/m_ts_sparse.F90
  Src/state_init.F

----------------------------------------------------
July 16, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-78
Added the Cuthill-Mckee algorithm to optimize the BTD pattern

* The Cuthill-Mckee algorithm has been implemented to 
  optimize the tri-diagonal format for minimizing the 
  bandwidth of the matrix to be inverted.
  In case of TS.Analyze T it will be runned and it
  prints out the pivoting of the arrays:
  Like this:
    From  ->    To
      41  ->    37
      42  ->    38
      44  ->    39
    ...

  Notice that every number has to appear once on both sides.
  If not it will be erroneous.
  Furthermore notice that both indices are in the original
  index and thus not a consecutive pivoting array.

  For completeness sake it prints out the index change
  for the left, central and the right part.

modified:
  Src/Makefile
  Src/m_ts_sparse.F90
  Src/state_init.F

----------------------------------------------------
July 14, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-77
Bugfix for the error on the electrode positions

* An MPI_Barrier was obstructing the die call

modified:
  Src/m_ts_electrode.f90

----------------------------------------------------
July 14, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-76
Added a Tanh-Sinh quadrature method which excells in the circle contour

* A Tanh-Sinh quadrature method has been implemented which also deals
  with w(x)=1 and thus is good for the circle contour.
  It can be used for the line integrals (Eq. and nEq.) and the 
  circle method.

modified:
  Src/m_gauss_quad.f90
  Src/m_ts_cctype.f90
  Src/m_ts_contour.f90

----------------------------------------------------
July 12, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-75
Made the matrix inversion generic and removed unneeded integration schemes

* A generic matrix inverter is used for inverting matrices. Currently it has
  3 options:
   1) Invert in-place using lapack (getrf -> getri)
   2) Invert to work using lapack (gesv)
   3) Invert using the recursive algorithm

* As I did not risk any singular sub-matrices of the Hamiltonian the recursive
  algorithm is not used anywhere.

* Cleaned up in the available contour integration methods.
  We will not allow a Chebyshev algorithm as that is not nearly as precise due to
  weight contributions not reflecting the structure of the weight function properly.

* Added the transiesta mixing change when reading in from TSDE

* Removed obsolete csolve routines from m_ts_aux

* Changed the default composite line integral to Simpsons rules. Basically because
  these impose a lower degree polynomial and if the derivative of the product explodes
  the Simpson rules are more precise.
  If one expects a rapidly osciallating function in the interval the mid-rule could
  be preferred with high density of points.

* Changed the logic from switching from diagon to transiesta.
  We now do this:

    1. Do a final mix according to a regular continuation
    2. Change mixing parameters
    3. Initialize the pulay mixers
    4. Continue transiesta cycle

  Thus the density matrix and Hamiltonian will be the next mixed set of matrices.
  This meant a slight change in the transiesta switch check.

* Corrected a small write-out for the scf info in write_subs

modified:
  Src/Makefile
  Src/m_mat_invert.F90
  Src/m_new_dm.F90
  Src/m_trimat_invert.F90
  Src/m_ts_aux.F90
  Src/m_ts_contour.f90
  Src/m_ts_trimat_invert.F90
  Src/siesta_forces.F
  Src/write_subs.F

----------------------------------------------------
July 11, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-74
Added an inverter which speeds up the direct inversion a little

* A recursive algorithm for inverting a matrix has been built in, it
  takes a matrix, partitions it into 3-diagonal and calculates the
  inverse, then reconstructing the full inverted matrix afterwards.
  It has a hard-coded size limit of 40 so that for matrices smaller
  than this number it will use zgesv.
  It is used in the inversion of the tri-diagonal parts.
  As it is only used to invert the diagonal matrices
  it should not come near any singular valued matrices.

added:
  Src/m_mat_invert.F90
modified:
  Src/Makefile
  Src/m_trimat_invert.F90
  Src/m_ts_tri.F90
  Src/m_ts_trimat_invert.F90

----------------------------------------------------
July 10, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-73
Optimized GF.G.GF product and the expansion of the electrodes

* Made the electrode repetition a bit faster by pre-calculating 
  the qb * Pi 

* Fully implemented a stand-alone version of the full column inversion
  has been made. 
  It does not do too many calculations and speeds up the calculation
  by quite a bit when the second partition is much larger than necessary.

* Cleaned code in m_ts_tri and removed a little dead code

modified:
  Src/Makefile
  Src/m_trimat_invert.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_trimat_invert.F90

----------------------------------------------------
July 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-72
Improved logic in contour creation and added transiesta weight

* Via TS.MixingWeight the user can specify a specific weight for the DM when
  switching to the transiesta SCF.
  When the transiesta cycles starts it switches the weights in the two variables
  to be able to switch back (if needed). Currently it does not switch back
  to the siesta mixing weight as that should not be required.
  
* Added more print-outs for the transiesta options.

* Fixed the transiesta turn-over point.
  The logic is now:
  1) Diagon
  2) when SCFConverged, we do:
  2a) Reset pulay, 
  2b) change mixing weight,
  2c) reset SCF counters
  3) Reset Dold/Hold to the current Dscf/H to have no impact on the 
     old SIESTA cycles.
  4) start transiesta cycle.

  The previous implementation also did mixing which didn't seem right
  So this logic is more straight forward and should correspond to the correct
  methodology.

* Removed unnecessary orb-write out when switching to transiesta cycle.

* Corrected some minor indention lines

* LAST COMMIT WAS FAULTY (I have no idea how to revert and backtrack :) )

modified:modified:
  Src/compute_dm.F
  Src/m_ts_contour.f90
  Src/mixer.F
  Src/siesta_forces.F
  Src/write_subs.F

----------------------------------------------------
July 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-70
Bugfix for equilibrium transiesta weights

* Forgot to add a minus sign for the weights of the equilibrium contour in cases of
  V == 0.

modified:
  Src/m_ts_contour.f90

----------------------------------------------------
July 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-69
Added a general flag instead of TS.biasContour.NumPoints and removed unneeded logics

* Instead of both specifying TS.Contour.nEq.<Middle|Tail>.N one can use
  TS.Contour.nEq.N which determines both the tail and middle number of points
  automatically using the Gauss-Fermi tool.

* Removed the composite trapez rule (it weren't implemented)

modified:
  Src/m_ts_cctype.f90
  Src/m_ts_contour.f90

----------------------------------------------------
July 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-68
Generalized the composite Simpson and Boole's Newton-Cotes integration schemes

* The Simpson rule has been completely changed to a composite rule.
  This should increase the precision more than the quadrature rules as it retains
  the equi-distant points.
  At least it seems better suited for use than the Gaussian quadrature which does 
  expect a polynomial.

  We have changed the default to the Boole's method which is a 5-point Newton-Cotes
  integration scheme. For the end-points it chooses the Simpson 3/8 or 3 rules for ensuring 
  that it can be used for every N.

  The Simpson rule can still be selected for usage and is a composite rule with the 3/8 and 
  the 3-point rule. They behave more or less the same. (conceptually the 3/8-3 rule is easier
  to understand as the end-points are more easily defined.)
  
  We have taken advantage of the 3/8 and 3 point rule's error terms to select the best splitting
  between these two by automatic error-term optimization. Hence the 3/8-3 rule is 
  optimal for having the same error-term across the entire integration interval.
  
  The Boole's methods error-term is not directly related to the Simpson methods, hence
  we choose an empirical value for splitting the intervals, here hard-coded to be 3/5.
  This seems like a reasonable value.

* Removed the old different Simpson rules as the 3/8 should perform better, and is more
  stable.
  In case one wants a more rigid estimate, one can always revert to the mid-rule which
  does not impose any polynomial expansion.
  

added:
  Src/m_integrate.f90
modified:
  Src/Makefile
  Src/m_ts_cctype.f90
  Src/m_ts_contour.f90

----------------------------------------------------
July 4, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-67
Removed Tschebyscheff quadrature, added Gauss-Fermi with non-inf

* As the Fermi function rapidly decays for energies above 10kT
  it makes sense to generate the quadrature for the range [x;20kT]
  or some other figure of that magnitude.
  This will concentrate more abscissae at the bottom range and
  should increase the precision of the computation.
  Specifically Fermi function (20kT) ~= 1e-9 which roughly means
  no contribution in the density.
  Thus the user now has the possibility of switching Gauss-Fermi
  with the following upper bounds for the integral:
    1)  infinity (default behaviour)
    2)  20 kT
    3)  18 kT
    4)  16 kT
  
* Deleted the Tschebyscheff quadrature, it generated the same 
  abscissae as the Chebyshev, I suspect it is a naming thing.

* Corrected the weight scaling for the Chebyshev methods.

added:
  Src/m_gauss_fermi_16.f90
  Src/m_gauss_fermi_18.f90
  Src/m_gauss_fermi_20.f90
modified:
  Src/Makefile
  Src/m_gauss_quad.f90
  Src/m_ts_cctype.f90
  Src/m_ts_contour.f90

----------------------------------------------------
July 4, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-66
Bugfixes for nearly all the Gauss quadratures. Added full Gauss-Fermi up to 20 points

* m_gauss_quad have recieved some updates, I still suspect this module to contain some
  minor errors. However, for now the quadratures seem to generate the expected.
  Quite a few bug-fixes for the quadrature generation has been added.
  Particularly with different bounds

* Using Stieltjes and Golub-Welsch method we have retrieved the Gauss-Fermi quadrature point
  from -20kT up to 5kT, each with [2;20] points.
  This will allow a greater flexibility in the determination of the optimal Gauss-Fermi quadrature.
  Added an algorithm to automatically calculate the number of points used for the integrals.
  Specifically it determines the optimal number of tail integral points by estimating the
  weight in the middle segment compared to that of the tail integral.
  For high biases this will lead to few tail points and many middle segment points, and vice versa.


* TODO I suspect quite some "features" when mixing different contour methods.
  There are some things that should be more clear in the code.
  For intsance mixing Gauss-Fermi and line-integrals are a pain in the neck but proves
  quite useful.

* Changed the way one deals with the Gauss-Fermi contour elements.
  It is not too obvious for the user what which options meen, however, the 
  options print-out is what it uses. So anything that is corrected in the
  code is reflected in the out-put.

* Generalized the contour creation routines, the equilibrium contour and the
  non-equilibrium contour are now created separately and both can utilize a new
  line_integral method which allows for creating different integration methods 
  irrespective of the nature of the integral.

* The reading of the contour options have moved to the m_ts_contour module for
  better clarity and also the constants belong to this module.

  It should make the partition clearer and the programmer knows exactly where each
  variable belongs.

* TODO run a test-suite of the contour methods out-put to ensure their compatibility with
  the old method.

* Fixed the TSiscf count and made it like this:

  1) TSiscf is set to 1 when the transiesta cycle kicks in
     This is necessary as that is later used in the mixing and should thus have value 1+
     and not 0.
  2) iscf is now a mirror of TSiscf when transiesta is running
  3) At the loop when transiesta kicks in, iscf and TSiscf are not updated, otherwise
     it would be incremented to 2, which is not the correct thing.
     I had to do it like this because of the non-triviality of the mixing scheme and the
     counters that is used to track how mixing should be performed.

* Instead of reading in the temperature in the transiesta options it is now passed down
  through the subroutines.
  Thus any default change in the temperature is also reflected in the transiesta routine.

added:
  Src/m_gauss_fermi.f90
modified:
  Src/Makefile
  Src/compute_dm.F
  Src/m_gauss_quad.f90
  Src/m_ts_aux.F90
  Src/m_ts_cctype.f90
  Src/m_ts_contour.f90
  Src/m_ts_full.F90
  Src/m_ts_global_vars.f90
  Src/m_ts_options.F90
  Src/m_ts_tri.F90
  Src/siesta_forces.F
  Src/siesta_init.F
  Src/ts_init.F90

----------------------------------------------------
July 1, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-65
Clean-up in m_ts_contour, added Gauss-Chebyshev and general gauss-integration module

* Added m_gauss_quad which enables to generate gauss-quadrature points and weights for
  the following methods:
    1) Gauss-Legendre (Jacobi)
       Used for \int_a^b f(x)w(x)dx , w(x) = 1
    2) Gauss-Gegenbauer (Jacobi)
       Used for \int_a^b f(x)w(x)dx , w(x) = (1-x^2)^{\lambda-1/2}
    3) Gauss-Jacobi (Jacobi)
       Used for \int_a^b f(x)w(x)dx , w(x) = (1-x)^\alpha (1+x)^\beta
    4) Gauss-Chebyshev (Jacobi)
       Usef for \int_a^b f(x)w(x)dx , w(x) = \frac1{\sqrt{1-x^2}}
    5) Gauss-Laguerre (Laguerre)
       Usef for \int_a^\infty f(x)w(x)dx , w(x) = e^{-x}
    6) Gauss-Generalized-Laguerre (Laguerre)
       Usef for \int_a^\infty f(x)w(x)dx , w(x) = x^\alpha e^{-x}
    7) Gauss-Hermite
       Usef for \int_{-\infty}^\infty f(x)w(x)dx , w(x) = e^{-x^2}
  I have checked the majority of the routines for the simplest cases and for
  N upto 10.
  It is very general and can be used for any integration scheme.
  For all but the Legendre method an optional argument "pure" is available.
  If pure == .true. we have the weight function in the function description,
  otherwise we multiply by 1 = w(x)/w(x) to enable the use of the method.
  Hence, it is not a "pure" weight.

  For those methods applicable one can shift the boundaries by supplying 
  "a" and "b", or only "a".

* Generalization of the keys for transiesta to be more meaningful.
  
  Anything that has to do with the contour integral, we have done

  TS.Contour.<nEq|Eq>
  
  For Eq we have:
    Circle.<N|Method>
    Line.<N>
    Pole.<N>
  method for the Line will follow in a later commit.
  For nEq we have:
    Line.<N|Tail|Middle>
  where for Tail and Middle we have:
    N
  Hence the read-in of the options are more readable and concise.
  The idea is that we can easily extend the option in this way.

  In general I have substituted by these options:

    TS.ComplexContourEmin  ->  TS.Contour.Eq.Emin
    TS.biasContour.Eta  ->  TS.Contour.nEq.Eta
    TS.ComplexContour.NPoles  ->  TS.Contour.Eq.Pole.N
    TS.ComplexContour.NCircle  ->  TS.Contour.Eq.Circle.N
    TS.ComplexContour.NLine  ->  TS.Contour.Eq.Line.N
    TS.biasContour.NumPoints  ->  TS.Contour.nEq.N
    TS.biasContour.method  ->   TS.Contour.nEq.Method
    TS.HSFileLeft  ->  TS.Elec.Left.TSHS
    TS.NumUsedAtomsLeft  ->  TS.Elec.Left.UsedAtoms
    TS.ReplicateA1Left  ->  TS.Elec.Left.Replicate.A1
    TS.ReplicateA2Left  ->  TS.Elec.Left.Replicate.A2

  however, backwards compatibility is fully maintained.
  One can also fine-tune the number of points in the tails of the non-equilibrium contour:
    TS.Contour.nEq.Tail.N
    TS.Contour.nEq.Middle.N

* Added flag TS.Analyze which will immediately create the TSCC file and also do
  a tri-matrix partition. Hence, one can try both the speed and mem optimization
  routine for partitioning the system.
  The analyzation will stop after having partitioned the system and is thus, only
  an analyzation tool.

* Non-equilibrium contour integration for transiesta has been improved to be 
  able to handle different schemes.

  Currently there is still only the same tail integration, but several new
  schemes for the line in between.
  The general idea is to do:
    TS.Contour.nEq.Method <tail method>[+<middle method]

  hence:
    TS.Contour.nEq.Method g-fermi+extended-simpson
  will use the Gauss-Fermi quadrature on the tails and the extended
  Simpson method in between the tails.
  
  We have added the use of any of these middle methods:

  1) extended-simpson
  2) composite-simpson
  3) mid-rule
  4) g-legendre
  5) g-chebyshev-open

  For the tails we have the following methods:
  1) g-fermi
  2) sommerfeld

  Later we will fully implement the Legendre and the Laguerre methods.

* A new default option is chosen so that there are no "empty" parallel cycles.
  Hence it will automatically optimize the number of energy-points so no processors
  are doing nothing in the transiesta loops.

  To disable this one can do:

  TS.Contour.<nEq|Eq>.NoEmpyCycles F
  
* Should have fixed a case of electrode density spill of electrons. Now the charges should
  strictly be fixed in the electrodes TODO, needs to be checked.

added:
  Src/m_gauss_quad.f90
modified:
  Src/Makefile
  Src/m_ts_aux.F90
  Src/m_ts_cctype.f90
  Src/m_ts_contour.f90
  Src/m_ts_options.F90
  Src/siesta_forces.F
  Src/state_init.F
  Src/ts_init.F90

----------------------------------------------------
June 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-64
Small bugfix in sparse 2 tri-matrix occured when buffer atoms apparent

* When having buffer atoms the tri-matrix creation was incorrect. 
  This seems to have been corrected.
  Still need full proof.

modified:
  Src/m_ts_Sparsity2TriMat.F90

----------------------------------------------------
June 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-63
Comment indentation and bugfix in imperfect processor scaling

* Comments in m_ts_contour has been indented

* When number of processors was not divisable by the number of processors
  we had also incremented the number of line points. 
  However, the current implementation uses Gauss for the line-points
  which for many processors could lead to incorrect number of energy-points.
  Now excess integration points are attributed the circle contour as that
  is independent on the Gauss-Fermi quadrature

modified:
  Src/m_ts_contour.F90
  Src/m_ts_options.F90

----------------------------------------------------
June 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-62
Bugfix for deprecated flag and IsVolt flag

modified:
  Src/m_ts_contour.F90
  Src/m_ts_options.F90

----------------------------------------------------
June 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-61
Forgot to include the IsVolt in the use statement

modified:
  Src/m_ts_tri.F90

----------------------------------------------------
June 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-60
Bugfix in size checks of the transiesta initialization

* The tri-diagonal had special requirements when only using the 3-tri
  This is now correctly checked.

modified:
  Src/m_ts_tri.F90
  Src/ts_init.F90

----------------------------------------------------
June 20, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-59
Added last transiesta feature, triple matrix product GfGGf uses TriMat

* Added optional argument to the EYE function
  to specify the value in the diagonal

* When debugging it would not write out the correct sparsity pattern
  if it was empty.

* Added a write-out of the energies when the TSGF files does not match
  the internal energy of transiesta

* Added the matrix product for arbitrary tri-matrices.
  This means that we do extra computations as it is very unlikely that the full
  column of both the left and right side will be enough.
  Hence we need to re-read the non-equilibrium energies.
  This is accomblished by a flag to the TSGF read routine.
  This will be a slower computation when dealing with few parts (i.e. ~4-5)
  but for more parts it will be faster as the amount of double-computation
  will be quite limited.
  
* Fully removed the GF_INV_EQUI_PART variable, the same information about
  the computation is in UpdateDMCR.
  The UpdateDMCR is automatically corrected when the user asks for
  UseBulk = .false.

* When debugging will the code also write out the GfGGf product 
  as well as the Gf for the left/right-column.

* Fixed comments in the m_ts_tri_scat module.

* Fully removed all tri_Vparts references. 
  Now the tri-mat routine uses the "old" trimat implementation when
  parts(GF) == 3 and the new one when parts(GF) > 3

added:
  Src/m_ts_trimat_invert.F90
modified:
  Src/Makefile
  Src/intrinsic_missing.f90
  Src/m_ts_debug.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_full.F90
  Src/m_ts_full_scat.F90
  Src/m_ts_method.f90
  Src/m_ts_options.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
  Src/ts_init.F90

----------------------------------------------------
June 18, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-58
Bugfix for logic behind Green's function calculations

* When the options UpdateDMCROnly and UseBulk was used the logic
  was not what was happening. 
  This has now been fixed.
  Consequently the computations when not requiring the full
  Gf is reduced.

* Added remarks for the tri-mat code

modified:
  Src/m_trimat_invert.F90
  Src/m_ts_full.F90
  Src/m_ts_full_scat.F90
  Src/m_ts_options.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90

----------------------------------------------------
June 18, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-57
Added small awk script when the electrode does not conform

* Lets the user do copy paste and then paste the repeated out
  electrode positions directly into the FDF

* Code clean-up

modified:
  Src/m_ts_electrode.F90

----------------------------------------------------
June 17, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-56
Added a full transiesta debug code segment for displaying GF matrices

* In order to debug the application it was necessary to write out the 
  GF, GF^-1, SigmaL and SigmaR arrays.
  Instead of doing it locally it will be added to the code and only 
  compiled through the flag: -DTRANSIESTA_DEBUG
  It will run BOTH the full inversion algorithm and the tri-diagonal
  algorithm and a multitude of files will be created.
  This will allow to debug the inversion algorithm and scour through
  the matrices
  It has been found that the accuracy of the block-tridiagonal inversion
  is on the order of 1e-13 which is more than expected (tested for
  system of 1000 orbitals).
  (Possibly this will be a little lower for very large systems.)

* Cleaned up some code

* Removed the need for a Gamma variable in the electrode
  We ensure that the electrode calculation is not
  a Gamma calculation anyway.
  
* Ensured intent(inout) a couple of places where the same
  array is actually used.
  It should not matter, but to lessen the confusion.

* Bugfix in display of supercell connections when erroring
  on the electrode z-direction.

modified:
  Src/Makefile
  Src/class_TriMat.T90
  Src/compute_dm.F
  Src/m_trimat_invert.F90
  Src/m_ts_debug.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_full.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90

----------------------------------------------------
June 14, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-55
Bugfixes in debug module

* Trimat write out was wrong

modified:
  Src/m_ts_debug.F90

----------------------------------------------------
June 14, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-54
Added debug module for transiesta, when debugging GF is written out

* When debugging (-DTRANSIESTA_DEBUG) the full GF will be written out
  for all energy-points for the first SCF iteration.
  This will enable one to debug several things.

* Moved an sp_to_file routine to the module as well

* Debug files are created with an explanation of their content
  in the out file
  Typically they are added the node index so that every node 
  writes out something.

added:
  Src/m_ts_debug.F90
modified:
  Src/Makefile
  Src/create_Sparsity_SC.F90
  Src/create_Sparsity_Union.F90
  Src/m_ts_full.F90
  Src/m_ts_sparse.F90
  Src/m_ts_tri.F90

----------------------------------------------------
June 14, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-53
Bugfix for non-UC sparsity pattern

* For gamma-calculations the density was incorrectly updated.

* Deleted unused file m_ts_sparse_helper_new.F90

removed:
  Src/m_ts_sparse_helper_new.F90
modified:
  Src/Makefile
  Src/m_ts_dm_update.F90
  Src/m_ts_full.F90
  Src/m_ts_tri.F90

----------------------------------------------------
June 13, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-52
Made a new fdf flag to control the precision of the electrodes position

* When dealing with repetition one can encounter small discrepancies
  with the electrode coordinates.
  
  We have added a flag:
    TS.Electrode.Coord.Eps
  with a length which specifies the accuracy of the electrode 
  positioning that is required.
  The default precision is 1e-4 Bohr, which seems reasonable.

  This should ONLY be used if one is sure that the electrodes are
  positioned correctly.

* Added write-out of the exact number of unit-cells connections for
  the electrodes.

* Added write-out of the maximum Hamiltoninan element when the
  electrode has too long connections.

modified:
  Src/m_ts_electrode.F90
  Src/m_ts_gf.F90
  Src/m_ts_options.F90
  Src/ts_init.F90

----------------------------------------------------
June 13, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-51
Fixed gamma-calculation to be able to handle non-bias

* The sparsity pattern check was implicit in the update_DM routine
  Now it is correctly handled for Gamma calculations.

modified:
  Src/Makefile
  Src/m_ts_dm_update.F90
  Src/m_ts_full.F90
  Src/m_ts_tri.F90

----------------------------------------------------
June 13, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-50
F77 requires intrinsic function call dcmplx and not cmplx

modified:
  Src/linpack.F

----------------------------------------------------
June 13, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-49
Fixed cmplx-creation variables 

* cmplx(1._dp,1._dp) /= dcmplx(1._dp,1._dp) == cmplx(1._dp,1._dp,dp)

modified:
  Src/detover.F
  Src/linpack.F

----------------------------------------------------
June 13, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-48
Clean-up and module separations, full structure of transiesta completed

* Moved specific routines to more general modules, i.e. 
  ts_print_charge has been moved to a m_ts_charge
  module.
  In this module we have also added the charge-correction
  feature (still experimental)
  The options for this method is now fully contained in m_ts_charge

  Print charges routines have received an interface update
  so that it could potentially be called from outer routines.
  The options for this method is now fully contained in m_ts_charge

* Removed old routines which were not necessary, i.e. old weight
  routines.

* Added surface-greens function information.
  Will now print out inforamtion about the recursive method:
    Lopez-Sancho x2 & Rubio recursive surface self-energy calculation...
    Lopez-Sancho x2 & Rubio: Mean/std iterations:     8.6979 /     7.7636
    Lopez-Sancho x2 & Rubio: Min/Max iterations :          3 /         22

  This has no purpose other than telling the users about the scheme.

* Moved files to more saying names, i.e. 
    m_ts_mem > m_ts_full
    m_ts_new_tri > m_ts_tri

* Fully implemented the new transiesta methods for the full transiesta calculation
  TODO check how the matrixes are looking when calculating with the different methods

* Created a module for dealing with updating the density matries in the
  transiesta iterations. 
  Currently there are many different which takes care of separate functions.
  Unfortunately this will mean that maintenance is a hazzle.
  Maybe they could be autogenerated as the loops are the same, but the 
  updating is not the same.

* Removed the requirement for the tri-diagonal method to not be able to handle
  buffer atoms. It should now be possible to do all the same calculations.

* Corrected indentation in m_ts_options

removed:
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_new_tri.F90
added:
  Src/m_ts_charge.F90
  Src/m_ts_dm_update.F90
  Src/m_ts_full.F90
  Src/m_ts_full_scat.F90
modified:
  Src/Makefile
  Src/compute_dm.F
  Src/m_ts_electrode.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/siesta_forces.F
  Src/ts_init.F90

----------------------------------------------------
June 12, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-47
Optimizations and little clean-up, finished weight

* Instead of doing dcmplx(0,1)*<x> we can do dcmplx(0,<x>)
  This has been implemented in m_hs_matrix and elsewhere.

* Added a SAVE statement to a pulay variable (not necessary, but
  for clarity)

* Generalized the UC_expansion function for the self-energies in 
  transiesta. This will leverage a triple if-statement in the
  loop construct.

* When reading in the next Surface G we now read in both from
  one subroutine. I.e. cleaner interface.

* Prepared surface Green's function calculation to use pointers
  to a work array. Should speed it up a little bit (leverages
  a lot of de/allocates.
  Also cleaned the loop construct for checking convergence.

* Fully implemented a triple weight function.
  Fixed the communication so that it displays the correct integration
  estimate orbitals.

* Fixed iscf counter when performing transiesta cycles

* Added fdf_deprecated for TS.MixH (instead use MixHamiltonian)

modified:
  Src/Makefile
  Src/class_SpData1D.T90
  Src/class_SpData2D.T90
  Src/m_hs_matrix.f90
  Src/m_pulay.F90
  Src/m_trimat_invert.F90
  Src/m_ts_elec_se.F90
  Src/m_ts_electrode.F90
  Src/m_ts_mem.F90
  Src/m_ts_new_tri.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_sparse_helper_new.F90
  Src/m_ts_tri.F90
  Src/m_ts_weight.F90
  Src/siesta_forces.F
  Src/siesta_options.F90

----------------------------------------------------
June 11, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-46
Removed the concatenation feature of the objects, added name function

* The concatenation feature of retrieving the name of the object was
  not that useful. Hence, it has been obsoleted.
  Instead the function "name" has been created which returns the trimmed
  string of the name.
  
* Renamed "retrieve" to "attach" for the Sparsity object.
  This is semantically better and describes better the meaning.

modified:
  Src/basic_type.inc
  Src/class_Sparsity.F90
  Src/create_Sparsity_SC.F90
  Src/create_Sparsity_Union.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_new_tri.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_sparse_helper_new.F90
  Src/m_ts_tri.F90
  Src/m_ts_weight.F90
  Src/state_init.F

----------------------------------------------------
June 7, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-45
Fully implemented "initialized" and "same" for the class_ objects

* Added initialized and same in the basic_type.inc.
  initialized) This will allow one to do:
               initialized(<object>) to see if the <object>%data
               is associated.
               This will be the criteria of the initialized state.

  same) Comparison of same <object>%data address,
        thus it is an object comparison, and not value comparison.
	For same values I would advice that we do this by other
	names. For instance "equivalent".

* Used the new initialized in the m_ts_new_tri.F90 routine for
  making a single routine instead of several.
  I don't particularly like this, but transiesta requires a lot
  of similar routines, so this seems ok.

modified:
  Src/basic_type.inc
  Src/class_Data1D.T90
  Src/class_Data2D.T90
  Src/class_Geometry.F90
  Src/class_SpData1D.T90
  Src/class_SpData2D.T90
  Src/class_Sparsity.F90
  Src/class_TriMat.T90
  Src/m_ts_new_tri.F90

----------------------------------------------------
June 7, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-44
Forgot to add m_ts_aux.F90

added:
  Src/m_ts_aux.F90

----------------------------------------------------
June 7, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-43
Removed old transiesta code and restructured some general ts-routines

* Removed all references to the old transiesta version
  A lot of routines needed deletion of lines, etc.

* Moved the TSVHFIX to m_ts_voltage and renamed to ts_VH_fix

* Deleted a lot of unnecessary routines for the old tri-mat routines
  this ment that many routines in m_ts_aux_rout was not needed anymore.

* Moved m_ts_aux_rout.F to m_ts_aux.F90 and cleaned code.

removed:
  Src/m_ts_aux_rout.F
  Src/m_ts_in_siesta.F
  Src/m_ts_scattering.F
modified:
  Src/Makefile
  Src/compute_dm.F
  Src/dhscf.F
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_contour.f90
  Src/m_ts_electrode.F90
  Src/m_ts_io.F90
  Src/m_ts_iodm.F
  Src/m_ts_kpoints.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_method.f90
  Src/m_ts_new_tri.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_sparse_helper_new.F90
  Src/m_ts_tri.F90
  Src/m_ts_voltage.F90
  Src/m_ts_weight.F90
  Src/siesta_forces.F
  Src/ts_init.F90

----------------------------------------------------
June 7, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-42
New transiesta weighting and a lot of bugfixes (TODO clean code)

* Bugfix on class_OrbitalDistribution (OD) if the number of nodes was 1 
  and we where in an MPI-run environment.
  Instead of checking for the number of nodes in the orbital distribution
  we can check for the communicator being MPI_Comm_Self which is more robust.

* Name change of geom_helper routines.
    - ucell_nnn    => cell_xyz
    - ucell_n[xyz] => cell_[xyz]
    - ucell_n      => cell_d
  these names makes more sense in that they describe a coordinates
  unit cell in 3 coordinates.

* Added 2 new (better) methods for obtaining optimal tri-diagonal partition (TDP)
  of the transiesta GF^{-1} array. We now try to create a TDP by looping through all
  orbitals in the electrodes.
  The two methods will select based on:
    1) speed, the highest number of partitions, and the highest variance of
       the TDP.
       This is emperically found and tends to be alright
    2) memory, the lowest number of elements in the TDP
  For regular system they tend to give the same distribution, however, for long/large
  systems they could diverge.
  The segmentation has been parallelized to speed it up even though it is only
  performed once.

* Added explicit contour arrays for the left/right/non-equilibrium arrays
  This will make integration loops more explicit in transiesta routines
  Currently the ts_init routine creates the correct pointers

* Restructured the m_ts_options module, made the formats print out more 
  nicely

* In case of a bias and k-points we include a pointer array which points from
  transiesta local update sparsity to siesta local sparsity.
  This leverages the need to create a subset of the xij array to local form

* The global sparsity creator has been generalized and moved to 2 routines
  to make the code clearer in intent.
  Hence, we now have these routines:
    ts_Sparsity_Update (create an update sparsity, works for both global and local)
    ts_Sparsity_Global (create a global update sparsity)
  
* Changed the AllReduce routine for the transiesta arrays to a better interface

* Moved the print-out of the transiesta charges to right before the iteration step
  write-out. (thus they should be closer if Mulliken is printed)

* Added 3 different weight-schemes for the non-equilibrium contour
   1) A real-space weight:
      w_L = (\sum_k \Delta_L(k))^2
      w_R = (\sum_k \Delta_R(k))^2
   2) A real-space uncorrelated weight:
      w_L = \sum_k \Delta_L(k)^2
      w_R = \sum_k \Delta_R(k)^2
   3) A k-space uncorrelated weight:
      w_L^k = \Delta_L(k)^2
      w_R^k = \Delta_R(k)^2
  it seems that option 3 is the best choice as it weighs each k-point integration
  as would have been done in the Gamma-point calculations. Hence we have made this
  the default.
  It can be changed via the option:
    TS.Weight.NonEquilibrium correlated|uncorrelated|k-uncorrelated
  for 1, 2, 3 respectively.
  Notice that for Gamma-calculation they are all the same!
  This required some abstraction of some of the routines for the integration of
  the Green's function. As of now this is located in m_ts_sparse_helper_new.F90

  NOTICE, this only works for the tri-diagonal routine

* TODO change the sparse method to do the same and clean up the code!
  
added:
  Src/m_ts_new_tri.F90
  Src/m_ts_sparse_helper_new.F90
  Src/m_ts_weight.F90
modified:
  Src/Makefile
  Src/class_OrbitalDistribution.F90
  Src/compute_dm.F
  Src/create_Sparsity_SC.F90
  Src/geom_helper.f90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_contour.f90
  Src/m_ts_io.F90
  Src/m_ts_mem.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/siesta_forces.F
  Src/ts_init.F90

----------------------------------------------------
June 3, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-41
Added functions for Sparsity and fixed bug in MPI variable declaration

* Added "same" and "initialized" to the class_Sparsity
   - "same" returns true if two sparsities have the same ID (hence
     it is the same object)
   - initialized returns the field initialized
  it could be implemented to all "classes" via the include

* Added the normalization of the density of states for the surface-Green
  function

* Fixed an MPI variables double appearence (MPI_Comm_Self)

* Added bounds check for the phonon transport energy-points

modified:
  Src/MPI/mpi__include.f90
  Src/class_Sparsity.F90
  Src/m_ts_contour.f90
  Src/m_ts_electrode.F90

----------------------------------------------------
May 22, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-40
Added MPI_Comm_Self and fixed index out-of-bounds occuring in new routines

* In the Transiesta sparsity patterns, we request them to be local, hence
  the blocksize is that of the problem order, and without any distribution
  on processors.
  However, the current class_OrbitalDistribution (OD) could not take this into
  account when calculating which node had what.
  We needed to create an OD with a local sparsity pattern. The simplest
  thing was to enable the use of MPI_COMM_SELF, which is an intrinsic
  communicator in MPI (since very early version of MPI, hence it should
  not mean any compatibility issues).
  It is simply a communicator which only contains 1 processor, it-self.
  This also required a small alteration for the OD class to be able 
  to correctly figure out if it is local.
  This is now implemented with die calls for erroneous calls to the 
  affected routines.

  TODO, ensure that it really does make sense in other situations,
  perhaps it should return Node from MPI_Comm_World so that it is also
  able to do MPI_Recv/MPI_Send without problems. I.e.:
  If an MPI_Recv is performed with its own node ID, it will return instantly.

* Implemented the local sparsity pattern distribution in the search for
  the tri-mat partition.

* Added ncols to the newSparsity when creating a new sparsity

* Fixed comments for the Gauss-Fermi integral constants.

* In case of many bias contour points the Gauss-Fermi line contour
  could cause an overflow, this has been corrected.

modified:
  Src/MPI/mpi__include.f90
  Src/MPI/mpi_siesta.f90
  Src/MPI/mpif2sane.f90
  Src/class_OrbitalDistribution.F90
  Src/class_TriMat.T90
  Src/create_Sparsity_SC.F90
  Src/m_ts_aux_rout.F
  Src/m_ts_contour.f90
  Src/m_ts_tri.F90

----------------------------------------------------
May 22, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-39
Added new creation routine for the tri-parts, should better capture big systems

* Instead of making the first part occupy a lot of the sparsity we only 
  take half the first row as an initial part. Then the remaining parts
  should adapt to this. For very bulk systems this guess is better

modified:
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_tri.F90

----------------------------------------------------
May 22, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-38
Bugfix tri-parts allocation, added memory limitation on H(k), S(k) with UseBulk

* Forgot to nullify a pointer

* In case of UseBulk we replace the H_LL and H_RR with the hamiltonian
  from the electrode, i.e. bulk electrode Hamiltonian.
  Thus there is no need to create the H(k), S(k) for those parts.
  I have removed that information from those two arrays (saves more memory)

* As the tri-part algortihm relies on the orbitals existing in the sparse
  pattern, we add them before analyzing the sparsity pattern.
  This means that we correctly find the tri-part.

modified:
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90

----------------------------------------------------
May 22, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-37
Tri-diagonal matrix inversion routine should not handle parts == 1 cases

* If there is only one part in the tri-diagonal matrix then we don't have
  a tri-diagonal method.
  It will now die if this is the case (consider changing it to regular 
  inversion)

modified:
  Src/m_trimat_invert.F90

----------------------------------------------------
May 22, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-36
Made sure that the 3-tri-matrix was used in unforseen cases

* For very long range problems the tri-part routine does not
  perform that good (need a revision).
  Hence, it could often find only 2 parts.
  If this is the case we revert to the regular 3-tri-diagonal method

modified:
  Src/m_ts_Spartsity2TriMat.F90
  Src/m_ts_tri.F90

----------------------------------------------------
May 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-35
Corrected codes (comments) to deal with GFORTRAN compilation

* Incorrectly had a function return value as logical where it should be
  integer

* Apparently comments containing \* */ is not allowed by gfortran

modified:
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_sparse_helper.F90

----------------------------------------------------
May 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-34
Fully implemented the SFIND algorithm in the update regions appropriate

* The SFIND algorithm for finding an element in an integer array has been
  implemented. It should prove quite useful for large size problems

modified:
  Src/m_ts_sparse_helper.F90

----------------------------------------------------
May 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-33
Finalized the correct way of dealing with the k-point integration

* The method of Maslyuk was correct with small modifications.
  Currently the integration is performed like so:
   Eq. contour:
     \rho_{Eq} = \int (Gf^R-Gf^A) dE 
     \rho_{non-Eq} = \int Gf^R\Gamma Gf^A dE
     \rho = e^{-i.k.x} (\rho_{Eq}+\rho_{non-Eq})
  This means that we do not need to add the transposed of the non-equilibrium
  correction term.
  The implementation is so that when performing the weights we subtract the
  daggered Gf^R\Gamma Gf^A so that the update_zDM routine performs correctly.
  This may seem stupid, however, it allows to not change the add_DM routines.
  It is also faster.
  
  This method also does the weighting slightly differently than the Maslyuk version,
  see revno: 460 for explanation.

* Added warning message that the TS_ORIGINAL solution method does not perform 
  as expected.

* Corrected the integration error estimates for cases where wL or wR where 0 in
  all \nu\mu.

* TODO we need to correct the integration for the energy matrix in case of bias
  in the same way as described above.

modified:
  Src/m_ts_options.F90
  Src/m_ts_sparse_helper.F90

----------------------------------------------------
May 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-32
Added more checks against the SFIND algorithm 

* We still have the possibility to add the SFIND algorithm a couple
  of places, this will be done eventually.

modified:
  Src/m_ts_sparse_helper.F90

----------------------------------------------------
May 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-31
Fixed the sparsity pattern for the tri-diag part calculation

* The electrodes where added in the wrong indices. 
  This has now been fixed

modified:
  Src/m_ts_tri.F90

----------------------------------------------------
May 20, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-30
Ensured the correct tri-part creation and moved no_BufL/R to options

* By utilizing create_Sparsity_Union we can ensure that the electrode
  parts are fully considered when figuring out the tri parts for
  transiesta.
  It however, requires some more initialization on the sparsity pattern
  is performed as we ensure that the elements are considered.

* Numerous routines had calculated the number of orbitals in the 
  buffer regions of transiesta.
  This calculation has now moved to the option reading of TS and
  is thus made an "option"

  Removed code that used no_BufL/R the most frequent places

modified:
  Src/Makefile
  Src/create_Sparsity_Union.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_in_siesta.F
  Src/m_ts_mem.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_voltage.F90
  Src/ts_init.F90

----------------------------------------------------
May 20, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-29
Added generalization of tri-diagonal inversion and Transiesta implementation

* Added file m_trimat_invert which contains routines for inverting a tri-diagonal
  matrix of arbitrary sizes (it relies heavily on the TriMat class.
  The algoritm can be found in:
    DOI: 10.1088/1749-4699/5/1/014009
  despite the articles title, it also contains a general routine for
  calculating the inversion.

* Fixed a bug in the which_part routine in the TriMat class.

* Added module to convert a SIESTA sparsity pattern to a tri-diagonal matrix pattern
  It does so by a hand-made algorithm (I cannot find any papers on this topic).
  The algorithm is simple but has proven to really perform optimal choices.

  It tries to make all the parts as evenly distributed in size as possible.
  TODO add algorithm to optimize on memory (the left-most and right-most part
  can be made larger and thus reduce the total memory requirement).

* In the sparse tri-solver for transiesta it has been fully implemented.
  We can, currently, only utilize the hand-made parts in the equilibrium contour
  as we don't need the full column of the inverted matrix.
  So we use the optimized tri-diagonal matrix in the equilibrium contour
  and the 3-tri-diagonl matrix in the bias contour.
  TODO reduce the de/allocations by making a hack in the TriMat class
  to pass the array.
  This will leverage some time in these large arrays.
  It also required some changes to the m_ts_tri_scat routines which calculated
  the GF

* This optimized tri-diagonalization routines required an initialitation step for
  the sparse tri solver.
  This has been added and called in compute_DM 
  TODO add a ts_init_DM routine

added:
  Src/m_trimat_invert.F90
  Src/m_ts_Sparsity2TriMat.F90
modified:
  Src/Makefile
  Src/class_TriMat.T90
  Src/compute_dm.F
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
  Src/ts_init.F90

----------------------------------------------------
May 19, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-28
Transiesta code cleanup and simplification

* Moved the k-point conjugation into the update routines
  This leveraged the need for a couple of routines which
  had been deleted in m_ts_mem and m_ts_tri

* Added a which_part function to the TriMat class to
  retrieve the part in which a given row or column
  lies in (maybe it should just be deleted)

modified:
  Src/Makefile
  Src/class_TriMat.T90
  Src/m_ts_mem.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90

----------------------------------------------------
May 17, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-27
TStri: Removed the memory requirement of the electrodes self-energies

* In the transiesta tri-diagonal case (memory-reduced) a further
  memory reduction could be made
  The Sigma[LR] is now pointing to a segment of the GF array.
  This only requires that the GF array is not used in between the 
  calls to UC_expansion and prepare_GF_inv routines.
  However, this was already the case so no need to restructure
  the program.
  It required that the calc_GF_Bias routine was altered slightly, 
  but only a single copy of the electrode arrays are needed
  to compensate the change.

modified:
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90

----------------------------------------------------
May 17, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-26
Added electrode TYPE and generalized TriMat3, bugfixes in TS

* Added a type to contain the transiesta electrodes
  It contains the following information:
    - HSfile
    - Atoms
    - Used atoms
    - Orbitals
    - Used orbitals
    - Replication in A1/A2/A3 directions
  
  The type resides in m_ts_electype and also has
  function calls to retrieve all the information without using the
  type % denotation.

  TODO instantiate this type in TBTrans_rep

* Made the tri-diagonal matrix class to a generic one.
  This will accomodate a further optimization in the transiesta
  core eventually.
  Prepared the insertion of the self-energies to comply with
  an arbitrary tri-diagonal matrix format

* The non-equilibrium integration seems to be mysterious.
  In the Maslyuk version he uses the transposed, which could
  be due to his assumptions on the Gf and Gamma properties:
    Gf = Gf ^ T
  and hence we should not transpose here.
  In the add_DMnonEq routines we have made it the same element
  that is updated (however it makes the error-estimate worse
  which could mean that it is wrong?)
  TODO check with Mads

* Added a routine for the sparsity class to retrieve information
  in one line.
  It can easily be extended as everything has to be named arguments
  (for now I have not added the DUMMY == die argument which forces
   the use of named arguments)
  The same idea could be extended to the other classes if necessary.
  I, at least, think it makes sense to not pollute every small routine
  with trivial calls.
  It has been implemented in the routines of transiesta.
  For the classes it has the interface:
    call retrieve(this,<list of NAMED arguments with respective
                        equivalent function names>)

* Renamed module m_ts_mem_sparsity to a more meaningful name:
    m_ts_sparse

removed:
  Src/class_TriMat3.F90
  Src/class_TriMat3.T90
added:
  Src/class_TriMat.F90
  Src/class_TriMat.T90
  Src/m_ts_electype.F90
renamed:
  Src/m_ts_mem_sparsity.F90 => Src/m_ts_sparse.F90
modified:
  Src/Makefile
  Src/class_Sparsity.F90
  Src/compute_dm.F
  Src/m_ts_electrode.F90
  Src/m_ts_gf.F90
  Src/m_ts_in_siesta.F
  Src/m_ts_mem.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_voltage.F90
  Src/ts_init.F90
  Src/ts_show_regions.f90
  Src/m_ts_sparse.F90

----------------------------------------------------
May 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-25
Added the voltage drop to only occur in the central region

* Using the fdf option:
    TS.VoltagePlacement
  with values:
    1) cell
    2) central or scat
  will determine where the transiesta voltage drop will be placed
  in the mesh of the cell.
  Specifying 'cell' will put the voltage drop across the entire cell
  Specifying 'scat' or 'central' will put the voltage drop in
  between the electrodes, i.e. in the central region of the 
  transiesta regions.
  Previously it was 'cell', but we default it to 'central' as that
  makes more physical sense.

modified:
  Src/m_ts_options.F90
  Src/m_ts_voltage.F90

----------------------------------------------------
May 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-24
Restructured the integration algorithm, same result, improved error estimate

* The k-point integration is a bit tricky. 
  I have made it to comply with the V.V. Maslyuk version.
  This includes that the error-estimates on the integration parameters
  now are correct.

* The equilibrium density is a symmetric matrix, hence we force
  the symmetry by taking Gf(i,j)-conjg(Gf(j,i)) for symmetry.
  However, the non-equilibrium points are not symmetric, but should
  be handled transposed. Again by guidance of V.V. Maslyuk's code.

modified:
  Src/m_ts_mem.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90

----------------------------------------------------
May 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-23
Custometic updates and removal of unused variables

* Removed ununsed variables in various modules

* Updated the tri-diagonalization routine requirements

modified:
  Src/class_Data1D.T90
  Src/class_SpData1D.T90
  Src/final_H_f_stress.F
  Src/m_ts_mem.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
  Src/siesta_forces.F
  Src/ts_init.F90
  Src/ts_show_regions.f90

----------------------------------------------------
May 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-22
Logic in the ts-kgrid means that it has to be initialized

* I had erroneously moved the ts-k-grid creation into a TSmode
  logic.
  However, the electrode TSHS relies on the transiesta k-points.
  I would actually prefer if this was the SIESTA as that makes 
  more sense.

* Prepared the logic in the electrode read.
  We now only check the transiesta part of the k-grid.
  In principle the z-direction k-points need not be checked for
  the electrodes.

* transiesta io routine now correctly reads in onlyS files.

modified:
  Src/m_ts_electrode.F90
  Src/m_ts_io.F90
  Src/ts_init.F90

----------------------------------------------------
May 7, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-21
Restructured common transiesta routines to generic purpose module

* Routines concerning transiesta to be more stringent.
  All routines related to the reading/expansion of the self-energy
  has been moved to m_ts_elec_se.F90

* Renamed all Gf.Gamma.Gf routines to Gf_Gamma_Gf so that naming scheme
  is the same. They are located in their own module for each different 
  method. Hence if loading the wrong module a compilation error will arise.

* The weightDM routines concerning the sparsity method has been moved
   to the m_ts_sparse_helper.

* Removed not used routines (they are in the history so can be found)
  These are the Gf_Gamma_Gf_Left/Right routines for the tri-diagonal 
  solution method.

* Checked compilation of TS with gfortran 4.4.5

added:
  Src/m_ts_elec_se.F90
modified:
  Src/Makefile
  Src/m_ts_in_siesta.F
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_method.f90
  Src/m_ts_scattering.F
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90

----------------------------------------------------
May 7, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-20
Optimized transiesta for speed, now the sparse-tri is precise +bugfixes

* Moved Vscf voltage ramp call into the module. 
  This will make extensions easier.

* Reinstantiated the complex Gamma arrays. 
  We can actually save the GAA[LR] arrays as the Gamma arrays
  are first created later. (consider this)
  Also they are transposed (which speeds up access in BLAS), hence
  the naming scheme: Gamma[LR]T

* Created the charge print-out in the sparse SCF cycle.
  It now print the charges as in the development branch of
  transiesta.

* Moved size checks of transiesta arrays into the 
  ts_init routine. This is very detached however, it will capture
  an erroneous run in the beginning instead of after the diagon run.
  TODO recheck everything here.

* Added option to transpose the Gf arrays in the add_DM routines.
  For now this is not needed, however it could be used for optimizing matrix
  accessing.

* Have completely rewritten the code for doing:
    GF.Gamma.Gf^\dagger (GfGGf)
  Upon inspection it is clear that the matrix products
  can be split up into left electrode GfGGf where only the first
  no_L states are needed in the Green's function.
  For the right electrode we only need the last no_R states in the
  Green's function.
  This leverages a lot of computation as no_u_TS-no_L-no_R states
  can be removed from the Gf computation.
  Hence the bias integration points are now "cheap".
  
* GfGGf has been rewritten in terms of block computations which speeds
  it up by a factor of 5 (for my test system, the larger the better speed up). 
  After this update Transiesta bias contour points are the cheap points
  as opposed to previously where they where the expensive integration points.

* Generated a transiesta method module which contains information
  about the different methods available.
  Currently it only contains:
   1) the original method
   2) the sparse method
   3) the tridiagonalization sparse method
   4) whether the GF calculation only needs Gf22

* Fixed a logical error about an acting efield and transiesta
  run. This is not allowed and will create erroneous contours.
  Hence the program should die if both of these are supplied.

* Added preliminary entry for "immediate transiesta" runs.
  This seems to require the EDM matrix, and right now we
  need this being created after having read in the <SysLabel>.DM
  The point of this is to do regular SIESTA run. Then 
  immediately start Transiesta from that DM. (i.e. you force SIESTA
  to believe it has already converged, which it has).
  This should leverage the initial diagon run on very large systems.
 
* Added a sorting algorithm for the contour points in transiesta.
  This should (with large number of energy points) meen a higher 
  numeric accuracy.
  I.e. we sum up the energy-points with small weights and end 
  with the large weight energy-points.

* The tridiagonalization routine coupled with the sparse pattern of
  transiesta should now be the preferred way of dealing with transiesta
  runs. It is extremely fast and has exactly the same precision.
  This means that we have added the computation of all necessary arrays
  in the tri-diagonal case. Hence the new tri-diagonalization routine
  can also handle TS.UseBulk F.
  TODO, eventually the old implementation should be phased out.

* Changed the logic behind the integration of the non-equilibrium
  correction terms for the density matrix.
  Instead of adding the factor -i on the Gf.Gamma.Gf we add it
  to the weight when dealing with these energy points.
  It should be more clearer now.

* Added explanations about the sign convention in m_ts_mem.F90
  so that new developers can see what is going on.

* Added error estimates about the integration of the density matrix
  For now it defaults to printing it out. The calculation of the
  estimate is fast and does not take any time as it is per-orbital.
  The print-out is per k-point, hence for many k-points the out-file
  will be flooded.
  The error estimate is only estimated in the density part, i.e.
  when dealing with k-points it is only the real(imag) part of the 
  density that takes part in the weight.
  TODO: add flag for requesting this information. For instance:
        TS.NonEquilibrium.ErrorEstimate T/F

* Made the sparse tridiagonalization the default behaviour.
  The user can obtain the old implementation by setting:
   TS.SolutionMethod original
   TS.TriDiag F

* Removed unneccessary arrays GAA[LR] from the sparse methods
  The Gamma arrays can handily be used for this.
  This is because the GAA[LR] are used to obtain the self-energies
  and THEN the Gamma arrays are constructed (in the same routine:
  UC_expansion_Sigma_GammaT). Hence we re-use the memory elements.

* Moved the addition of the self-energies to the prepare_Gf routines.
  This makes much more logical sense than the previous implementation.

* BUGfix: symmetric Gf.Gamma.Gf^\dagger only symmetric in Gamma-point
  Previously the Gamma arrays where real quantities and the Gf.Gamma.Gf
  was made/forced symmetric. However, this is only the case for the 
  Gamma-point calculation and hence any non-symmetric part of k-point 
  sampling was actually not caught.
  Practically this should not meen much, but it does influence the 
  convergence, hence for large bias and many energy points this does
  have influence.

* BUGfix: sign on EDMR was wrong
  It seemed like the sign on the EDMR was wrong. It seems like this needs 
  some testing.

* BUGfix: weight of DM was performed on the absolute square of the 
  non-equilibrium density matrix. However as the imaginary part of
  Gf.Gamma.Gf has to do with local currents and nothing with the 
  density it should only be the real part of Gf.Gamma.Gf which determines
  the weight.

* BUGfix: weights in left/right electrode regions was not weighted as 
  performed as in the article.
  This was primarily due to the tri-diagonalization which could not
  handle the Gf.Gamma.Gf product properly. Hence the weights was fixed
  to 1, 0 in the left/right regions, respectively.

* NOTICE
  The original implementation does not perform the correct integration
  with bias and using the tri-diagonalization. Hence it should not be used.
  I have forced a warning about this and forced the regular method.
  Hence:
    TS.SolutionMethod original
    TS.Voltage /= 0
    TS.TriDiag T
  will become:
    TS.SolutionMethod original
    TS.Voltage /= 0
    TS.TriDiag F

* TODO
   Clean up the routines for next commit
   Ensure compilation with gfortran
   Talk to Alberto about the SCF.RequireHConvergence and
         SCF.H.Tolerance
   Add all this information to the manual

added:
  Src/m_ts_method.f90
modified:
  Src/Makefile
  Src/class_TriMat3.T90
  Src/compute_dm.F
  Src/dhscf.F
  Src/m_new_dm.F90
  Src/m_ts_contour.f90
  Src/m_ts_in_siesta.F
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_mem_sparsity.F90
  Src/m_ts_options.F90
  Src/m_ts_scattering.F
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_voltage.F90
  Src/siesta_forces.F
  Src/siesta_init.F
  Src/ts_init.F90

----------------------------------------------------
April 27, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-19
Cleaned up the class names and references in the code

* Changed all names class_Array[12]D to class_Data[12]D

* Changed all names class_SpArr[12]D to class_SpData[12]D

* The usage of these classes in the code has also been corrected
  and especially the readSpData2D (previously readSpMatrix) has	
  been edited to conform with the new names.

* DEV advice:
   to change the name of the classes do:
     sed -s -i -e "s/Data\([12]\)D/<new name>\1D/g" *.*
   which successfully will change "Data" to "<new name>" in all
   codes.

* All the files that referenced SpMatrix has been 
  renamed to SpData2D.

* ** forgot the file changes in commit 458, added that to TS-scf.CHANGES **

renamed:
  Src/class_Array1D.T90 => Src/class_Data1D.T90
  Src/class_Array2D.T90 => Src/class_Data2D.T90
  Src/class_Fstack_Pair_Geometry_SpMatrix.F90 => Src/class_Fstack_Pair_Geometry_SpData2D.F90
  Src/class_Pair_Geometry_SpMatrix.F90 => Src/class_Pair_Geometry_SpData2D.F90
  Src/class_SpArr1D.T90 => Src/class_SpData1D.T90
  Src/class_SpArr2D.T90 => Src/class_SpData2D.T90
  Src/class_lsdczArray1D.F90 => Src/class_Data1D.F90
  Src/class_lsdczArray2D.F90 => Src/class_Data2D.F90
  Src/class_lsdczSpArr1D.F90 => Src/class_SpData1D.F90
  Src/class_lsdczSpArr2D.F90 => Src/class_SpData2D.F90
  Src/extrapolateSpMatrix.F90 => Src/extrapolateSpData2D.F90
  Src/readSpMatrix.F90 => Src/readSpData2D.F90
  Src/restructSpMatrix.F90 => Src/restructSpData2D.F90
modified:
  Docs/TS-scf.CHANGES
  Src/Makefile
  Src/compute_EKS_Harris.F90
  Src/m_new_dm.F90
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/setup_H0.F
  Src/setup_hamiltonian.F
  Src/siesta_init.F
  Src/sparse_matrices.F
  Src/state_analysis.F
  Src/state_init.F
  version.info
  Src/class_Data1D.T90
  Src/class_Data2D.T90
  Src/class_Fstack_Pair_Geometry_SpData2D.F90
  Src/class_Pair_Geometry_SpData2D.F90
  Src/class_SpData2D.T90
  Src/class_Data1D.F90
  Src/class_Data2D.F90
  Src/class_SpData1D.F90
  Src/class_SpData2D.F90
  Src/extrapolateSpData2D.F90
  Src/readSpData2D.F90
  Src/restructSpData2D.F90

----------------------------------------------------
April 27, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-18
Fully revised/optimized the tri-diagonal inversion of the GF

* Added a new class_TriMat3 (M) which has the following properties:

  1. The 3 refers to it being only a 3-part tridiagonal matrix
     which fits the transiesta scheme elegantly.
     I.e. M31 and M13 are non-existing
  2. To obtain a pointer to a subpart of the matrix do:
       M<i,j> => val<i><j>(TriMat3)
     or the full matrix by:
       M      => val      (TriMat3)
     Thus each segment of the tri-diagonal matrix is a self
     contained matrix. This makes sense as the typical usage
     of tri-diagonal matrices is to utilize operations in
     segments rather than entire matrices simultaneously.
     The memory is layout in a single dimension as:
       M11
       M21
       M12
       M22
       M32
       M23
       M33
     i.e. the conventional Fortran memory layout.
  3. A function "index" allows to get the corresponding 1D-index
     in the "M=>val(TriMat3)" index.
     I.e.:
        idx = index(TriMat3,<i>,<j>)
     will give the correct index of the i'th row and j'th column of the
     full matrix.
     It returns 0 for all elements in M13 and M31.
  4. To create a tri-diagonal matrix do:
       call newzTriMat3(this,<left>,<center>,<right>, name=<name>)
     Maybe the names should be changed, but they make visual sense.
     It is associated with 3 size specifications:
        left, center, right
     which summed yields the matrix order.
     The dimensions can be obtained via:
       nrows_g_[left|center|right](TriMat3)
     to conform with the sparsity pattern.
     Then:
       nrows_g(TriMat3)
     returns the matrix order.

     Currently there is no equivalent nrows.

     This could be extended with an OrbitalDistribution
     element so that it can be used in a distributed manner.
     However, I don't know if this is usuable?

* Added the tri-diagonalization routine for the transiesta
  sparse solution method. 

  This is accompanied by two files:
    m_ts_tri.F90
    m_ts_tri_scat.F90

  Simply do:
    TS.SolutionMethod sparse
    TS.TriDiag T

  This method has required a restructure of some of the most crucial
  routines in the sparse method.
  Hence for now the transiesta-methods have been fully separated.
  Otherwise we would have the following in MANY places...
    if ( ts_gamma_scf ) then
       if ( TriDiag ) then
         ...
       else
         ...
       end if
    else
       if ( TriDiag ) then
         ...
       else
         ...
       end if
    end if
  which could be ok, but for clarity they are currently separate.

  The routine is an adaptation of the old implementation. However, 
  simple analysis of the method suggested that it was not necessary
  to do any memory allocations. Hence no additional memory is 
  allocated and thus we further reduce the memory requirements by using
  this solution method compared to the sparse solver.

  This has also led to a dramatic speed-increase.

  For the tri-diagonal solution we rely on the class_TriMat3 which
  enables us easy access to a tri-diagonal data structure.

  TODO, move this to the *old* implementation.

* The GF_Gamma_GF routines needed a tri-diagonal counter part
  Luckily they are easier to optimize as the tri-diagonal construct
  allows direct BLAS calls for each segment.
  I.e. there are calls to:
    Gf_Gamma_Gf_Left
    Gf_Gamma_Gf_Right
  which both does not use any extra memory when doing the matrix
  multiplications and is faster.

* The old GfGammGF routine has been obsoleted and thus deleted

* Created a new module which keeps the dublicated routines for
  the sparse transiesta in a separate module.
  
    m_ts_sparse_helper

  this module deals with the following operations:
    1) creating the k-point Hamiltonian in sparse format
    2) symmetrizing a k-point Hamiltonian
    3) creating the Gamma-point Hamiltonian in sparse format
    4) symmetrizing a Gamma-point Hamiltonian
    5) AllReduce a zSpArr1D (only in MPI)
    6) initialize the local density matrix
    7) update the local density matrix from a global sparse
       format density matrix

* All class_* which contains data have been added a new routine:
    init_val
  which initializes the value arrays to:
    logical = .false.
    integer = 0
    real = 0.
    complex = (0.,0.)
  with the correct precisions.
  This is currently in the following routines:
    SpArr[12]D
    Array[12]D
    TriMat3

  I was not sure about the need for such a routine in the 
  Geometry class, and if so, how it should be handled, i.e.
    1) should it initialize the positions,
    2) should it initialize the cell,
    3) should it initialize the species list,
    4) should it initialize number of atoms.
  Hence, I have not done anything for this class.

added:
  Src/class_TriMat3.F90
  Src/class_TriMat3.T90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
modified:
  Src/class_Array1D.T90
  Src/class_Array2D.T90
  Src/class_SpArr1D.T90
  Src/class_SpArr2D.T90
  Src/class_lsdczArray1D.F90
  Src/class_lsdczArray2D.F90
  Src/class_lsdczSpArr1D.F90
  Src/compute_dm.F
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_options.F90
  Src/m_ts_scattering.F
  Src/siesta_forces.F

----------------------------------------------------
April 24, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-17
Merge of two commits

----------------------------------------------------
April 24, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-16
Optimized electrode surface green's function

* The calculation of the surface Green's function has received 
  an optimization.

* The DOS calculation in the surface GF is now not performed in
  Transiesta (it was not used).
  This will save us a large amount of computations. (however,
  it only has meaning once as it is the electrode GF generation)

* The interface change is now also present in TBTrans_rep

* TODO: I suspect that a large amount of memory could be 
  saved in this routine (however, it is not that 
  memory consumptioning so it might not be worth-while seeking 
  this kind of optimization)

modified:
  Src/m_ts_electrode.F90
  Src/m_ts_gf.F90
  Src/ts_init.F90
  Util/TBTrans_rep/tbtrans.F90

----------------------------------------------------
April 24, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-16
Execution speed in GFGGF routine down to ~25%

* The GFGGF routine has been troubling because the original
  implementation was extremely fast (but requiring twice
  the no_u_TS region of memory).
  Primarily the speed was due to transposing of the GF
  which makes matrix-multiplication much easier.
  I have leveraged that and fully transposed GF before entry
  to the GFGGF routines.
  This actually makes it ~2 as fast as the old implementation
  i.e. ~3-4 times as fast as the previous implementation 
  (memory reduced).
  For bias calculations the speed-up should be quite noticeable
  as many systems require a huge amount of energy points for 
  better convergence.

* The GFGGF routine has been merged to the non-sparse
  method which in turn required the reduction of the Gamma
  arrays into real quantities. (this simply means lower 
  memory consumption)

* DEV notice. When reading/writing arrays:
    write(<unit>) array(1:n,1:n,1:2)
  one should prefer to read in the values via the same
  bounds:
    read(<unit>) array(1:n,1:n,1:2)
  and NOT:
    read(<unit>) array(1:n**2*2)
  I can't really see why as I had suspected the file to only containg 
  values in the record (and not array bounds). However, testing this
  in m_ts_mem_scat revealed a much slower execution speed in the latter.
  Is there a reason I have overlooked?

* Made GF creation easier by changing the interface for the LHS to a 
  square matrix, rather than 1D matrix.

* Optimized the expansion routines for a simpler solution
  when only dealing with non-repeated electrodes.
  Also moved the one dublicated code into a subroutine

* When the repetition is off we have removed any overhead associated with 
  the expansion loop.

* The EYE functions have been slightly changed, there are no if statements
  now.

modified:
  Src/Makefile
  Src/intrinsic_missing.f90
  Src/m_ts_in_siesta.F
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_scattering.F

----------------------------------------------------
April 19, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-15
Optimized the Gf_Gamma_Gf routine

* Removed the need for double code in Gf_Gamma_Gf routine
  It had no purpose (now we do the same thing by having an offset
  in the matrices)

modified:
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90

----------------------------------------------------
April 19, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-14
Added timings of the expansion routines

* Have added timings for some crucial expansion routines
  which deals with the repetition.
  ** Consider to remove them once we have a good feeling of their
     performance. These routines are called excessively.

modified:
  Src/m_ts_mem_scat.F90
  Src/m_ts_scattering.F

----------------------------------------------------
April 18, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-13
Added a new module for creating unions of dense and sparse matrices

* Preparing the Transiesta sparse to deal with full sparse matrices
  This requires that the electrodes are gathered in the LHS for 
  containing the self-energies (which are not sparse).
  Thus we needed a way to make a new sparse format with a dense part
  This has been accomblished by creating the module:
  create_Sparsity_Union.F90
  This will eventually require the ts_mem_init to also get
  the block-distribution of the Hamiltonian and overlap matrices.
  Thus we have added this in the call.

* Added some declarations of creation for the last couple of routines

added:
  Src/create_Sparsity_Union.F90
modified:
  Src/Makefile
  Src/compute_dm.F
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_mem_sparsity.F90

----------------------------------------------------
April 5, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-12
Made error recognition in allocations in TS, moved Gamma to IsVolt

* the Gamma arrays in Transiesta are only needed when performing 
  voltage calculations. Hence they have been moved to such a state

* The allocation routines for the large arrays (GF,work) is 
  now checked for errors.
  This will kill the job on errors of allocation.

modified:
  Src/m_ts_mem.F90

----------------------------------------------------
April 5, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-11
Wrong routine call in non-MPI cases

* Call to the creation of the sparse HS was wrong in non-MPI

modified:
  Src/m_ts_mem_sparsity.F90

----------------------------------------------------
April 4, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-10
Bugfix in intrinsic_missing

* The sort array could occasionally overread a variable
  leading to dimension out-of-bounds.

modified:
  Src/intrinsic_missing.f90

----------------------------------------------------
April 3, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-9
TBTrans_rep eased calculation of PDOS

* Made the DOS calculation easier to read

modified:
  Util/TBTrans_rep/tbtrans.F90

----------------------------------------------------
April 2, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-8
TS sparse bugfixes for gnu compiler

* Some bugs which are only occuring for the GNU compiler has been
  fixed.
  They are mainly related to the intrinsic_missing module
  were nested calls of functions are not allowed in GNU, but with Intel
  it is.
  I.e. SORT(UNIQ(arr)) is NOT allowed with GNU
  This has been noted in the module for easy reference.

* The sparsity creator module has recieved some general fixes (intent
  of variables are now more correct)

* Code cleanup in terms of clarity has been performed

modified:
  Docs/siesta.tex
  Src/Makefile
  Src/create_Sparsity_SC.F90
  Src/intrinsic_missing.f90
  Src/m_ts_mem.F90
  Src/m_ts_mem_sparsity.F90
  Src/m_ts_options.F90
  Util/TBTrans_rep/tbtrans.F90

----------------------------------------------------
April 1, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-7

Added a new solution method for Transiesta *NEED TESTS*

* Transiesta now has two solution methods:
  <anything unrecognizable> the full array method
  'sparse' the sparse array method (heavily memory reduced)
  The selection can be distinguished by:
  TS.SolutionMethod orig|mem

* The mem solution method has been completely rewritten
  It accomodates full sparsity patterns for all arrays which does
  not need the full order of the matrix.
  For direct comparison these are the changes:
  1. Old TS code:
    - Full matrices:
        H, S, DM, EDM, DMR, EDMR, DMneqL, DMneqR
        GF_inv, GF
    - Global sparse matrices (in super cell pattern)
        H, S, DM, EDM, update_list, region_list
    - Local sparse matrices
        DM, EDM, H, S, update_list, region_list
    - Electrodes
        Gamma arrays are complex
  2. New memory reduced code:
    - Full matrices:
        GF_inv, GF
    - Global sparse matrices (in unit-cell pattern)
        H, S  
    - Global sparse matrices (in update-unit-cell pattern)
        DM, EDM, DMR, EDMR, DMneqL, DMneqR
    - Local sparse matrices
        DM, EDM, H, S
    - Electrodes
        Gamma arrays are real (they have no imaginary part)

  This will leave a memory foot-print well below 50% of what it was.
  For regular systems, it will even be on the order of 25% of what it was.

  The speed of the new routines are not extremely fast, they need some more
  optimizations and they mainly lack speed due to BLAS operations not enabled.
  The looping and checking in the constructs for the TS update region is 
  probably causing the slow execution.

  The memory reduced method does not show as much information regarding the
  charges. However, it shows the charges:
  1. Before the first Transiesta iteration
  2. After the last Transiesta iteration (in siesta_forces)
  TODO add distinguishing between update and non-update region.

  * REMARK * The solution method has been tested on a couple of systems.
  It seems that the execution is stable and provides reliable results,
  however, we need more testing!

* In order to fulfil the above memory reduced creations we need some new 
  routines.
  1. A sparsity pattern creator which can down-fold a super cell pattern
     into a unit cell pattern.
     This is straight forward as that can be performed by down-folding
     all values in list_col into the unit cell and then remove any duplicates.
     * NOTE * the new Transiesta routines are heavily relying on the fact
              that the unit cell pattern of list_col is sorted in each row entry. 
	      Hence the sparsity creator will automatically sort the entries.
	      This also makes sense for the unit cell sparsity pattern.
  2. A sparsity pattern creator which takes a MASK to select which entries
     should be copied to the new sparsity.
     This will NOT sort the list_col entries per row, as one does not know
     about the existence of any super cell entries. However, it retains
     the order of entries.

* A new module has been added which adds some generic "missing" routines
  in fortran.
  We here list some of the functions:
     VNORM : (norm of vector, when called on matrix it returns the 
              column wise norm in a vector of same dimension as DIM=2)
     SORT  : sorts an array (int only)
     UNIQ  : returns all unique elements of an array (int only)
     UNIQC : returns the number of unique elements of an array (int only)
     SFIND : finds an element of an sorted array (int only)
     MODP  : a ceiling version of the MOD, operator (int only)
     EYE   : returns the identity matrix of all kinds

  It is completely separable and should always be kept as such.
  For further information, see the details in the module.

* Added a new module geom_helper.
  This should aid in the search for various values in the SIESTA
  sparsity pattern via look-ups.
  1. the iaorb array (returns the atom which an orbital resides
     on) is easily reached by searching in the lasto array.
     Note, it does so by guessing the atom number from the number
     of orbitals on the first atom, hence it searches fast.
  2. the indexuo array (which returns the unit cell equivalent
     orbital from a super cell index) can easily be checked by
     MODP (from intrinsic_missing)
     Here we name the function UCORB 
  3. ucell_nnn, returns the index of the ucell in the super cell
     construct. I.e. the transfer matrix index in all directions.
     There are equivalent routines for obtaining in any direction.
     ucell_nx, ucell_ny, ucell_nz, ucell_n (takes an extra argument)

* Made some cosmetic changes for conforming with 80 line width.
  And cleaned up the old m_ts_scattering

* Added the completion of only computing GF(2,2) when UpdateDMRC == .TRUE.
  and UseBulk == .TRUE.
  This means that the inversion routine will be much faster when not needing 
  to update cross-terms between left-centre and centre-right electrodes regions.
  Note that for bias calculations this can not be used (and is not used).
  However, we differentiate when it can be used, so that equilibrium energy
  points can utilize the smaller inversion technique. This speeds up
  Transiesta by quite a bit.
  This now exists both in the "old" TS and the memory reduced TS which makes
  both run faster.

* Added an integer array for the Array1D, Array2D and their sparse 
  equivalents.
  TODO: rename all files to class_T_{Array[12]D|SpArr[12]D} to be able
  to easily decipher that it contains all types.

* Removed unnecessary array workcmplx in Transiesta
  Fixed various spurious constructs ( double negation in ifs are not
  easy to understand)

* Added TRANSIESTA_TIMING flags for direct comparison between the solution
  methods of Transiesta. This flag should only be used when debugging, etc.
  This has shown that there needs to be worked on the expansion routines
  in the new sparsity method. If they are leveraged in utilization we
  can gain some more speed in Transiesta.

* TBTrans_rep has been removed the need for fdf_global_get (fdf is parallel)
  Also the calculation of PDOS has been corrected with the overlap conjugate
  This needs to be checked, however, it makes much more sense!
  The memory reduced methods has not been transferred to TBTrans. Currently
  TBtrans need not be considered "heavy" on the memory usage.

* REMARK, before release all TS tests needs to be redone.
  The transmission from the TBTrans and TBTrans_rep are not the same.
  TBTrans has a spin-factor meaning that that will give the double of the
  transmission. That is not the correct way.

* Updated the manual to reflect the changes

added:
  Src/create_Sparsity_SC.F90
  Src/geom_helper.f90
  Src/intrinsic_missing.f90
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_mem_sparsity.F90
modified:
  Docs/siesta.tex
  Src/Makefile
  Src/class_Sparsity.F90
  Src/class_lsdczArray1D.F90
  Src/class_lsdczArray2D.F90
  Src/class_lsdczSpArr1D.F90
  Src/class_lsdczSpArr2D.F90
  Src/compute_dm.F
  Src/m_ts_contour.f90
  Src/m_ts_electrode.F90
  Src/m_ts_gf.F90
  Src/m_ts_in_siesta.F
  Src/m_ts_options.F90
  Src/m_ts_scattering.F
  Src/siesta_forces.F
  Util/TBTrans/Makefile
  Util/TBTrans_rep/Makefile
  Util/TBTrans_rep/m_tbt_kpoints.F90
  Util/TBTrans_rep/m_tbt_options.F90
  Util/TBTrans_rep/tbtrans.F90

----------------------------------------------------
Mar 16, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-6
Changed the class_* classes for more future integrity

* The creation of several type-classes has been streamlined
  - Each class_<basetype> where <basetype> is:
    Array1D, Array2D, SpArr1D, SpArr2D.
    has been transformed to be generated from a single 
    file for all types.
    See class_lsdcz<basetype> which collects the
    creation of all data-types into one single file.
    TODO, the context could be cleared up, however, 
    the replication in code is very limited.

* Added a logical array for Array[12]D and SpArr[12]D

* basic_type.inc has recieved concatenation for the name 
  attribute in the parent class.
  Hence any classes created by this basic_type requires a "name"
  field to be processed. 
  This is a minor additon that helps printing out information
  about types.

* class_Sparsity has recieved some new additions
  - Two new fields "ncols" and "ncols_g" has been added.
    When an object is created they can be optionally passed down.
    If they are NOT passed, the value "nrows_g" will be used in both
    instances (which constitute a block-cyclic distribution).
  - The field-getters of the integer fields in the object has
    been made to PURE functions. This enables the use of them
    in routine interfaces.
    * NOTE * doing debugging of these routines if apted to change
    could be trouble some. PURE routines does not allow PRINT,WRITE
    statements (nor calls to UNPURE routines)
  - Interfaces for retrieving specific indices of arrays in the object
    has been added, the input variables are given specific names to
    be more descriptive
  - The printSparsity has been added information about the sparsity of
    the array. If "ncols_g" is set then the sparsity can be considered
    correct all the time. (on multiprocess runs one needs to sum, the
    sparsity number on all processors to get the correct sparsity, hence
    the sparsity is the local-nnzs/global size.
    The field is shown to 4 significant digits, which should be enough.

* class_Geometry has been re-indented (for code structure)
  Thus many lines have *changed*.
  The following is what has been added:
  - field-getters "cell" and "isa" which returns the "cell" or "isa"
    arrays has been added
  - All field-getters has been added the index-equivalent specification
    of the retrival. Hence "coords(g,2)" returns the coords of the 
    second atom in the geometry.
  - The field-getter "na" is PURE so that it can be used in interfaces

* class_SpArr[12]D has changed many of the field-getters to be PURE
  in the case that they only return integers.
  This means that they can be used in interfaces of routines.

  Have removed the initialization of the arrays on creation.
  Thus it is up to the developer to initialize arrays if needed.
  This will actually clear-up the code as the purpose of the array
  is apparent.

  TODO : many field-getters in class_Sparsity has been 
  added, we need to add them here as well. However, it seems like there
  should be a class_Sparsity.inc for any classes that wish
  to retain direct interaction on the parent object level.
  That is, routines of direct sparsity access:
    nnzs(class_SpArr1D)
  I.e. a common include graph which accesses the this%data%sp
  field and calls the appropriate sparsity routine.
  (This will come in handy when doing multitude of changes, as
  has been done now.)

* class_SpArr2D has recieved some additional features
  When creating an object from a distribution and sparsity
  pattern, one now has the possibility to decide which dimension
  gets attached the sparse layout (before it was the first dimension)
  This now enables an easy creation of "xa" sparsity arrays which has
  the correct sparsity layout.

* Makefile has been stripped of beginning line HASH marks on empty lines.
  They had no purpose and made stepping in the file incredibly hard!

removed:
  Src/class_sdczArray1D.F90
  Src/class_sdczArray2D.F90
  Src/class_sdczSpArr1D.F90
  Src/class_sdczSpArr2D.F90
added:
  Src/class_lsdczArray1D.F90
  Src/class_lsdczArray2D.F90
  Src/class_lsdczSpArr1D.F90
  Src/class_lsdczSpArr2D.F90
modified:
  Src/Makefile
  Src/basic_type.inc
  Src/class_Array1D.T90
  Src/class_Array2D.T90
  Src/class_Geometry.F90
  Src/class_SpArr1D.T90
  Src/class_SpArr2D.T90
  Src/class_Sparsity.F90

----------------------------------------------------
Mar 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-5
Added TSDM update region writeout with TRANSIESTA_DEBUG

* When -DTRANSIESTA_DEBUG is supplied a new file:
  <syslabel>.TSORB_UP is created.
  This holds the matrix elements which are updated
  in the following format:
  no_u no_u
  <row> <col> <-1|1> 
  <row> <col> <-1|1> 
  ...

  where -1 means not updated, and 1 means updated.
  This is very useful when checking against the updated
  region. Mainly for future debugging and region abstraction
  methods.

* Indentations in the class_* files

modified:
  Src/Makefile
  Src/class_Array2D.T90
  Src/class_Sparsity.F90
  Src/m_ts_in_siesta.F

----------------------------------------------------
Mar 7, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-4
Diverged the SpMatrix class to separate Dimension classes

* Have fully clarified the dimension, and sparsity scheme
  of the *old* SpMatrix class as well as the *Array2D* class
* Instead of having files constituting the full precision
  and type regime for the classes we have abstracted it to:
  - class_[sdcz]Array[12]D
    * TODO, consider renaming to [...]Arr[12]D?
  - class_[sdcz]SpArr[12]D (instead of SpMatrix and SpVector)
* The class creations are formed by the files:
  class_sdczArray[12]D which abstract the modules by 
  preprocessor flags. This requires several #define #undef 
  lines, however, it is clearer to collect these routines
  to a united code segment.
* All references to the *old* SpMatrix has been removed 
  and updated to dSpArr2D (which is the fully equivalent)
  This also holds for the FStack and Pair classes!
* The subroutine names of SpMatrix has changed from
  <prefix>SpMatrix<suffix> to <prefix>dSpArr2D<suffix> naming 
  scheme
  - TODO, probably this should be generalized in some way?
  - TODO, is this prefered? It directly says what it reads
    however, I much prefer, "<prefix>_dSpArr2D_<suffix>" for 
    clarification of datatype and inline reading.
* Removed unnecessary nullification of pointers which
  are directly associated afterwards

* Added *exact* copy pastable coordinates if the electrodes
  are not coinciding. The only requirement is that the first
  atom HAS to be located in the correct place. 
  I.e. we locate all other atoms with respect to the first
  electrode-atom in a TranSIESTA cycle.
* Added GF checks in the m_ts_options routine:
  - Generally it will be adviced that non-bias runs
    with the same electrodes on the left- and right-hand
    side use the same GF (for computational efficiency)
  - Hence we do the following checks:
    If the user requests the same left and right GF we
    can check:
    - If Bias /= 0.0 we die
    - If Left TSHS file /= Right TSHS file we die
    - If requested number of atoms are not the full 
      electrode file! (the partition of the GF is not 
      the same for left/right)
  - Will also notify the user about the option
    to do this if the conditions are meet.
  
removed:
  Src/class_SpMatrix.F90
  Src/class_cArray1D.F90
  Src/class_cArray2D.F90
  Src/class_dArray1D.F90
  Src/class_dArray2D.F90
  Src/class_sArray1D.F90
  Src/class_sArray2D.F90
  Src/class_zArray1D.F90
  Src/class_zArray2D.F90
added:
  Src/class_SpArr1D.T90
  Src/class_SpArr2D.T90
  Src/class_sdczArray1D.F90
  Src/class_sdczArray2D.F90
  Src/class_sdczSpArr1D.F90
  Src/class_sdczSpArr2D.F90
modified:
  Src/Makefile
  Src/class_Array1D.T90
  Src/class_Array2D.T90
  Src/class_Fstack_Pair_Geometry_SpMatrix.F90
  Src/class_Pair_Geometry_SpMatrix.F90
  Src/compute_EKS_Harris.F90
  Src/extrapolateSpMatrix.F90
  Src/m_new_dm.F90
  Src/m_ts_electrode.F90
  Src/m_ts_options.F90
  Src/readSpMatrix.F90
  Src/restructSpMatrix.F90
  Src/setup_H0.F
  Src/setup_hamiltonian.F
  Src/siesta_init.F
  Src/sparse_matrices.F
  Src/state_analysis.F
  Src/state_init.F

----------------------------------------------------
Mar 5, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-3
TBTrans_rep fix for the new sparsity modules and MPI

* Renamed all DAT_Double references to MPI_Double_precision
* Added dependency on the sparsity modules (albeit they are
  not used, they will eventually)

modified:
  Util/TBTrans_rep/Makefile
  Util/TBTrans_rep/m_tbt_iotshs.F90
  Util/TBTrans_rep/m_tbt_read_tshs.F90

----------------------------------------------------
Mar 5, 2013 -- Nick P. Andersen     trunk-432--ts-scf-2
Added sparsity index retrieval by supplying an index

* Added sparsity index retrieval for the arrays:
  - n_col
  - list_ptr
  - list_col
  simply pass two arguments to the functions
  - n_col(s,idx)
  - list_ptr(s,idx)
  - list_col(s,idx)
* Removed all fdf_global_get in m_ts_options

modified:
  Src/class_Sparsity.F90
  Src/m_ts_options.F90

----------------------------------------------------
Feb 25, 2013 -- Nick P. Andersen     trunk-432--ts-scf-1
Initial commit, separated Array2D into precision and datatypes

* The need for generalizing the Array2D to different precision
  and data-types was apparent.
  Furthermore, the need for 1D cases has been met.
  - The naming scheme has been chosen to follow that of general
    data type schemes, they are:
    - sArray[12]D = single real
    - dArray[12]D = double real
    - cArray[12]D = single complex
    - zArray[12]D = double complex
* Added routines to alloc.F90:
  - realloc_1c, realloc_2c
  - realloc_1z, realloc_2z
  - dealloc_1c, dealloc_2c
  - dealloc_1z, dealloc_2z
  to accomodate the new datatypes in the [sdcz]Array[12]D types.
* The creation of objects through "newArray2D" has been changed
  to also require the precision/datatype declaration.
  This will clarify the object inheritance and make codes clear. 
* Removed the old single data-type array type Array2D
* All routines dependent on "Array2D" has now changed to "dArray2D"
* Trying to bypass the naming scheme by using preprocessor concatenators
  has proven unsuccessfull.

  The reason seems to be the expansion order.
  
  Thus there are many preprocess definitions containing the same words,
  this seems inificient, but necessary.

* We could change all alloc routines/Array[12]D codes to be generated through
  simple bash-scripts.

removed:
  Src/class_Array2D.F90
added:
  Docs/TS-scf.CHANGES
  Src/basic_func.inc
  Src/class_Array1D.T90
  Src/class_Array2D.T90
  Src/class_cArray1D.F90
  Src/class_cArray2D.F90
  Src/class_dArray1D.F90
  Src/class_dArray2D.F90
  Src/class_sArray1D.F90
  Src/class_sArray2D.F90
  Src/class_zArray1D.F90
  Src/class_zArray2D.F90
modified:
  Src/Makefile
  Src/alloc.F90
  Src/class_SpMatrix.F90
  Src/extrapolateSpMatrix.F90
  Src/m_new_dm.F90
  Src/readSpMatrix.F90
  Src/restructSpMatrix.F90
