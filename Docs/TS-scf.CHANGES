----------------------------------------------------
April 5, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-11
Wrong routine call in non-MPI cases

* Call to the creation of the sparse HS was wrong in non-MPI

modified:
  Src/m_ts_mem_sparsity.F90

----------------------------------------------------
April 4, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-10
Bugfix in intrinsic_missing

* The sort array could occasionally overread a variable
  leading to dimension out-of-bounds.

modified:
  Src/intrinsic_missing.f90

----------------------------------------------------
April 3, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-9
TBTrans_rep eased calculation of PDOS

* Made the DOS calculation easier to read

modified:
  Util/TBTrans_rep/tbtrans.F90

----------------------------------------------------
April 2, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-8
TS sparse bugfixes for gnu compiler

* Some bugs which are only occuring for the GNU compiler has been
  fixed.
  They are mainly related to the intrinsic_missing module
  were nested calls of functions are not allowed in GNU, but with Intel
  it is.
  I.e. SORT(UNIQ(arr)) is NOT allowed with GNU
  This has been noted in the module for easy reference.

* The sparsity creator module has recieved some general fixes (intent
  of variables are now more correct)

* Code cleanup in terms of clarity has been performed

modified:
  Docs/siesta.tex
  Src/Makefile
  Src/create_Sparsity_SC.F90
  Src/intrinsic_missing.f90
  Src/m_ts_mem.F90
  Src/m_ts_mem_sparsity.F90
  Src/m_ts_options.F90
  Util/TBTrans_rep/tbtrans.F90

----------------------------------------------------
April 1, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-7

Added a new solution method for Transiesta *NEED TESTS*

* Transiesta now has two solution methods:
  <anything unrecognizable> the full array method
  'sparse' the sparse array method (heavily memory reduced)
  The selection can be distinguished by:
  TS.SolutionMethod orig|mem

* The mem solution method has been completely rewritten
  It accomodates full sparsity patterns for all arrays which does
  not need the full order of the matrix.
  For direct comparison these are the changes:
  1. Old TS code:
    - Full matrices:
        H, S, DM, EDM, DMR, EDMR, DMneqL, DMneqR
        GF_inv, GF
    - Global sparse matrices (in super cell pattern)
        H, S, DM, EDM, update_list, region_list
    - Local sparse matrices
        DM, EDM, H, S, update_list, region_list
    - Electrodes
        Gamma arrays are complex
  2. New memory reduced code:
    - Full matrices:
        GF_inv, GF
    - Global sparse matrices (in unit-cell pattern)
        H, S  
    - Global sparse matrices (in update-unit-cell pattern)
        DM, EDM, DMR, EDMR, DMneqL, DMneqR
    - Local sparse matrices
        DM, EDM, H, S
    - Electrodes
        Gamma arrays are real (they have no imaginary part)

  This will leave a memory foot-print well below 50% of what it was.
  For regular systems, it will even be on the order of 25% of what it was.

  The speed of the new routines are not extremely fast, they need some more
  optimizations and they mainly lack speed due to BLAS operations not enabled.
  The looping and checking in the constructs for the TS update region is 
  probably causing the slow execution.

  The memory reduced method does not show as much information regarding the
  charges. However, it shows the charges:
  1. Before the first Transiesta iteration
  2. After the last Transiesta iteration (in siesta_forces)
  TODO add distinguishing between update and non-update region.

  * REMARK * The solution method has been tested on a couple of systems.
  It seems that the execution is stable and provides reliable results,
  however, we need more testing!

* In order to fulfil the above memory reduced creations we need some new 
  routines.
  1. A sparsity pattern creator which can down-fold a super cell pattern
     into a unit cell pattern.
     This is straight forward as that can be performed by down-folding
     all values in list_col into the unit cell and then remove any duplicates.
     * NOTE * the new Transiesta routines are heavily relying on the fact
              that the unit cell pattern of list_col is sorted in each row entry. 
	      Hence the sparsity creator will automatically sort the entries.
	      This also makes sense for the unit cell sparsity pattern.
  2. A sparsity pattern creator which takes a MASK to select which entries
     should be copied to the new sparsity.
     This will NOT sort the list_col entries per row, as one does not know
     about the existence of any super cell entries. However, it retains
     the order of entries.

* A new module has been added which adds some generic "missing" routines
  in fortran.
  We here list some of the functions:
     VNORM : (norm of vector, when called on matrix it returns the 
              column wise norm in a vector of same dimension as DIM=2)
     SORT  : sorts an array (int only)
     UNIQ  : returns all unique elements of an array (int only)
     UNIQC : returns the number of unique elements of an array (int only)
     SFIND : finds an element of an sorted array (int only)
     MODP  : a ceiling version of the MOD, operator (int only)
     EYE   : returns the identity matrix of all kinds

  It is completely separable and should always be kept as such.
  For further information, see the details in the module.

* Added a new module geom_helper.
  This should aid in the search for various values in the SIESTA
  sparsity pattern via look-ups.
  1. the iaorb array (returns the atom which an orbital resides
     on) is easily reached by searching in the lasto array.
     Note, it does so by guessing the atom number from the number
     of orbitals on the first atom, hence it searches fast.
  2. the indexuo array (which returns the unit cell equivalent
     orbital from a super cell index) can easily be checked by
     MODP (from intrinsic_missing)
     Here we name the function UCORB 
  3. ucell_nnn, returns the index of the ucell in the super cell
     construct. I.e. the transfer matrix index in all directions.
     There are equivalent routines for obtaining in any direction.
     ucell_nx, ucell_ny, ucell_nz, ucell_n (takes an extra argument)

* Made some cosmetic changes for conforming with 80 line width.
  And cleaned up the old m_ts_scattering

* Added the completion of only computing GF(2,2) when UpdateDMRC == .TRUE.
  and UseBulk == .TRUE.
  This means that the inversion routine will be much faster when not needing 
  to update cross-terms between left-centre and centre-right electrodes regions.
  Note that for bias calculations this can not be used (and is not used).
  However, we differentiate when it can be used, so that equilibrium energy
  points can utilize the smaller inversion technique. This speeds up
  Transiesta by quite a bit.
  This now exists both in the "old" TS and the memory reduced TS which makes
  both run faster.

* Added an integer array for the Array1D, Array2D and their sparse 
  equivalents.
  TODO: rename all files to class_T_{Array[12]D|SpArr[12]D} to be able
  to easily decipher that it contains all types.

* Removed unnecessary array workcmplx in Transiesta
  Fixed various spurious constructs ( double negation in ifs are not
  easy to understand)

* Added TRANSIESTA_TIMING flags for direct comparison between the solution
  methods of Transiesta. This flag should only be used when debugging, etc.
  This has shown that there needs to be worked on the expansion routines
  in the new sparsity method. If they are leveraged in utilization we
  can gain some more speed in Transiesta.

* TBTrans_rep has been removed the need for fdf_global_get (fdf is parallel)
  Also the calculation of PDOS has been corrected with the overlap conjugate
  This needs to be checked, however, it makes much more sense!
  The memory reduced methods has not been transferred to TBTrans. Currently
  TBtrans need not be considered "heavy" on the memory usage.

* REMARK, before release all TS tests needs to be redone.
  The transmission from the TBTrans and TBTrans_rep are not the same.
  TBTrans has a spin-factor meaning that that will give the double of the
  transmission. That is not the correct way.

* Updated the manual to reflect the changes

added:
  Src/create_Sparsity_SC.F90
  Src/geom_helper.f90
  Src/intrinsic_missing.f90
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_mem_sparsity.F90
modified:
  Docs/siesta.tex
  Src/Makefile
  Src/class_Sparsity.F90
  Src/class_lsdczArray1D.F90
  Src/class_lsdczArray2D.F90
  Src/class_lsdczSpArr1D.F90
  Src/class_lsdczSpArr2D.F90
  Src/compute_dm.F
  Src/m_ts_contour.f90
  Src/m_ts_electrode.F90
  Src/m_ts_gf.F90
  Src/m_ts_in_siesta.F
  Src/m_ts_options.F90
  Src/m_ts_scattering.F
  Src/siesta_forces.F
  Util/TBTrans/Makefile
  Util/TBTrans_rep/Makefile
  Util/TBTrans_rep/m_tbt_kpoints.F90
  Util/TBTrans_rep/m_tbt_options.F90
  Util/TBTrans_rep/tbtrans.F90

----------------------------------------------------
Mar 16, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-6
Changed the class_* classes for more future integrity

* The creation of several type-classes has been streamlined
  - Each class_<basetype> where <basetype> is:
    Array1D, Array2D, SpArr1D, SpArr2D.
    has been transformed to be generated from a single 
    file for all types.
    See class_lsdcz<basetype> which collects the
    creation of all data-types into one single file.
    TODO, the context could be cleared up, however, 
    the replication in code is very limited.

* Added a logical array for Array[12]D and SpArr[12]D

* basic_type.inc has recieved concatenation for the name 
  attribute in the parent class.
  Hence any classes created by this basic_type requires a "name"
  field to be processed. 
  This is a minor additon that helps printing out information
  about types.

* class_Sparsity has recieved some new additions
  - Two new fields "ncols" and "ncols_g" has been added.
    When an object is created they can be optionally passed down.
    If they are NOT passed, the value "nrows_g" will be used in both
    instances (which constitute a block-cyclic distribution).
  - The field-getters of the integer fields in the object has
    been made to PURE functions. This enables the use of them
    in routine interfaces.
    * NOTE * doing debugging of these routines if apted to change
    could be trouble some. PURE routines does not allow PRINT,WRITE
    statements (nor calls to UNPURE routines)
  - Interfaces for retrieving specific indices of arrays in the object
    has been added, the input variables are given specific names to
    be more descriptive
  - The printSparsity has been added information about the sparsity of
    the array. If "ncols_g" is set then the sparsity can be considered
    correct all the time. (on multiprocess runs one needs to sum, the
    sparsity number on all processors to get the correct sparsity, hence
    the sparsity is the local-nnzs/global size.
    The field is shown to 4 significant digits, which should be enough.

* class_Geometry has been re-indented (for code structure)
  Thus many lines have *changed*.
  The following is what has been added:
  - field-getters "cell" and "isa" which returns the "cell" or "isa"
    arrays has been added
  - All field-getters has been added the index-equivalent specification
    of the retrival. Hence "coords(g,2)" returns the coords of the 
    second atom in the geometry.
  - The field-getter "na" is PURE so that it can be used in interfaces

* class_SpArr[12]D has changed many of the field-getters to be PURE
  in the case that they only return integers.
  This means that they can be used in interfaces of routines.

  Have removed the initialization of the arrays on creation.
  Thus it is up to the developer to initialize arrays if needed.
  This will actually clear-up the code as the purpose of the array
  is apparent.

  TODO : many field-getters in class_Sparsity has been 
  added, we need to add them here as well. However, it seems like there
  should be a class_Sparsity.inc for any classes that wish
  to retain direct interaction on the parent object level.
  That is, routines of direct sparsity access:
    nnzs(class_SpArr1D)
  I.e. a common include graph which accesses the this%data%sp
  field and calls the appropriate sparsity routine.
  (This will come in handy when doing multitude of changes, as
  has been done now.)

* class_SpArr2D has recieved some additional features
  When creating an object from a distribution and sparsity
  pattern, one now has the possibility to decide which dimension
  gets attached the sparse layout (before it was the first dimension)
  This now enables an easy creation of "xa" sparsity arrays which has
  the correct sparsity layout.

* Makefile has been stripped of beginning line HASH marks on empty lines.
  They had no purpose and made stepping in the file incredibly hard!

removed:
  Src/class_sdczArray1D.F90
  Src/class_sdczArray2D.F90
  Src/class_sdczSpArr1D.F90
  Src/class_sdczSpArr2D.F90
added:
  Src/class_lsdczArray1D.F90
  Src/class_lsdczArray2D.F90
  Src/class_lsdczSpArr1D.F90
  Src/class_lsdczSpArr2D.F90
modified:
  Src/Makefile
  Src/basic_type.inc
  Src/class_Array1D.T90
  Src/class_Array2D.T90
  Src/class_Geometry.F90
  Src/class_SpArr1D.T90
  Src/class_SpArr2D.T90
  Src/class_Sparsity.F90

----------------------------------------------------
Mar 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-5
Added TSDM update region writeout with TRANSIESTA_DEBUG

* When -DTRANSIESTA_DEBUG is supplied a new file:
  <syslabel>.TSORB_UP is created.
  This holds the matrix elements which are updated
  in the following format:
  no_u no_u
  <row> <col> <-1|1> 
  <row> <col> <-1|1> 
  ...

  where -1 means not updated, and 1 means updated.
  This is very useful when checking against the updated
  region. Mainly for future debugging and region abstraction
  methods.

* Indentations in the class_* files

modified:
  Src/Makefile
  Src/class_Array2D.T90
  Src/class_Sparsity.F90
  Src/m_ts_in_siesta.F

----------------------------------------------------
Mar 7, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-4
Diverged the SpMatrix class to separate Dimension classes

* Have fully clarified the dimension, and sparsity scheme
  of the *old* SpMatrix class as well as the *Array2D* class
* Instead of having files constituting the full precision
  and type regime for the classes we have abstracted it to:
  - class_[sdcz]Array[12]D
    * TODO, consider renaming to [...]Arr[12]D?
  - class_[sdcz]SpArr[12]D (instead of SpMatrix and SpVector)
* The class creations are formed by the files:
  class_sdczArray[12]D which abstract the modules by 
  preprocessor flags. This requires several #define #undef 
  lines, however, it is clearer to collect these routines
  to a united code segment.
* All references to the *old* SpMatrix has been removed 
  and updated to dSpArr2D (which is the fully equivalent)
  This also holds for the FStack and Pair classes!
* The subroutine names of SpMatrix has changed from
  <prefix>SpMatrix<suffix> to <prefix>dSpArr2D<suffix> naming 
  scheme
  - TODO, probably this should be generalized in some way?
  - TODO, is this prefered? It directly says what it reads
    however, I much prefer, "<prefix>_dSpArr2D_<suffix>" for 
    clarification of datatype and inline reading.
* Removed unnecessary nullification of pointers which
  are directly associated afterwards

* Added *exact* copy pastable coordinates if the electrodes
  are not coinciding. The only requirement is that the first
  atom HAS to be located in the correct place. 
  I.e. we locate all other atoms with respect to the first
  electrode-atom in a TranSIESTA cycle.
* Added GF checks in the m_ts_options routine:
  - Generally it will be adviced that non-bias runs
    with the same electrodes on the left- and right-hand
    side use the same GF (for computational efficiency)
  - Hence we do the following checks:
    If the user requests the same left and right GF we
    can check:
    - If Bias /= 0.0 we die
    - If Left TSHS file /= Right TSHS file we die
    - If requested number of atoms are not the full 
      electrode file! (the partition of the GF is not 
      the same for left/right)
  - Will also notify the user about the option
    to do this if the conditions are meet.
  
removed:
  Src/class_SpMatrix.F90
  Src/class_cArray1D.F90
  Src/class_cArray2D.F90
  Src/class_dArray1D.F90
  Src/class_dArray2D.F90
  Src/class_sArray1D.F90
  Src/class_sArray2D.F90
  Src/class_zArray1D.F90
  Src/class_zArray2D.F90
added:
  Src/class_SpArr1D.T90
  Src/class_SpArr2D.T90
  Src/class_sdczArray1D.F90
  Src/class_sdczArray2D.F90
  Src/class_sdczSpArr1D.F90
  Src/class_sdczSpArr2D.F90
modified:
  Src/Makefile
  Src/class_Array1D.T90
  Src/class_Array2D.T90
  Src/class_Fstack_Pair_Geometry_SpMatrix.F90
  Src/class_Pair_Geometry_SpMatrix.F90
  Src/compute_EKS_Harris.F90
  Src/extrapolateSpMatrix.F90
  Src/m_new_dm.F90
  Src/m_ts_electrode.F90
  Src/m_ts_options.F90
  Src/readSpMatrix.F90
  Src/restructSpMatrix.F90
  Src/setup_H0.F
  Src/setup_hamiltonian.F
  Src/siesta_init.F
  Src/sparse_matrices.F
  Src/state_analysis.F
  Src/state_init.F

----------------------------------------------------
Mar 5, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-3
TBTrans_rep fix for the new sparsity modules and MPI

* Renamed all DAT_Double references to MPI_Double_precision
* Added dependency on the sparsity modules (albeit they are
  not used, they will eventually)

modified:
  Util/TBTrans_rep/Makefile
  Util/TBTrans_rep/m_tbt_iotshs.F90
  Util/TBTrans_rep/m_tbt_read_tshs.F90

----------------------------------------------------
Mar 5, 2013 -- Nick P. Andersen     trunk-432--ts-scf-2
Added sparsity index retrieval by supplying an index

* Added sparsity index retrieval for the arrays:
  - n_col
  - list_ptr
  - list_col
  simply pass two arguments to the functions
  - n_col(s,idx)
  - list_ptr(s,idx)
  - list_col(s,idx)
* Removed all fdf_global_get in m_ts_options

modified:
  Src/class_Sparsity.F90
  Src/m_ts_options.F90

----------------------------------------------------
Feb 25, 2013 -- Nick P. Andersen     trunk-432--ts-scf-1
Initial commit, separated Array2D into precision and datatypes

* The need for generalizing the Array2D to different precision
  and data-types was apparent.
  Furthermore, the need for 1D cases has been met.
  - The naming scheme has been chosen to follow that of general
    data type schemes, they are:
    - sArray[12]D = single real
    - dArray[12]D = double real
    - cArray[12]D = single complex
    - zArray[12]D = double complex
* Added routines to alloc.F90:
  - realloc_1c, realloc_2c
  - realloc_1z, realloc_2z
  - dealloc_1c, dealloc_2c
  - dealloc_1z, dealloc_2z
  to accomodate the new datatypes in the [sdcz]Array[12]D types.
* The creation of objects through "newArray2D" has been changed
  to also require the precision/datatype declaration.
  This will clarify the object inheritance and make codes clear. 
* Removed the old single data-type array type Array2D
* All routines dependent on "Array2D" has now changed to "dArray2D"
* Trying to bypass the naming scheme by using preprocessor concatenators
  has proven unsuccessfull.

  The reason seems to be the expansion order.
  
  Thus there are many preprocess definitions containing the same words,
  this seems inificient, but necessary.

* We could change all alloc routines/Array[12]D codes to be generated through
  simple bash-scripts.

removed:
  Src/class_Array2D.F90
added:
  Docs/TS-scf.CHANGES
  Src/basic_func.inc
  Src/class_Array1D.T90
  Src/class_Array2D.T90
  Src/class_cArray1D.F90
  Src/class_cArray2D.F90
  Src/class_dArray1D.F90
  Src/class_dArray2D.F90
  Src/class_sArray1D.F90
  Src/class_sArray2D.F90
  Src/class_zArray1D.F90
  Src/class_zArray2D.F90
modified:
  Src/Makefile
  Src/alloc.F90
  Src/class_SpMatrix.F90
  Src/extrapolateSpMatrix.F90
  Src/m_new_dm.F90
  Src/readSpMatrix.F90
  Src/restructSpMatrix.F90
