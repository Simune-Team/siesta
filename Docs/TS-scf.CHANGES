----------------------------------------------------
May 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-33
Finalized the correct way of dealing with the k-point integration

* The method of Maslyuk was correct with small modifications.
  Currently the integration is performed like so:
   Eq. contour:
     \rho_{Eq} = \int (Gf^R-Gf^A) dE 
     \rho_{non-Eq} = \int Gf^R\Gamma Gf^A dE
     \rho = e^{-i.k.x} (\rho_{Eq}+\rho_{non-Eq})
  This means that we do not need to add the transposed of the non-equilibrium
  correction term.
  The implementation is so that when performing the weights we subtract the
  daggered Gf^R\Gamma Gf^A so that the update_zDM routine performs correctly.
  This may seem stupid, however, it allows to not change the add_DM routines.
  It is also faster.
  
  This method also does the weighting slightly differently than the Maslyuk version,
  see revno: 460 for explanation.

* Added warning message that the TS_ORIGINAL solution method does not perform 
  as expected.

* Corrected the integration error estimates for cases where wL or wR where 0 in
  all \nu\mu.

* TODO we need to correct the integration for the energy matrix in case of bias
  in the same way as described above.

modified:
  Src/m_ts_options.F90
  Src/m_ts_sparse_helper.F90

----------------------------------------------------
May 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-32
Added more checks against the SFIND algorithm 

* We still have the possibility to add the SFIND algorithm a couple
  of places, this will be done eventually.

modified:
  Src/m_ts_sparse_helper.F90

----------------------------------------------------
May 21, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-31
Fixed the sparsity pattern for the tri-diag part calculation

* The electrodes where added in the wrong indices. 
  This has now been fixed

modified:
  Src/m_ts_tri.F90

----------------------------------------------------
May 20, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-30
Ensured the correct tri-part creation and moved no_BufL/R to options

* By utilizing create_Sparsity_Union we can ensure that the electrode
  parts are fully considered when figuring out the tri parts for
  transiesta.
  It however, requires some more initialization on the sparsity pattern
  is performed as we ensure that the elements are considered.

* Numerous routines had calculated the number of orbitals in the 
  buffer regions of transiesta.
  This calculation has now moved to the option reading of TS and
  is thus made an "option"

  Removed code that used no_BufL/R the most frequent places

modified:
  Src/Makefile
  Src/create_Sparsity_Union.F90
  Src/m_ts_Sparsity2TriMat.F90
  Src/m_ts_in_siesta.F
  Src/m_ts_mem.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_voltage.F90
  Src/ts_init.F90

----------------------------------------------------
May 20, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-29
Added generalization of tri-diagonal inversion and Transiesta implementation

* Added file m_trimat_invert which contains routines for inverting a tri-diagonal
  matrix of arbitrary sizes (it relies heavily on the TriMat class.
  The algoritm can be found in:
    DOI: 10.1088/1749-4699/5/1/014009
  despite the articles title, it also contains a general routine for
  calculating the inversion.

* Fixed a bug in the which_part routine in the TriMat class.

* Added module to convert a SIESTA sparsity pattern to a tri-diagonal matrix pattern
  It does so by a hand-made algorithm (I cannot find any papers on this topic).
  The algorithm is simple but has proven to really perform optimal choices.

  It tries to make all the parts as evenly distributed in size as possible.
  TODO add algorithm to optimize on memory (the left-most and right-most part
  can be made larger and thus reduce the total memory requirement).

* In the sparse tri-solver for transiesta it has been fully implemented.
  We can, currently, only utilize the hand-made parts in the equilibrium contour
  as we don't need the full column of the inverted matrix.
  So we use the optimized tri-diagonal matrix in the equilibrium contour
  and the 3-tri-diagonl matrix in the bias contour.
  TODO reduce the de/allocations by making a hack in the TriMat class
  to pass the array.
  This will leverage some time in these large arrays.
  It also required some changes to the m_ts_tri_scat routines which calculated
  the GF

* This optimized tri-diagonalization routines required an initialitation step for
  the sparse tri solver.
  This has been added and called in compute_DM 
  TODO add a ts_init_DM routine

added:
  Src/m_trimat_invert.F90
  Src/m_ts_Sparsity2TriMat.F90
modified:
  Src/Makefile
  Src/class_TriMat.T90
  Src/compute_dm.F
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
  Src/ts_init.F90

----------------------------------------------------
May 19, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-28
Transiesta code cleanup and simplification

* Moved the k-point conjugation into the update routines
  This leveraged the need for a couple of routines which
  had been deleted in m_ts_mem and m_ts_tri

* Added a which_part function to the TriMat class to
  retrieve the part in which a given row or column
  lies in (maybe it should just be deleted)

modified:
  Src/Makefile
  Src/class_TriMat.T90
  Src/m_ts_mem.F90
  Src/m_ts_sparse.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90

----------------------------------------------------
May 17, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-27
TStri: Removed the memory requirement of the electrodes self-energies

* In the transiesta tri-diagonal case (memory-reduced) a further
  memory reduction could be made
  The Sigma[LR] is now pointing to a segment of the GF array.
  This only requires that the GF array is not used in between the 
  calls to UC_expansion and prepare_GF_inv routines.
  However, this was already the case so no need to restructure
  the program.
  It required that the calc_GF_Bias routine was altered slightly, 
  but only a single copy of the electrode arrays are needed
  to compensate the change.

modified:
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90

----------------------------------------------------
May 17, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-26
Added electrode TYPE and generalized TriMat3, bugfixes in TS

* Added a type to contain the transiesta electrodes
  It contains the following information:
    - HSfile
    - Atoms
    - Used atoms
    - Orbitals
    - Used orbitals
    - Replication in A1/A2/A3 directions
  
  The type resides in m_ts_electype and also has
  function calls to retrieve all the information without using the
  type % denotation.

  TODO instantiate this type in TBTrans_rep

* Made the tri-diagonal matrix class to a generic one.
  This will accomodate a further optimization in the transiesta
  core eventually.
  Prepared the insertion of the self-energies to comply with
  an arbitrary tri-diagonal matrix format

* The non-equilibrium integration seems to be mysterious.
  In the Maslyuk version he uses the transposed, which could
  be due to his assumptions on the Gf and Gamma properties:
    Gf = Gf ^ T
  and hence we should not transpose here.
  In the add_DMnonEq routines we have made it the same element
  that is updated (however it makes the error-estimate worse
  which could mean that it is wrong?)
  TODO check with Mads

* Added a routine for the sparsity class to retrieve information
  in one line.
  It can easily be extended as everything has to be named arguments
  (for now I have not added the DUMMY == die argument which forces
   the use of named arguments)
  The same idea could be extended to the other classes if necessary.
  I, at least, think it makes sense to not pollute every small routine
  with trivial calls.
  It has been implemented in the routines of transiesta.
  For the classes it has the interface:
    call retrieve(this,<list of NAMED arguments with respective
                        equivalent function names>)

* Renamed module m_ts_mem_sparsity to a more meaningful name:
    m_ts_sparse

removed:
  Src/class_TriMat3.F90
  Src/class_TriMat3.T90
added:
  Src/class_TriMat.F90
  Src/class_TriMat.T90
  Src/m_ts_electype.F90
renamed:
  Src/m_ts_mem_sparsity.F90 => Src/m_ts_sparse.F90
modified:
  Src/Makefile
  Src/class_Sparsity.F90
  Src/compute_dm.F
  Src/m_ts_electrode.F90
  Src/m_ts_gf.F90
  Src/m_ts_in_siesta.F
  Src/m_ts_mem.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_voltage.F90
  Src/ts_init.F90
  Src/ts_show_regions.f90
  Src/m_ts_sparse.F90

----------------------------------------------------
May 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-25
Added the voltage drop to only occur in the central region

* Using the fdf option:
    TS.VoltagePlacement
  with values:
    1) cell
    2) central or scat
  will determine where the transiesta voltage drop will be placed
  in the mesh of the cell.
  Specifying 'cell' will put the voltage drop across the entire cell
  Specifying 'scat' or 'central' will put the voltage drop in
  between the electrodes, i.e. in the central region of the 
  transiesta regions.
  Previously it was 'cell', but we default it to 'central' as that
  makes more physical sense.

modified:
  Src/m_ts_options.F90
  Src/m_ts_voltage.F90

----------------------------------------------------
May 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-24
Restructured the integration algorithm, same result, improved error estimate

* The k-point integration is a bit tricky. 
  I have made it to comply with the V.V. Maslyuk version.
  This includes that the error-estimates on the integration parameters
  now are correct.

* The equilibrium density is a symmetric matrix, hence we force
  the symmetry by taking Gf(i,j)-conjg(Gf(j,i)) for symmetry.
  However, the non-equilibrium points are not symmetric, but should
  be handled transposed. Again by guidance of V.V. Maslyuk's code.

modified:
  Src/m_ts_mem.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90

----------------------------------------------------
May 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-23
Custometic updates and removal of unused variables

* Removed ununsed variables in various modules

* Updated the tri-diagonalization routine requirements

modified:
  Src/class_Data1D.T90
  Src/class_SpData1D.T90
  Src/final_H_f_stress.F
  Src/m_ts_mem.F90
  Src/m_ts_options.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
  Src/siesta_forces.F
  Src/ts_init.F90
  Src/ts_show_regions.f90

----------------------------------------------------
May 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-22
Logic in the ts-kgrid means that it has to be initialized

* I had erroneously moved the ts-k-grid creation into a TSmode
  logic.
  However, the electrode TSHS relies on the transiesta k-points.
  I would actually prefer if this was the SIESTA as that makes 
  more sense.

* Prepared the logic in the electrode read.
  We now only check the transiesta part of the k-grid.
  In principle the z-direction k-points need not be checked for
  the electrodes.

* transiesta io routine now correctly reads in onlyS files.

modified:
  Src/m_ts_electrode.F90
  Src/m_ts_io.F90
  Src/ts_init.F90

----------------------------------------------------
May 7, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-21
Restructured common transiesta routines to generic purpose module

* Routines concerning transiesta to be more stringent.
  All routines related to the reading/expansion of the self-energy
  has been moved to m_ts_elec_se.F90

* Renamed all Gf.Gamma.Gf routines to Gf_Gamma_Gf so that naming scheme
  is the same. They are located in their own module for each different 
  method. Hence if loading the wrong module a compilation error will arise.

* The weightDM routines concerning the sparsity method has been moved
   to the m_ts_sparse_helper.

* Removed not used routines (they are in the history so can be found)
  These are the Gf_Gamma_Gf_Left/Right routines for the tri-diagonal 
  solution method.

* Checked compilation of TS with gfortran 4.4.5

added:
  Src/m_ts_elec_se.F90
modified:
  Src/Makefile
  Src/m_ts_in_siesta.F
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_method.f90
  Src/m_ts_scattering.F
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90

----------------------------------------------------
May 7, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-20
Optimized transiesta for speed, now the sparse-tri is precise +bugfixes

* Moved Vscf voltage ramp call into the module. 
  This will make extensions easier.

* Reinstantiated the complex Gamma arrays. 
  We can actually save the GAA[LR] arrays as the Gamma arrays
  are first created later. (consider this)
  Also they are transposed (which speeds up access in BLAS), hence
  the naming scheme: Gamma[LR]T

* Created the charge print-out in the sparse SCF cycle.
  It now print the charges as in the development branch of
  transiesta.

* Moved size checks of transiesta arrays into the 
  ts_init routine. This is very detached however, it will capture
  an erroneous run in the beginning instead of after the diagon run.
  TODO recheck everything here.

* Added option to transpose the Gf arrays in the add_DM routines.
  For now this is not needed, however it could be used for optimizing matrix
  accessing.

* Have completely rewritten the code for doing:
    GF.Gamma.Gf^\dagger (GfGGf)
  Upon inspection it is clear that the matrix products
  can be split up into left electrode GfGGf where only the first
  no_L states are needed in the Green's function.
  For the right electrode we only need the last no_R states in the
  Green's function.
  This leverages a lot of computation as no_u_TS-no_L-no_R states
  can be removed from the Gf computation.
  Hence the bias integration points are now "cheap".
  
* GfGGf has been rewritten in terms of block computations which speeds
  it up by a factor of 5 (for my test system, the larger the better speed up). 
  After this update Transiesta bias contour points are the cheap points
  as opposed to previously where they where the expensive integration points.

* Generated a transiesta method module which contains information
  about the different methods available.
  Currently it only contains:
   1) the original method
   2) the sparse method
   3) the tridiagonalization sparse method
   4) whether the GF calculation only needs Gf22

* Fixed a logical error about an acting efield and transiesta
  run. This is not allowed and will create erroneous contours.
  Hence the program should die if both of these are supplied.

* Added preliminary entry for "immediate transiesta" runs.
  This seems to require the EDM matrix, and right now we
  need this being created after having read in the <SysLabel>.DM
  The point of this is to do regular SIESTA run. Then 
  immediately start Transiesta from that DM. (i.e. you force SIESTA
  to believe it has already converged, which it has).
  This should leverage the initial diagon run on very large systems.
 
* Added a sorting algorithm for the contour points in transiesta.
  This should (with large number of energy points) meen a higher 
  numeric accuracy.
  I.e. we sum up the energy-points with small weights and end 
  with the large weight energy-points.

* The tridiagonalization routine coupled with the sparse pattern of
  transiesta should now be the preferred way of dealing with transiesta
  runs. It is extremely fast and has exactly the same precision.
  This means that we have added the computation of all necessary arrays
  in the tri-diagonal case. Hence the new tri-diagonalization routine
  can also handle TS.UseBulk F.
  TODO, eventually the old implementation should be phased out.

* Changed the logic behind the integration of the non-equilibrium
  correction terms for the density matrix.
  Instead of adding the factor -i on the Gf.Gamma.Gf we add it
  to the weight when dealing with these energy points.
  It should be more clearer now.

* Added explanations about the sign convention in m_ts_mem.F90
  so that new developers can see what is going on.

* Added error estimates about the integration of the density matrix
  For now it defaults to printing it out. The calculation of the
  estimate is fast and does not take any time as it is per-orbital.
  The print-out is per k-point, hence for many k-points the out-file
  will be flooded.
  The error estimate is only estimated in the density part, i.e.
  when dealing with k-points it is only the real(imag) part of the 
  density that takes part in the weight.
  TODO: add flag for requesting this information. For instance:
        TS.NonEquilibrium.ErrorEstimate T/F

* Made the sparse tridiagonalization the default behaviour.
  The user can obtain the old implementation by setting:
   TS.SolutionMethod original
   TS.TriDiag F

* Removed unneccessary arrays GAA[LR] from the sparse methods
  The Gamma arrays can handily be used for this.
  This is because the GAA[LR] are used to obtain the self-energies
  and THEN the Gamma arrays are constructed (in the same routine:
  UC_expansion_Sigma_GammaT). Hence we re-use the memory elements.

* Moved the addition of the self-energies to the prepare_Gf routines.
  This makes much more logical sense than the previous implementation.

* BUGfix: symmetric Gf.Gamma.Gf^\dagger only symmetric in Gamma-point
  Previously the Gamma arrays where real quantities and the Gf.Gamma.Gf
  was made/forced symmetric. However, this is only the case for the 
  Gamma-point calculation and hence any non-symmetric part of k-point 
  sampling was actually not caught.
  Practically this should not meen much, but it does influence the 
  convergence, hence for large bias and many energy points this does
  have influence.

* BUGfix: sign on EDMR was wrong
  It seemed like the sign on the EDMR was wrong. It seems like this needs 
  some testing.

* BUGfix: weight of DM was performed on the absolute square of the 
  non-equilibrium density matrix. However as the imaginary part of
  Gf.Gamma.Gf has to do with local currents and nothing with the 
  density it should only be the real part of Gf.Gamma.Gf which determines
  the weight.

* BUGfix: weights in left/right electrode regions was not weighted as 
  performed as in the article.
  This was primarily due to the tri-diagonalization which could not
  handle the Gf.Gamma.Gf product properly. Hence the weights was fixed
  to 1, 0 in the left/right regions, respectively.

* NOTICE
  The original implementation does not perform the correct integration
  with bias and using the tri-diagonalization. Hence it should not be used.
  I have forced a warning about this and forced the regular method.
  Hence:
    TS.SolutionMethod original
    TS.Voltage /= 0
    TS.TriDiag T
  will become:
    TS.SolutionMethod original
    TS.Voltage /= 0
    TS.TriDiag F

* TODO
   Clean up the routines for next commit
   Ensure compilation with gfortran
   Talk to Alberto about the SCF.RequireHConvergence and
         SCF.H.Tolerance
   Add all this information to the manual

added:
  Src/m_ts_method.f90
modified:
  Src/Makefile
  Src/class_TriMat3.T90
  Src/compute_dm.F
  Src/dhscf.F
  Src/m_new_dm.F90
  Src/m_ts_contour.f90
  Src/m_ts_in_siesta.F
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_mem_sparsity.F90
  Src/m_ts_options.F90
  Src/m_ts_scattering.F
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
  Src/m_ts_voltage.F90
  Src/siesta_forces.F
  Src/siesta_init.F
  Src/ts_init.F90

----------------------------------------------------
April 27, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-19
Cleaned up the class names and references in the code

* Changed all names class_Array[12]D to class_Data[12]D

* Changed all names class_SpArr[12]D to class_SpData[12]D

* The usage of these classes in the code has also been corrected
  and especially the readSpData2D (previously readSpMatrix) has	
  been edited to conform with the new names.

* DEV advice:
   to change the name of the classes do:
     sed -s -i -e "s/Data\([12]\)D/<new name>\1D/g" *.*
   which successfully will change "Data" to "<new name>" in all
   codes.

* All the files that referenced SpMatrix has been 
  renamed to SpData2D.

* ** forgot the file changes in commit 458, added that to TS-scf.CHANGES **

renamed:
  Src/class_Array1D.T90 => Src/class_Data1D.T90
  Src/class_Array2D.T90 => Src/class_Data2D.T90
  Src/class_Fstack_Pair_Geometry_SpMatrix.F90 => Src/class_Fstack_Pair_Geometry_SpData2D.F90
  Src/class_Pair_Geometry_SpMatrix.F90 => Src/class_Pair_Geometry_SpData2D.F90
  Src/class_SpArr1D.T90 => Src/class_SpData1D.T90
  Src/class_SpArr2D.T90 => Src/class_SpData2D.T90
  Src/class_lsdczArray1D.F90 => Src/class_Data1D.F90
  Src/class_lsdczArray2D.F90 => Src/class_Data2D.F90
  Src/class_lsdczSpArr1D.F90 => Src/class_SpData1D.F90
  Src/class_lsdczSpArr2D.F90 => Src/class_SpData2D.F90
  Src/extrapolateSpMatrix.F90 => Src/extrapolateSpData2D.F90
  Src/readSpMatrix.F90 => Src/readSpData2D.F90
  Src/restructSpMatrix.F90 => Src/restructSpData2D.F90
modified:
  Docs/TS-scf.CHANGES
  Src/Makefile
  Src/compute_EKS_Harris.F90
  Src/m_new_dm.F90
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/setup_H0.F
  Src/setup_hamiltonian.F
  Src/siesta_init.F
  Src/sparse_matrices.F
  Src/state_analysis.F
  Src/state_init.F
  version.info
  Src/class_Data1D.T90
  Src/class_Data2D.T90
  Src/class_Fstack_Pair_Geometry_SpData2D.F90
  Src/class_Pair_Geometry_SpData2D.F90
  Src/class_SpData2D.T90
  Src/class_Data1D.F90
  Src/class_Data2D.F90
  Src/class_SpData1D.F90
  Src/class_SpData2D.F90
  Src/extrapolateSpData2D.F90
  Src/readSpData2D.F90
  Src/restructSpData2D.F90

----------------------------------------------------
April 27, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-18
Fully revised/optimized the tri-diagonal inversion of the GF

* Added a new class_TriMat3 (M) which has the following properties:

  1. The 3 refers to it being only a 3-part tridiagonal matrix
     which fits the transiesta scheme elegantly.
     I.e. M31 and M13 are non-existing
  2. To obtain a pointer to a subpart of the matrix do:
       M<i,j> => val<i><j>(TriMat3)
     or the full matrix by:
       M      => val      (TriMat3)
     Thus each segment of the tri-diagonal matrix is a self
     contained matrix. This makes sense as the typical usage
     of tri-diagonal matrices is to utilize operations in
     segments rather than entire matrices simultaneously.
     The memory is layout in a single dimension as:
       M11
       M21
       M12
       M22
       M32
       M23
       M33
     i.e. the conventional Fortran memory layout.
  3. A function "index" allows to get the corresponding 1D-index
     in the "M=>val(TriMat3)" index.
     I.e.:
        idx = index(TriMat3,<i>,<j>)
     will give the correct index of the i'th row and j'th column of the
     full matrix.
     It returns 0 for all elements in M13 and M31.
  4. To create a tri-diagonal matrix do:
       call newzTriMat3(this,<left>,<center>,<right>, name=<name>)
     Maybe the names should be changed, but they make visual sense.
     It is associated with 3 size specifications:
        left, center, right
     which summed yields the matrix order.
     The dimensions can be obtained via:
       nrows_g_[left|center|right](TriMat3)
     to conform with the sparsity pattern.
     Then:
       nrows_g(TriMat3)
     returns the matrix order.

     Currently there is no equivalent nrows.

     This could be extended with an OrbitalDistribution
     element so that it can be used in a distributed manner.
     However, I don't know if this is usuable?

* Added the tri-diagonalization routine for the transiesta
  sparse solution method. 

  This is accompanied by two files:
    m_ts_tri.F90
    m_ts_tri_scat.F90

  Simply do:
    TS.SolutionMethod sparse
    TS.TriDiag T

  This method has required a restructure of some of the most crucial
  routines in the sparse method.
  Hence for now the transiesta-methods have been fully separated.
  Otherwise we would have the following in MANY places...
    if ( ts_gamma_scf ) then
       if ( TriDiag ) then
         ...
       else
         ...
       end if
    else
       if ( TriDiag ) then
         ...
       else
         ...
       end if
    end if
  which could be ok, but for clarity they are currently separate.

  The routine is an adaptation of the old implementation. However, 
  simple analysis of the method suggested that it was not necessary
  to do any memory allocations. Hence no additional memory is 
  allocated and thus we further reduce the memory requirements by using
  this solution method compared to the sparse solver.

  This has also led to a dramatic speed-increase.

  For the tri-diagonal solution we rely on the class_TriMat3 which
  enables us easy access to a tri-diagonal data structure.

  TODO, move this to the *old* implementation.

* The GF_Gamma_GF routines needed a tri-diagonal counter part
  Luckily they are easier to optimize as the tri-diagonal construct
  allows direct BLAS calls for each segment.
  I.e. there are calls to:
    Gf_Gamma_Gf_Left
    Gf_Gamma_Gf_Right
  which both does not use any extra memory when doing the matrix
  multiplications and is faster.

* The old GfGammGF routine has been obsoleted and thus deleted

* Created a new module which keeps the dublicated routines for
  the sparse transiesta in a separate module.
  
    m_ts_sparse_helper

  this module deals with the following operations:
    1) creating the k-point Hamiltonian in sparse format
    2) symmetrizing a k-point Hamiltonian
    3) creating the Gamma-point Hamiltonian in sparse format
    4) symmetrizing a Gamma-point Hamiltonian
    5) AllReduce a zSpArr1D (only in MPI)
    6) initialize the local density matrix
    7) update the local density matrix from a global sparse
       format density matrix

* All class_* which contains data have been added a new routine:
    init_val
  which initializes the value arrays to:
    logical = .false.
    integer = 0
    real = 0.
    complex = (0.,0.)
  with the correct precisions.
  This is currently in the following routines:
    SpArr[12]D
    Array[12]D
    TriMat3

  I was not sure about the need for such a routine in the 
  Geometry class, and if so, how it should be handled, i.e.
    1) should it initialize the positions,
    2) should it initialize the cell,
    3) should it initialize the species list,
    4) should it initialize number of atoms.
  Hence, I have not done anything for this class.

added:
  Src/class_TriMat3.F90
  Src/class_TriMat3.T90
  Src/m_ts_sparse_helper.F90
  Src/m_ts_tri.F90
  Src/m_ts_tri_scat.F90
modified:
  Src/class_Array1D.T90
  Src/class_Array2D.T90
  Src/class_SpArr1D.T90
  Src/class_SpArr2D.T90
  Src/class_lsdczArray1D.F90
  Src/class_lsdczArray2D.F90
  Src/class_lsdczSpArr1D.F90
  Src/compute_dm.F
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_options.F90
  Src/m_ts_scattering.F
  Src/siesta_forces.F

----------------------------------------------------
April 24, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-17
Merge of two commits

----------------------------------------------------
April 24, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-16
Optimized electrode surface green's function

* The calculation of the surface Green's function has received 
  an optimization.

* The DOS calculation in the surface GF is now not performed in
  Transiesta (it was not used).
  This will save us a large amount of computations. (however,
  it only has meaning once as it is the electrode GF generation)

* The interface change is now also present in TBTrans_rep

* TODO: I suspect that a large amount of memory could be 
  saved in this routine (however, it is not that 
  memory consumptioning so it might not be worth-while seeking 
  this kind of optimization)

modified:
  Src/m_ts_electrode.F90
  Src/m_ts_gf.F90
  Src/ts_init.F90
  Util/TBTrans_rep/tbtrans.F90

----------------------------------------------------
April 24, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-16
Execution speed in GFGGF routine down to ~25%

* The GFGGF routine has been troubling because the original
  implementation was extremely fast (but requiring twice
  the no_u_TS region of memory).
  Primarily the speed was due to transposing of the GF
  which makes matrix-multiplication much easier.
  I have leveraged that and fully transposed GF before entry
  to the GFGGF routines.
  This actually makes it ~2 as fast as the old implementation
  i.e. ~3-4 times as fast as the previous implementation 
  (memory reduced).
  For bias calculations the speed-up should be quite noticeable
  as many systems require a huge amount of energy points for 
  better convergence.

* The GFGGF routine has been merged to the non-sparse
  method which in turn required the reduction of the Gamma
  arrays into real quantities. (this simply means lower 
  memory consumption)

* DEV notice. When reading/writing arrays:
    write(<unit>) array(1:n,1:n,1:2)
  one should prefer to read in the values via the same
  bounds:
    read(<unit>) array(1:n,1:n,1:2)
  and NOT:
    read(<unit>) array(1:n**2*2)
  I can't really see why as I had suspected the file to only containg 
  values in the record (and not array bounds). However, testing this
  in m_ts_mem_scat revealed a much slower execution speed in the latter.
  Is there a reason I have overlooked?

* Made GF creation easier by changing the interface for the LHS to a 
  square matrix, rather than 1D matrix.

* Optimized the expansion routines for a simpler solution
  when only dealing with non-repeated electrodes.
  Also moved the one dublicated code into a subroutine

* When the repetition is off we have removed any overhead associated with 
  the expansion loop.

* The EYE functions have been slightly changed, there are no if statements
  now.

modified:
  Src/Makefile
  Src/intrinsic_missing.f90
  Src/m_ts_in_siesta.F
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_scattering.F

----------------------------------------------------
April 19, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-15
Optimized the Gf_Gamma_Gf routine

* Removed the need for double code in Gf_Gamma_Gf routine
  It had no purpose (now we do the same thing by having an offset
  in the matrices)

modified:
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90

----------------------------------------------------
April 19, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-14
Added timings of the expansion routines

* Have added timings for some crucial expansion routines
  which deals with the repetition.
  ** Consider to remove them once we have a good feeling of their
     performance. These routines are called excessively.

modified:
  Src/m_ts_mem_scat.F90
  Src/m_ts_scattering.F

----------------------------------------------------
April 18, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-13
Added a new module for creating unions of dense and sparse matrices

* Preparing the Transiesta sparse to deal with full sparse matrices
  This requires that the electrodes are gathered in the LHS for 
  containing the self-energies (which are not sparse).
  Thus we needed a way to make a new sparse format with a dense part
  This has been accomblished by creating the module:
  create_Sparsity_Union.F90
  This will eventually require the ts_mem_init to also get
  the block-distribution of the Hamiltonian and overlap matrices.
  Thus we have added this in the call.

* Added some declarations of creation for the last couple of routines

added:
  Src/create_Sparsity_Union.F90
modified:
  Src/Makefile
  Src/compute_dm.F
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_mem_sparsity.F90

----------------------------------------------------
April 5, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-12
Made error recognition in allocations in TS, moved Gamma to IsVolt

* the Gamma arrays in Transiesta are only needed when performing 
  voltage calculations. Hence they have been moved to such a state

* The allocation routines for the large arrays (GF,work) is 
  now checked for errors.
  This will kill the job on errors of allocation.

modified:
  Src/m_ts_mem.F90

----------------------------------------------------
April 5, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-11
Wrong routine call in non-MPI cases

* Call to the creation of the sparse HS was wrong in non-MPI

modified:
  Src/m_ts_mem_sparsity.F90

----------------------------------------------------
April 4, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-10
Bugfix in intrinsic_missing

* The sort array could occasionally overread a variable
  leading to dimension out-of-bounds.

modified:
  Src/intrinsic_missing.f90

----------------------------------------------------
April 3, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-9
TBTrans_rep eased calculation of PDOS

* Made the DOS calculation easier to read

modified:
  Util/TBTrans_rep/tbtrans.F90

----------------------------------------------------
April 2, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-8
TS sparse bugfixes for gnu compiler

* Some bugs which are only occuring for the GNU compiler has been
  fixed.
  They are mainly related to the intrinsic_missing module
  were nested calls of functions are not allowed in GNU, but with Intel
  it is.
  I.e. SORT(UNIQ(arr)) is NOT allowed with GNU
  This has been noted in the module for easy reference.

* The sparsity creator module has recieved some general fixes (intent
  of variables are now more correct)

* Code cleanup in terms of clarity has been performed

modified:
  Docs/siesta.tex
  Src/Makefile
  Src/create_Sparsity_SC.F90
  Src/intrinsic_missing.f90
  Src/m_ts_mem.F90
  Src/m_ts_mem_sparsity.F90
  Src/m_ts_options.F90
  Util/TBTrans_rep/tbtrans.F90

----------------------------------------------------
April 1, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-7

Added a new solution method for Transiesta *NEED TESTS*

* Transiesta now has two solution methods:
  <anything unrecognizable> the full array method
  'sparse' the sparse array method (heavily memory reduced)
  The selection can be distinguished by:
  TS.SolutionMethod orig|mem

* The mem solution method has been completely rewritten
  It accomodates full sparsity patterns for all arrays which does
  not need the full order of the matrix.
  For direct comparison these are the changes:
  1. Old TS code:
    - Full matrices:
        H, S, DM, EDM, DMR, EDMR, DMneqL, DMneqR
        GF_inv, GF
    - Global sparse matrices (in super cell pattern)
        H, S, DM, EDM, update_list, region_list
    - Local sparse matrices
        DM, EDM, H, S, update_list, region_list
    - Electrodes
        Gamma arrays are complex
  2. New memory reduced code:
    - Full matrices:
        GF_inv, GF
    - Global sparse matrices (in unit-cell pattern)
        H, S  
    - Global sparse matrices (in update-unit-cell pattern)
        DM, EDM, DMR, EDMR, DMneqL, DMneqR
    - Local sparse matrices
        DM, EDM, H, S
    - Electrodes
        Gamma arrays are real (they have no imaginary part)

  This will leave a memory foot-print well below 50% of what it was.
  For regular systems, it will even be on the order of 25% of what it was.

  The speed of the new routines are not extremely fast, they need some more
  optimizations and they mainly lack speed due to BLAS operations not enabled.
  The looping and checking in the constructs for the TS update region is 
  probably causing the slow execution.

  The memory reduced method does not show as much information regarding the
  charges. However, it shows the charges:
  1. Before the first Transiesta iteration
  2. After the last Transiesta iteration (in siesta_forces)
  TODO add distinguishing between update and non-update region.

  * REMARK * The solution method has been tested on a couple of systems.
  It seems that the execution is stable and provides reliable results,
  however, we need more testing!

* In order to fulfil the above memory reduced creations we need some new 
  routines.
  1. A sparsity pattern creator which can down-fold a super cell pattern
     into a unit cell pattern.
     This is straight forward as that can be performed by down-folding
     all values in list_col into the unit cell and then remove any duplicates.
     * NOTE * the new Transiesta routines are heavily relying on the fact
              that the unit cell pattern of list_col is sorted in each row entry. 
	      Hence the sparsity creator will automatically sort the entries.
	      This also makes sense for the unit cell sparsity pattern.
  2. A sparsity pattern creator which takes a MASK to select which entries
     should be copied to the new sparsity.
     This will NOT sort the list_col entries per row, as one does not know
     about the existence of any super cell entries. However, it retains
     the order of entries.

* A new module has been added which adds some generic "missing" routines
  in fortran.
  We here list some of the functions:
     VNORM : (norm of vector, when called on matrix it returns the 
              column wise norm in a vector of same dimension as DIM=2)
     SORT  : sorts an array (int only)
     UNIQ  : returns all unique elements of an array (int only)
     UNIQC : returns the number of unique elements of an array (int only)
     SFIND : finds an element of an sorted array (int only)
     MODP  : a ceiling version of the MOD, operator (int only)
     EYE   : returns the identity matrix of all kinds

  It is completely separable and should always be kept as such.
  For further information, see the details in the module.

* Added a new module geom_helper.
  This should aid in the search for various values in the SIESTA
  sparsity pattern via look-ups.
  1. the iaorb array (returns the atom which an orbital resides
     on) is easily reached by searching in the lasto array.
     Note, it does so by guessing the atom number from the number
     of orbitals on the first atom, hence it searches fast.
  2. the indexuo array (which returns the unit cell equivalent
     orbital from a super cell index) can easily be checked by
     MODP (from intrinsic_missing)
     Here we name the function UCORB 
  3. ucell_nnn, returns the index of the ucell in the super cell
     construct. I.e. the transfer matrix index in all directions.
     There are equivalent routines for obtaining in any direction.
     ucell_nx, ucell_ny, ucell_nz, ucell_n (takes an extra argument)

* Made some cosmetic changes for conforming with 80 line width.
  And cleaned up the old m_ts_scattering

* Added the completion of only computing GF(2,2) when UpdateDMRC == .TRUE.
  and UseBulk == .TRUE.
  This means that the inversion routine will be much faster when not needing 
  to update cross-terms between left-centre and centre-right electrodes regions.
  Note that for bias calculations this can not be used (and is not used).
  However, we differentiate when it can be used, so that equilibrium energy
  points can utilize the smaller inversion technique. This speeds up
  Transiesta by quite a bit.
  This now exists both in the "old" TS and the memory reduced TS which makes
  both run faster.

* Added an integer array for the Array1D, Array2D and their sparse 
  equivalents.
  TODO: rename all files to class_T_{Array[12]D|SpArr[12]D} to be able
  to easily decipher that it contains all types.

* Removed unnecessary array workcmplx in Transiesta
  Fixed various spurious constructs ( double negation in ifs are not
  easy to understand)

* Added TRANSIESTA_TIMING flags for direct comparison between the solution
  methods of Transiesta. This flag should only be used when debugging, etc.
  This has shown that there needs to be worked on the expansion routines
  in the new sparsity method. If they are leveraged in utilization we
  can gain some more speed in Transiesta.

* TBTrans_rep has been removed the need for fdf_global_get (fdf is parallel)
  Also the calculation of PDOS has been corrected with the overlap conjugate
  This needs to be checked, however, it makes much more sense!
  The memory reduced methods has not been transferred to TBTrans. Currently
  TBtrans need not be considered "heavy" on the memory usage.

* REMARK, before release all TS tests needs to be redone.
  The transmission from the TBTrans and TBTrans_rep are not the same.
  TBTrans has a spin-factor meaning that that will give the double of the
  transmission. That is not the correct way.

* Updated the manual to reflect the changes

added:
  Src/create_Sparsity_SC.F90
  Src/geom_helper.f90
  Src/intrinsic_missing.f90
  Src/m_ts_mem.F90
  Src/m_ts_mem_scat.F90
  Src/m_ts_mem_sparsity.F90
modified:
  Docs/siesta.tex
  Src/Makefile
  Src/class_Sparsity.F90
  Src/class_lsdczArray1D.F90
  Src/class_lsdczArray2D.F90
  Src/class_lsdczSpArr1D.F90
  Src/class_lsdczSpArr2D.F90
  Src/compute_dm.F
  Src/m_ts_contour.f90
  Src/m_ts_electrode.F90
  Src/m_ts_gf.F90
  Src/m_ts_in_siesta.F
  Src/m_ts_options.F90
  Src/m_ts_scattering.F
  Src/siesta_forces.F
  Util/TBTrans/Makefile
  Util/TBTrans_rep/Makefile
  Util/TBTrans_rep/m_tbt_kpoints.F90
  Util/TBTrans_rep/m_tbt_options.F90
  Util/TBTrans_rep/tbtrans.F90

----------------------------------------------------
Mar 16, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-6
Changed the class_* classes for more future integrity

* The creation of several type-classes has been streamlined
  - Each class_<basetype> where <basetype> is:
    Array1D, Array2D, SpArr1D, SpArr2D.
    has been transformed to be generated from a single 
    file for all types.
    See class_lsdcz<basetype> which collects the
    creation of all data-types into one single file.
    TODO, the context could be cleared up, however, 
    the replication in code is very limited.

* Added a logical array for Array[12]D and SpArr[12]D

* basic_type.inc has recieved concatenation for the name 
  attribute in the parent class.
  Hence any classes created by this basic_type requires a "name"
  field to be processed. 
  This is a minor additon that helps printing out information
  about types.

* class_Sparsity has recieved some new additions
  - Two new fields "ncols" and "ncols_g" has been added.
    When an object is created they can be optionally passed down.
    If they are NOT passed, the value "nrows_g" will be used in both
    instances (which constitute a block-cyclic distribution).
  - The field-getters of the integer fields in the object has
    been made to PURE functions. This enables the use of them
    in routine interfaces.
    * NOTE * doing debugging of these routines if apted to change
    could be trouble some. PURE routines does not allow PRINT,WRITE
    statements (nor calls to UNPURE routines)
  - Interfaces for retrieving specific indices of arrays in the object
    has been added, the input variables are given specific names to
    be more descriptive
  - The printSparsity has been added information about the sparsity of
    the array. If "ncols_g" is set then the sparsity can be considered
    correct all the time. (on multiprocess runs one needs to sum, the
    sparsity number on all processors to get the correct sparsity, hence
    the sparsity is the local-nnzs/global size.
    The field is shown to 4 significant digits, which should be enough.

* class_Geometry has been re-indented (for code structure)
  Thus many lines have *changed*.
  The following is what has been added:
  - field-getters "cell" and "isa" which returns the "cell" or "isa"
    arrays has been added
  - All field-getters has been added the index-equivalent specification
    of the retrival. Hence "coords(g,2)" returns the coords of the 
    second atom in the geometry.
  - The field-getter "na" is PURE so that it can be used in interfaces

* class_SpArr[12]D has changed many of the field-getters to be PURE
  in the case that they only return integers.
  This means that they can be used in interfaces of routines.

  Have removed the initialization of the arrays on creation.
  Thus it is up to the developer to initialize arrays if needed.
  This will actually clear-up the code as the purpose of the array
  is apparent.

  TODO : many field-getters in class_Sparsity has been 
  added, we need to add them here as well. However, it seems like there
  should be a class_Sparsity.inc for any classes that wish
  to retain direct interaction on the parent object level.
  That is, routines of direct sparsity access:
    nnzs(class_SpArr1D)
  I.e. a common include graph which accesses the this%data%sp
  field and calls the appropriate sparsity routine.
  (This will come in handy when doing multitude of changes, as
  has been done now.)

* class_SpArr2D has recieved some additional features
  When creating an object from a distribution and sparsity
  pattern, one now has the possibility to decide which dimension
  gets attached the sparse layout (before it was the first dimension)
  This now enables an easy creation of "xa" sparsity arrays which has
  the correct sparsity layout.

* Makefile has been stripped of beginning line HASH marks on empty lines.
  They had no purpose and made stepping in the file incredibly hard!

removed:
  Src/class_sdczArray1D.F90
  Src/class_sdczArray2D.F90
  Src/class_sdczSpArr1D.F90
  Src/class_sdczSpArr2D.F90
added:
  Src/class_lsdczArray1D.F90
  Src/class_lsdczArray2D.F90
  Src/class_lsdczSpArr1D.F90
  Src/class_lsdczSpArr2D.F90
modified:
  Src/Makefile
  Src/basic_type.inc
  Src/class_Array1D.T90
  Src/class_Array2D.T90
  Src/class_Geometry.F90
  Src/class_SpArr1D.T90
  Src/class_SpArr2D.T90
  Src/class_Sparsity.F90

----------------------------------------------------
Mar 8, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-5
Added TSDM update region writeout with TRANSIESTA_DEBUG

* When -DTRANSIESTA_DEBUG is supplied a new file:
  <syslabel>.TSORB_UP is created.
  This holds the matrix elements which are updated
  in the following format:
  no_u no_u
  <row> <col> <-1|1> 
  <row> <col> <-1|1> 
  ...

  where -1 means not updated, and 1 means updated.
  This is very useful when checking against the updated
  region. Mainly for future debugging and region abstraction
  methods.

* Indentations in the class_* files

modified:
  Src/Makefile
  Src/class_Array2D.T90
  Src/class_Sparsity.F90
  Src/m_ts_in_siesta.F

----------------------------------------------------
Mar 7, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-4
Diverged the SpMatrix class to separate Dimension classes

* Have fully clarified the dimension, and sparsity scheme
  of the *old* SpMatrix class as well as the *Array2D* class
* Instead of having files constituting the full precision
  and type regime for the classes we have abstracted it to:
  - class_[sdcz]Array[12]D
    * TODO, consider renaming to [...]Arr[12]D?
  - class_[sdcz]SpArr[12]D (instead of SpMatrix and SpVector)
* The class creations are formed by the files:
  class_sdczArray[12]D which abstract the modules by 
  preprocessor flags. This requires several #define #undef 
  lines, however, it is clearer to collect these routines
  to a united code segment.
* All references to the *old* SpMatrix has been removed 
  and updated to dSpArr2D (which is the fully equivalent)
  This also holds for the FStack and Pair classes!
* The subroutine names of SpMatrix has changed from
  <prefix>SpMatrix<suffix> to <prefix>dSpArr2D<suffix> naming 
  scheme
  - TODO, probably this should be generalized in some way?
  - TODO, is this prefered? It directly says what it reads
    however, I much prefer, "<prefix>_dSpArr2D_<suffix>" for 
    clarification of datatype and inline reading.
* Removed unnecessary nullification of pointers which
  are directly associated afterwards

* Added *exact* copy pastable coordinates if the electrodes
  are not coinciding. The only requirement is that the first
  atom HAS to be located in the correct place. 
  I.e. we locate all other atoms with respect to the first
  electrode-atom in a TranSIESTA cycle.
* Added GF checks in the m_ts_options routine:
  - Generally it will be adviced that non-bias runs
    with the same electrodes on the left- and right-hand
    side use the same GF (for computational efficiency)
  - Hence we do the following checks:
    If the user requests the same left and right GF we
    can check:
    - If Bias /= 0.0 we die
    - If Left TSHS file /= Right TSHS file we die
    - If requested number of atoms are not the full 
      electrode file! (the partition of the GF is not 
      the same for left/right)
  - Will also notify the user about the option
    to do this if the conditions are meet.
  
removed:
  Src/class_SpMatrix.F90
  Src/class_cArray1D.F90
  Src/class_cArray2D.F90
  Src/class_dArray1D.F90
  Src/class_dArray2D.F90
  Src/class_sArray1D.F90
  Src/class_sArray2D.F90
  Src/class_zArray1D.F90
  Src/class_zArray2D.F90
added:
  Src/class_SpArr1D.T90
  Src/class_SpArr2D.T90
  Src/class_sdczArray1D.F90
  Src/class_sdczArray2D.F90
  Src/class_sdczSpArr1D.F90
  Src/class_sdczSpArr2D.F90
modified:
  Src/Makefile
  Src/class_Array1D.T90
  Src/class_Array2D.T90
  Src/class_Fstack_Pair_Geometry_SpMatrix.F90
  Src/class_Pair_Geometry_SpMatrix.F90
  Src/compute_EKS_Harris.F90
  Src/extrapolateSpMatrix.F90
  Src/m_new_dm.F90
  Src/m_ts_electrode.F90
  Src/m_ts_options.F90
  Src/readSpMatrix.F90
  Src/restructSpMatrix.F90
  Src/setup_H0.F
  Src/setup_hamiltonian.F
  Src/siesta_init.F
  Src/sparse_matrices.F
  Src/state_analysis.F
  Src/state_init.F

----------------------------------------------------
Mar 5, 2013 -- Nick P. Andersen     trunk-432-scf-40--ts-scf-3
TBTrans_rep fix for the new sparsity modules and MPI

* Renamed all DAT_Double references to MPI_Double_precision
* Added dependency on the sparsity modules (albeit they are
  not used, they will eventually)

modified:
  Util/TBTrans_rep/Makefile
  Util/TBTrans_rep/m_tbt_iotshs.F90
  Util/TBTrans_rep/m_tbt_read_tshs.F90

----------------------------------------------------
Mar 5, 2013 -- Nick P. Andersen     trunk-432--ts-scf-2
Added sparsity index retrieval by supplying an index

* Added sparsity index retrieval for the arrays:
  - n_col
  - list_ptr
  - list_col
  simply pass two arguments to the functions
  - n_col(s,idx)
  - list_ptr(s,idx)
  - list_col(s,idx)
* Removed all fdf_global_get in m_ts_options

modified:
  Src/class_Sparsity.F90
  Src/m_ts_options.F90

----------------------------------------------------
Feb 25, 2013 -- Nick P. Andersen     trunk-432--ts-scf-1
Initial commit, separated Array2D into precision and datatypes

* The need for generalizing the Array2D to different precision
  and data-types was apparent.
  Furthermore, the need for 1D cases has been met.
  - The naming scheme has been chosen to follow that of general
    data type schemes, they are:
    - sArray[12]D = single real
    - dArray[12]D = double real
    - cArray[12]D = single complex
    - zArray[12]D = double complex
* Added routines to alloc.F90:
  - realloc_1c, realloc_2c
  - realloc_1z, realloc_2z
  - dealloc_1c, dealloc_2c
  - dealloc_1z, dealloc_2z
  to accomodate the new datatypes in the [sdcz]Array[12]D types.
* The creation of objects through "newArray2D" has been changed
  to also require the precision/datatype declaration.
  This will clarify the object inheritance and make codes clear. 
* Removed the old single data-type array type Array2D
* All routines dependent on "Array2D" has now changed to "dArray2D"
* Trying to bypass the naming scheme by using preprocessor concatenators
  has proven unsuccessfull.

  The reason seems to be the expansion order.
  
  Thus there are many preprocess definitions containing the same words,
  this seems inificient, but necessary.

* We could change all alloc routines/Array[12]D codes to be generated through
  simple bash-scripts.

removed:
  Src/class_Array2D.F90
added:
  Docs/TS-scf.CHANGES
  Src/basic_func.inc
  Src/class_Array1D.T90
  Src/class_Array2D.T90
  Src/class_cArray1D.F90
  Src/class_cArray2D.F90
  Src/class_dArray1D.F90
  Src/class_dArray2D.F90
  Src/class_sArray1D.F90
  Src/class_sArray2D.F90
  Src/class_zArray1D.F90
  Src/class_zArray2D.F90
modified:
  Src/Makefile
  Src/alloc.F90
  Src/class_SpMatrix.F90
  Src/extrapolateSpMatrix.F90
  Src/m_new_dm.F90
  Src/readSpMatrix.F90
  Src/restructSpMatrix.F90
