#!/usr/bin/env python

# Should make it "backwards" compatible down to 2.6
from __future__ import print_function

# This small utility can save a scipy sparse
# matrix in a NetCDF-4 file readable by tbtrans
# and hence you can gain access to a transport code
# without having to code the essentials.
# However, this also means that you do need
# to follow some strict rules.
# In the following several classes are made available
# to ease the creation of TB models for TBtrans.

# class TBT_TB
#   this class handles the saving of the TB model.
#   It requires a geometry formatted as TBT_Geom
#   and two csr-formatted sparse matrices (H and S)
#   Call the function .save(fname)
#   to save a NetCDF-4 file readable by tbtrans.

# class TBT_Geom
#   Handles geometries and is a quite powerful geometry
#   handler.
#   It enables a user to construct repeated cells for
#   tbtrans.
#   Specifically it allows one to easily find the 
#   neighbours of certain atoms by this easy call:
#     idx = TBT_Geom.close_all(ia,(1.,2.,3.))
#   which returns 3 index arrays (len(idx) == 3) which specifies:
#     idx[0] : all atoms within <= 1. of atom ia
#     idx[1] : all atoms within <= 2. of atom ia, but farther
#              away than 1. (1. < xa[:,:] - xa[ia,:][None,:] <= 2.)
#     idx[2] : all atoms within <= 3. of atom ia, but farther
#              away than 2. (2. < xa[:,:] - xa[ia,:][None,:] <= 3.)
#   With this call it is extremely easy to get nearest neighbours
#   etc. from a simple geometry.
#   You can repeat or tile the structure by these calls:
#     new_Geom = TBT_Geom.tile((0,3),(2,2))
#   which takes the geometry and repeats the entire structure
#   3 times in the x-direction, then those repeated cells
#   2 times in the z-direction. (thus the total size will be
#   3*2 * TBT_Geom.na_u
#     TBT_Geom.repeat()
#   works in the same way but enables one to utilize
#   Bloch enabled electrodes.
#   You can also remove certain atoms from the structure,
#   just do:
#     new_Geom = TBT_Geom.remove(np.arange(3))
#   which removes the first 3 atoms.
#
#   NOTE: The geometry class expects coordinates in Ang.

# The difficult class
# class TB_Model
#   This class solely handles the assignment of TB parameters
#   for the model.
#   To create a model simply pass a TBT_Geom to the initialization.
#   and the object will be setup correspondingly.
#     model = TBT_Model(TBT_Geom())
#   The only thing you need to do now is assigning 
#   TB parameters to the model.
#     model[i,j] = (H,S) [ H should be in eV ]
#   will create a hopping integral between orbital i and j
#   As the model can use periodicity you also need to
#   create the supercell interactions (it will not do this
#   for you)
#   An easy way is to ask for which sets you should set is
#   to use the geometry object to retrieve the closest
#   atoms and from there create your orbitals.
#   This is extremely easy for single orbital atoms
#   whereas for N orbital atoms this is a little bit more
#   tricky.
#   See the below code for how to construct a TB model for
#   graphene.
#
#   NOTE: It will never allow you to set the same orbital
#         connection twice.
#         Hence, if you do complex TB models you can with
#         benefit set all values for the differing couplings
#         first and then create the common hoppings.
#         As the common hoppings will likely be overlapping one
#         you have already set, it will just ignore updating it.

# PLEASE
# !!!
# Do not edit this file without contributing 
# your edits to the community!
# What is helping you, could MOST likely also
# help others in the community!
# Respect the maintainer, the code and the other users.
# !!!

# Written by: Nick Papior Andersen, 2014

# Load needed modules
import copy, os
import itertools as it
import numpy as np
import scipy.sparse as spar
import netCDF4 as nc

class TBT_TB(object):
    """
    Tight-binding class for writing a NetCDF-4 file
    readable by tbtrans
    """

    # constant fields for converting Ry/Bohr to eV/Ang
    # SIESTA/tbtrans requires Ry and Bohr
    Ry   = 13.60580
    Bohr = 0.529177

    def __init__(self,geom,H,S,Ef=0.):
        """
        initializes the TB-object
        """
        self.geom = geom
        if H.shape[0] != geom.no_u:
            raise ValueError("You have passed an erroneous sparsity"+
                             " pattern to the TB model")
        self.H = H
        self.no_u = int(self.H.shape[0])
        self.H.sort_indices()
        self.S = S
        self.S.sort_indices()
        self.Ef = Ef

    def save(self,fname='SIESTA.nc'):
        """
        Saves the current information in the 'fname'
        to be ready to be read in by tbtrans
        """
        if os.path.isfile(fname):
            raise Exception('File: '+fname+' already exists, we do not allow overwriting.')
        nf = nc.Dataset(fname,'w')

        # Create initial dimensions
        nf.createDimension('one',1)
        nf.createDimension('n_s',np.prod(self.geom.nsc))
        nf.createDimension('xyz',3)
        nf.createDimension('no_s',np.prod(self.geom.nsc)*self.no_u)
        nf.createDimension('no_u',self.no_u)
        nf.createDimension('spin',1)
        nf.createDimension('na_u',self.geom.na_u)

        # Create common variables
        v = nf.createVariable('nsc','i4',('xyz',))
        v.info = 'Number of supercells in each unit-cell direction'
        v = nf.createVariable('lasto','i4',('na_u',))
        v.info = 'Last orbital of equivalent atom'
        v = nf.createVariable('Ef','f8',('one',))
        v.info = 'Fermi level'
        v.unit = 'Ry'
        v = nf.createVariable('Qtot','f8',('one',))
        v.info = 'Total charge'
        v = nf.createVariable('xa','f8',('na_u','xyz'))
        v.info = 'Atomic coordinates'
        v.unit = 'Bohr'
        v = nf.createVariable('cell','f8',('xyz','xyz'))
        v.info = 'Unit cell'
        v.unit = 'Bohr'

        # Create attribute
        nf.method = 'python'

        sp = nf.createGroup('SPARSE')
        sp.createDimension('nnzs',self.H.getnnz())
        v = sp.createVariable('isc_off','i4',('n_s','xyz'))
        v.info = "Index of supercell coordinates"
        v = sp.createVariable('n_col','i4',('no_u',))
        v.info = "Number of non-zero elements per row"
        v = sp.createVariable('list_col','i4',('nnzs',))
        v.info = "Supercell column indices in the sparse format"
        v = sp.createVariable('S','f8',('nnzs',))
        v.info = "Overlap matrix"
        v = sp.createVariable('H','f8',('spin','nnzs'))
        v.info = "Hamiltonian"
        v.unit = "Ry"

        # We need to fake some BZ sampling... 
        # This will probably force the
        # user to utilize the check-kgrid F
        # in the electrodes.... well....
        st = nf.createGroup('SETTINGS')
        v = st.createVariable('ElectronicTemperature','f8',('one',))
        v.info = "Electronic temperature used for smearing DOS"
        v.unit = "Ry"
        v = st.createVariable('BZ','i4',('xyz','xyz'))
        v.info = "Grid used for the Brillouin zone integration"
        v = st.createVariable('BZ_displ','i4',('xyz',))
        v.info = "Monkhorst-Pack k-grid displacements"
        v.unit = "b**-1"

        # Save quantities
        nf.variables['nsc'][:] = self.geom.nsc
        nf.variables['lasto'][:] = self.geom.lasto[1:]
        nf.variables['Ef'][:] = self.Ef / self.Ry
        nf.variables['Qtot'][:] = self.no_u
        
        nf.variables['xa'][:,:] = self.geom.xa[:,:] / self.Bohr
        nf.variables['cell'][:,:] = self.geom.cell[:,:] / self.Bohr

        # Get sparse format
        ptr, ind = self.H.indptr,self.H.indices
        ncol = np.diff(ptr)
        sp.variables['isc_off'][:] = self.geom.isc_off
        sp.variables['n_col'][:] = ncol
        sp.variables['list_col'][:] = ind[:] + 1 # to get to fortran indexing

        # Save data
        sp.variables['H'][:] = self.H.data[:] / self.Ry
        # currently we do not check whether the 
        # sparsity patterns are the same, but they HAVE to be!
        sp.variables['S'][:] = self.S.data[:]

        # Just to ensure that it is not a Gamma
        # point calculation
        st.variables['BZ'][:] = np.identity(3) * 2
        st.variables['BZ_displ'][:] = np.zeros([3],np.float)

        st.variables['ElectronicTemperature'][:] = 0.025 / self.Ry

        nf.close()

# According to 
#  PRB. 81, 245402 (2010)
# we define A-G different sets of
# TB parameters for graphene.
# Our models will from this create a 
# TB input file for tbtrans
_TB_graphene = {
    # set A
    'A' : {
        # Nearest neighbour
        'n1' : -2.7, 
        # next nearest neighbour
        'n2' : 0. ,
        # next-next nearest neighbour
        'n3' : 0. ,
        # overlap (same as neigbour intgers)
        's1' : 0. ,
        's2' : 0. ,
        's3' : 0. ,
        # hopping to an armchair edge 
        'eA' : -2.7,
        'eZ' : -2.7,
        # Hubbard U
        'U'  : 0. ,
        },
    }
# Define set B
_TB_graphene['B'] = copy.deepcopy(_TB_graphene['A'])
_TB_graphene['B']['U'] = 2.0
# Define set C
_TB_graphene['C'] = copy.deepcopy(_TB_graphene['B'])
_TB_graphene['C']['n2'] = -0.2
# Define set D
_TB_graphene['D'] = copy.deepcopy(_TB_graphene['C'])
_TB_graphene['D']['n3'] = -0.18
# Define set E
_TB_graphene['E'] = copy.deepcopy(_TB_graphene['D'])
_TB_graphene['E']['eA'] = 1.06 * _TB_graphene['E']['n1']
_TB_graphene['E']['eZ'] = 1.03 * _TB_graphene['E']['n1']
# Define set F
_TB_graphene['F'] = copy.deepcopy(_TB_graphene['D'])
_TB_graphene['F'].update({
        'n2' : -0.09 ,
        'n3' : -0.27 ,
        's1' : 0.11 ,
        's2' : 0.045,
        's3' : 0.065,
        })
# Define set G
_TB_graphene['G'] = copy.deepcopy(_TB_graphene['D'])
_TB_graphene['G'].update({
        'n1' : -2.97 ,
        'n2' : -0.073,
        'n3' : -0.33 ,
        's1' : 0.073,
        's2' : 0.018,
        's3' : 0.026,
        'U'  : 0.   ,
        })

class TBT_Geom(object):
    """
    A geometry object handling atomic coordinates
    in a supercell
    """
    def __init__(self,cell,xa,dR=2.5,lasto=1):
        """
        Initializes a TB geometry which 
        interactively updates the number of supercells
        """
        self.cell = cell
        self.xa = xa
        self.na_u = len(xa)
        if isinstance(lasto,int):
            # We have a fixed number of orbitals per
            # atom
            self.lasto = np.arange(self.na_u+1) * lasto
        else:
            # The user have specified number of orbitals
            # per atom, explicitly
            self.lasto = np.cumsum(
                np.append(np.array([0],np.int),np.array(lasto,np.int)))
        self.no_u = int(self.lasto[-1])

        # Force the calculation of the super-cells from an orbital
        # range consideration
        self.update_sc(dR=dR)

    def update_sc(self,dR=None):
        """ Re-calculates the super-cell based on maximal interaction range """
        if dR is None:
            # Just update the super-cell, this is
            # if the user has changed the cell size
            ddR = self.dR
        else:
            self.dR = dR
            ddR = dR

        nsc = np.zeros([3],np.int)
        # loop over x-y-z directions
        for d in [0,1,2]:
            # create diagonal offset
            sc = np.zeros([3],np.int)
            # We need only check in the positive direction 
            # after all, it is periodic
            i = 0
            while True:
                i += 1
                sc[d] = i
                for ia in xrange(self.na_u):
                    if len(self.close_sc(ia,isc=sc,dR=ddR)) > 0:
                        nsc[d] = i
                        break
                # No interactions to auxiliary cell,
                # so break the search
                if nsc[d] < i: break
        # We have now calculated the required size
        # Re-set the nsc and the supercell indices
        # (correct for super-cells)
        self.nsc = nsc * 2 + 1
        # This variable determines the supercell
        self.isc_off = np.zeros([np.prod(self.nsc),3],np.int)

        # We define the following ones like this:
        x = range(-nsc[0],nsc[0]+1)
        y = range(-nsc[1],nsc[1]+1)
        z = range(-nsc[2],nsc[2]+1)
        i = 0
        for iz in z:
            for iy in y:
                for ix in x:
                    if ix == 0 and iy == 0 and iz == 0:
                        continue
                    # Increment index
                    i += 1
                    # The offsets for the supercells in the
                    # sparsity pattern
                    self.isc_off[i,0] = ix
                    self.isc_off[i,1] = iy
                    self.isc_off[i,2] = iz

    def xyz(self,fname=None,species='H'):
        """
        Creates an xyz file for showing in visual programs
        """
        if fname:
            # In case the atm_labels is a string we expand it
            if isinstance(species,str):
                lbl = [species] * self.na_u
            else:
                lbl = species
            with open(fname,'w') as fh:
                fh.write(str(self.na_u)+'\n\n')
                for ia in xrange(self.na_u):
                    fh.write(lbl[ia]+' {0:.5f} {1:.5f} {2:.5f}\n'.format(*self.xa[ia,:]))

        
    def copy(self):
        """
        Returns a copy of this Geometry
        """
        # Create a copy of this geometry
        return TBT_Geom(np.copy(self.cell),np.copy(self.xa),
                        dR=self.dR,lasto=self.lasto[1])

    def remove(self,idx_a):
        """
        Removes the atoms corresponding to idx_a and returns a new geometry.
        Indices passed *MUST* be unique.
        """
        xa = np.copy(self.xa)
        # truncate atoms requested
        xa = xa[np.setdiff1d(np.arange(self.na_u),idx_a,assume_unique=True),:]
        return TBT_Geom(np.copy(self.cell),xa,dR=self.dR,lasto=self.lasto[1])

    def tile(self,*args):
        """ 
        Returns a geometry expanded in terms of the arguments

        In contrast to self.repeat this takes the entire unit-cell
        and repeats in blocks.
        """
        if len(args) == 0: return self.copy()
        cell = np.copy(self.cell)
        for id, r in args: 
            cell[id,:] *= r
        # Pre-allocate geometry
        # Start the repetition
        xa = np.copy(self.xa)
        # Our first repetition *must* be with
        # the later coordinate
        ja = 0
        frR = 1
        toR = 1
        for id, r in args:
            toR *= r
            # Copy the entire structure
            xa = np.tile(xa,(r,1))
            # Single cell displacements
            dx = np.dot(np.arange(r)[:,None],self.cell[id,:][None,:])
            # Correct the unit-cell offsets
            xa[ja:ja+self.na_u*toR,:] += np.repeat(dx,frR*self.na_u,axis=0)
            frR *= r
        # Create the geometry and return it
        return TBT_Geom(cell,xa,dR=self.dR,lasto=self.lasto[1])

    def repeat(self,*args):
        """
        Returns a geometry expanded in terms of the arguments
        
        The *args list must have the following format:
          [(0,4),(1,3)]
        which means:
        1. loop over atoms in the geometry 'ia'
        2. Repeat 'ia' atom 4 times along the first vector (python is 0 index based)
        3. Repeat 'ia' atom 3 times along the second vector
        
        In essence is the expansion like this:
        ja = 0
        for ia in range(self.na_u):
            for id,r in args:
               for i in range(r):
                  ja = ia + cell[id,:] * i
        """
        if len(args) == 0: return self.copy()

        # Figure out the size
        R = 1
        nsc = np.copy(self.nsc)
        cell = np.copy(self.cell)
        for id, r in args: 
            cell[id,:] *= r
            # When we repeat a cell we also remove some
            # periodicity, this should take care of 
            # this (but it will still hold the
            # periodicity for simple structures)
            if nsc[id] > 3: nsc[id] -= 2
            R *= r
        # Pre-allocate geometry
        xa = np.zeros((self.na_u*R,3),np.float)
        # Start the repetition
        ja = 0
        for ia in xrange(self.na_u):
            toR = 1
            frR = 1
            for id, r in args:
                toR *= r
                # Single atom displacements
                dx = np.dot(np.arange(r)[:,None],self.cell[id,:][None,:])
                # First copy the previous coordinates
                xa[ja:ja+toR,:] = np.tile(xa[ja:ja+frR,:],(frR,1))
                # We repeat the cell displacements
                xa[ja:ja+toR,:] += np.repeat(dx,frR,axis=0)
                frR *= r
            # Add the basic atomic coordinate
            xa[ja:ja+toR,:] += self.xa[ia,:]
            ja += toR
        # Create the geometry and return it
        return TBT_Geom(cell,xa,dR=self.dR,lasto=self.lasto[1])

    def a2o(self,ia):
        """
        Returns an atomic index to the first orbital of said atom
        This is particularly handy if you want to create
        TB models with more than one orbital per atom.

        Then assigning TB parameters look something like:
        (here shown for two orbitals per atom)

        # Only nearest neighbour interactions
        dR = (.1, 2.)
        for ia in xrange(self.na_u):
            io = self.a2o(ia)
            idx_a = HUGE.close_all(ia,dR=dR)
            # first orbital on-site
            HS[io+0,self.a2o(idx_a[0])+0] = (U1 ,   1. )
            # second orbital on-site
            HS[io+1,self.a2o(idx_a[0])+1] = (U2 ,   1. )
            # orbital hopping to same orbital
            HS[io+0,self.a2o(idx_a[1])+0] = (t11,   0. )
            HS[io+1,self.a2o(idx_a[1])+1] = (t22,   0. )
            # orbital hopping to differing orbital
            HS[io+0,self.a2o(idx_a[1])+1] = (t12,   0. )
            HS[io+1,self.a2o(idx_a[1])+0] = (t12,   0. )

        """
        return self.lasto[ia]

    def coords(self,isc=[0,0,0]):
        """
        Returns the coordinates of the geometry in the specified
        cell
        """
        offset = self.cell[0,:] * isc[0] + \
            self.cell[1,:] * isc[1] + \
            self.cell[2,:] * isc[2]
        return self.xa + offset[None,:]

    def sc_idx(self,isc):
        """
        Returns the geometry index for the supercell
        corresponding to isc ([ix,iy,iz])
        """
        asc = np.array(isc,np.int)
        for i in xrange(self.isc_off.shape[0]):
            if np.all(self.isc_off[i,:] == asc): return i
        raise Exception('Could not find supercell index')

    def close_sc(self,ia,isc=[0,0,0],dR=None):
        """
        Returns all atoms that are within 'dR' of the atom 'ia'
        seen from the unit-cell.

        This allows one to easily create TB models

        If dR has several elements it will return the indices:
        in the ranges:
           ( x <= dR[0] , dR[0] < x <= dR[1], dR[1] < x <= dR[2] )
        """
        if dR is None:
            ddR = np.array((self.dR,),np.float)
        else:
            ddR = np.array((dR,),np.float).flatten()
        # Get atomic coordinate in principal cell
        dxa = self.coords(isc=isc) - self.xa[ia,:]
        # Retrieve all atomic indices which are closer
        # than our delta-R
        xaR = np.linalg.norm(dxa,axis=-1)
        idx = np.where(xaR <= ddR[0])[0]
        if len(ddR) == 1:
            # We only have one designation
            return idx
        idx = [idx]
        for i in range(1,len(ddR)):
            idx.append(np.where(np.logical_and(ddR[i-1] < xaR,xaR <= ddR[i]))[0])
        return idx

    def close_all(self,ia,dR=None):
        """
        Returns supercell indices for all atoms connecting to 'ia'
        from within range 'dR'.
        """
        if dR is None:
            ddR = np.array((self.dR,),np.float)
        else:
            ddR = np.array((dR,),np.float).flatten()
        idx_a = None
        for s in xrange(np.prod(self.nsc)):
            no = s * self.na_u
            idx = self.close_sc(ia,self.isc_off[s,:],dR=ddR)
            if isinstance(idx,list):
                # we have a list of arrays
                if idx_a is None:
                    idx_a = [ix + no for ix in idx]
                else:
                    for i,ix in enumerate(idx):
                        idx_a[i] = np.append(idx_a[i],ix + no)
            elif len(idx) > 0:
                # We can add it to the list
                # We add the atomic offset for the supercell 
                # index
                if idx_a is None:
                    idx_a = idx + s * self.na_u
                else:
                    idx_a = np.append(idx_a,idx+s*self.na_u)
        return idx_a
        

class TBT_Model(object):
    """
    A wrapper to create zero containing sparsity patterns
    while easily implementing the symmetric sparsity pattern.
    """
    def __init__(self,geom):
        self.geom = geom
        self.no_u = geom.no_u
        no_s = geom.no_u * np.prod(geom.nsc)
        # A pointer (MUST be zero)
        self.ptr = np.zeros((self.no_u+1,),np.int)
        self.i = 0
        self.col = np.empty((no_s,),np.int)
        self.H = np.empty((no_s,),np.float)
        self.S = np.empty((no_s,),np.float)

    def finalize(self):
        """ Disables the ability to extend this TB sparsity
        pattern
        """
        self.finalized = True
        self.H = self.H[:self.i]
        self.S = self.S[:self.i]
        self.col = self.col[:self.i]
        # Deleting the variable
        # will error out in _setitem when
        # it is referenced :)
        del self.i

    def _setitem(self,i,j,H,S):
        """
        Enables easy setting of TB sparsity pattern
        
        Ok, it is not pretty, it is not fast, but it works!
        """
        # step pointer of all above this
        # if the values already exists, simply return immediately
        if j in self.col[self.ptr[i]:self.ptr[i+1]]: return
        self.col[self.ptr[i+1]+1:self.i+1] = self.col[self.ptr[i+1]:self.i]
        self.H[self.ptr[i+1]+1:self.i+1] = self.H[self.ptr[i+1]:self.i]
        self.S[self.ptr[i+1]+1:self.i+1] = self.S[self.ptr[i+1]:self.i]
        self.col[self.ptr[i+1]] = j
        self.H[self.ptr[i+1]] = H
        self.S[self.ptr[i+1]] = S
        self.ptr[i+1:] += 1
        self.i = self.i + 1
        if self.i == len(self.col) - 1:
            self.col = np.append(self.col,np.empty([self.no_u],np.int))
            self.H = np.append(self.H,np.empty([self.no_u],np.float))
            self.S = np.append(self.S,np.empty([self.no_u],np.float))
        
    def __setitem__(self,key,value):
        """ 
        Set values in a sparsity pattern
        This does NOT allow advanced slicing operations
        only [i,j] assigning
        """
        if isinstance(key[1],int):
            self._setitem(key[0],key[1],value[0],value[1])
        else:
            for j in key[1]:
                self._setitem(key[0],j,value[0],value[1])

    def tocsr(self):
        """
        Returns a csr sparse matrix for both the Hamiltonian
        and the overlap matrix
        """
        try:
            if self.finalized: pass
        except:
            self.finalize()
        # Create csr sparse formats
        return (spar.csr_matrix((self.H,self.col,self.ptr)), \
            spar.csr_matrix((self.S,self.col,self.ptr)))

# Define a generic geometry for a square graphene unit-cell
# To create any arbitrary unit-cell, simple use the repeat
# function. :)
sq3h  = 3.**.5 * 0.5
GR_UC = TBT_Geom(xa=np.array([[ 0.,   0., 0.],
                              [ 2.,   0., 0.],
                              [0.5, sq3h, 0.],
                              [1.5, sq3h, 0.] ],np.float),
                 cell=np.array([[3.,     0.,  0.],
                                [0., 2*sq3h,  0.],
                                [0.,     0., 10.]],np.float),
                 dR=2.05) # third nearest neighbour

def TB_save(fname,Geom,TB = _TB_graphene['D'] ,alat=1.42):
    """ 
    Creates a TB SIESTA.nc file with a system of a geometry.
    It will automatically create a sparsity pattern based
    on the tight-binding parameter set provided through TB.
    """

    # Correct the lattice vector with 
    Geom.xa   *= alat
    Geom.cell *= alat
    Geom.dR   *= alat

    # Print out the differences with respect to the first
    #print('dR from 0: ',np.linalg.norm(Geom.xa-Geom.xa[0,:][None,:],axis=-1))

    # Create the sparsity pattern.
    # The regular scipy sparse patterns does not 
    # allow entering elements with zero value.
    # Hence we need to build it our-selves :(

    # In our one orbital model this will do
    HS = TBT_Model(Geom)

    # When setting the hopping and overlap you do it by 
    # a tuple assignment
    # Hence:
    #   HS[i,j] = (H,S)
    # means that the i'th orbital connecting with the j'th
    # has hopping energy H and overlap S

    # Create tuple of connection ranges (this is for graphene)
    dR = ( alat*0.5 , alat+0.1 , 2*sq3h*alat+0.1 , 2*alat+0.1 )
    # We add all hoppings
    for ia in xrange(Geom.na_u):
        # Retrieve all hoppings (in one go)
        idx_a = Geom.close_all(ia,dR=dR)
        # set all on-site hoppings
        HS[ia,idx_a[0]] = (TB['U'],    1.   )
        # set all nearest hoppings
        HS[ia,idx_a[1]] = (TB['n1'],TB['s1'])
        # set all next-nearest hoppings
        HS[ia,idx_a[2]] = (TB['n2'],TB['s2'])
        # set all next-next-nearest hoppings
        HS[ia,idx_a[3]] = (TB['n3'],TB['s3'])

    # This concludes the sparsity pattern
    # and TB parameters for the graphene TB model.
    # Convert to csr format
    H, S = HS.tocsr()

    # Save data file
    tb = TBT_TB(Geom,H,S,Ef=TB['U'])
    tb.save(fname)

def TB_square():
    """
    This simple example is the same as given in the manual
    for TBtrans.
    So follow the explanations there carefully and you should 
    be able to handle arbitrary systems
    """
    
    # Create a square unit cell with
    # nearest neighbour interactions,
    # and interatomic separation of 1. Ang
    cell = np.identity(3,np.float)
    cell[2,2] = 2.
    SQ = TBT_Geom(xa=np.zeros([1,3],np.float),
                  cell=cell, dR=1.1)
    
    # Extend the square lattice to a
    # 2 by 1 electrode [x by y]
    el  = SQ.repeat((0,2))
    # Create the device by making 1 by 3 times the electrode
    # [ x by y ]
    dev = el.tile((1,3))
    
    # Create the TB models
    TB_el  = TBT_Model(el)
    TB_dev = TBT_Model(dev)
    
    # set TB parameters
    # In the following we set the TB 
    # manually, however, further down we
    # also create them in an easier way
    # The point is to learn how the sparsity pattern
    # is setup.

    U  =  0.
    t1 = -0.5
    # electrode:
    #   on-site
    for io in range(el.no_u):
        TB_el[io,io] = (U,1.)
    #  1 -> 2
    TB_el[0,1] = (t1,0.)
    #  2 -> 1
    TB_el[1,0] = (t1,0.)
    #  1 -> 2 in super-cell [-1,0] and [1,0]
    # First we get supercell offset for the [-1,0] cell
    sc = el.sc_idx([-1,0,0]) * el.no_u
    TB_el[0,sc+1] = (t1,0.)
    sc = el.sc_idx([1,0,0]) * el.no_u
    TB_el[1,sc+0] = (t1,0.)
    # 1 -> 1, 2 -> 2
    #  in super-cell [0,-1] and [0,1]
    sc = el.sc_idx([0,-1,0]) * el.no_u
    TB_el[0,sc+0] = (t1,0.)
    TB_el[1,sc+1] = (t1,0.)
    sc = el.sc_idx([0,1,0]) * el.no_u
    TB_el[0,sc+0] = (t1,0.)
    TB_el[1,sc+1] = (t1,0.)
    
    # This finalizes the TB parameters for a
    # unit-cell with 2 atoms.
    # To recap, each atom connects with 4 
    # neighbouring atoms totalling in us
    # needing to set 8 elements (and we did!)

    # Here I show how the exact same thing can
    # be achieved by using atomic coordinates
    # to determine the integral hoppings,
    # first we define the range of hoppings
    #  on-site hoppings must be of atoms within 0.1 Ang of
    #          other atoms
    #  nearest neighbour hoppings must be of atoms within 1.1 Ang
    #          of other atoms
    #     on-site , nearest neighbour
    dR = (  0.1   ,     1.1          )
    # NOTE, this below loop does EVERYTHING you did above!
    for ia in xrange(el.na_u):
        idx_a = el.close_all(ia,dR=dR)
        # now idx_a is a list of two indices
        #  idx_a[0] is an index list containing all atoms 
        #           connecting to 'ia' within 0.1 Ang
        #  idx_a[1] is an index list containing all atoms
        #           connection to 'ia' within 1.1 Ang
        # Hence we can set the hopping integrals like this
        TB_el[ia,idx_a[0]] = ( U,1.)
        TB_el[ia,idx_a[1]] = (t1,0.)

    # Now we just do the same thing for the device
    for ia in xrange(dev.na_u):
        idx_a = dev.close_all(ia,dR=dR)
        # now idx_a is a list of two indices
        #  idx_a[0] is an index list containing all atoms 
        #           connecting to 'ia' within 0.1 Ang
        #  idx_a[1] is an index list containing all atoms
        #           connection to 'ia' within 1.1 Ang
        # Hence we can set the hopping integrals like this
        TB_dev[ia,idx_a[0]] = (U ,1.)
        TB_dev[ia,idx_a[1]] = (t1,0.)
        
    # And DONE, you have now created your first input for
    # tbtrans with a TB model of a square lattice

    # However, there is one problem...
    # tbtrans cannot handle too small problems.
    # For this square lattice it is too small, and we need it
    # to be wider for it to run (or one could increase the 
    # orbital range)

    # Here we correct the example to a wider system so it can be
    # run by tbtrans (it just needs to be [4 by 3]
    el  = SQ.repeat((0,4))
    dev = el.tile((1,3))
    TB_el = TBT_Model(el)
    for ia in xrange(el.na_u):
        idx_a = el.close_all(ia,dR=dR)
        TB_el[ia,idx_a[0]] = (U ,1.)
        TB_el[ia,idx_a[1]] = (t1,0.)
    TB_dev = TBT_Model(dev)
    for ia in xrange(dev.na_u):
        idx_a = dev.close_all(ia,dR=dR)
        TB_dev[ia,idx_a[0]] = (U ,1.)
        TB_dev[ia,idx_a[1]] = (t1,0.)
    # Now save the TB models to corresponding NetCDF-4 files
    H, S = TB_el.tocsr()
    tb_el = TBT_TB(el,H,S,Ef=0.)
    tb_el.save('SQUARE_EL.nc')
    H, S = TB_dev.tocsr()
    tb_dev = TBT_TB(dev,H,S,Ef=0.)
    tb_dev.save('SQUARE_DEV.nc')
    
if __name__ == '__main__':

    # This example code produces several TB NetCDF-4 files

    # create the simple square hopping integral
    TB_square()

    #TB_save('ELEC_zz.nc',GR_UC.copy())
    
    # We create all TB paramaters for a zz edge 
    # pristine graphene sample:
    for TB in ['A','B','C','D','E','F','G']:
        TB_save('ELEC_' + TB + '_zz.nc',
                GR_UC.copy() , TB = _TB_graphene[TB])
        TB_save('DEV_'  + TB + '_zz.nc',
                GR_UC.tile((1,5)) , TB = _TB_graphene[TB])

    # For the below examples we use the D set and a 
    # lattice constant of 1.42
    TB = _TB_graphene['D']
    alat = 1.42

    # Just for fun, create a graphene flake with a whole in it
    # This is essentially an anti-dot lattice with pristine
    # electrodes
    Nx = 10 ; Ny = 30
    print('Repeating graphene UC to flake with hole containing '+str(Nx*Ny*GR_UC.na_u)+' atoms...')
    HOLE = GR_UC.repeat((0,Nx)).tile((1,Ny))
    print('Correcting lattice parameters for graphene hole...')
    HOLE.xa   *= alat
    HOLE.cell *= alat
    HOLE.dR   *= alat
    # Remove a hole in the structure
    # We take some atom in the middle of the structure
    mid_atom = GR_UC.na_u * (Nx * Ny) / 2
    # Get all indices for all super-cell atoms within 12 angstrom
    idx_a = HOLE.close_all(mid_atom,dR=12.)
    # Convert to unit-cell atomic indices
    idx_a %= HOLE.no_u
    # remove dublicates (in case the user makes a too large hole)
    idx_a = np.unique(idx_a)
    print('Removing '+str(len(idx_a))+' atoms...')
    HOLE  = HOLE.remove(idx_a)
    HS = TBT_Model(HOLE)
    dR = ( alat*0.5 , alat+0.1 , 2*sq3h*alat+0.1 , 2*alat+0.1 )
    print('Creating TB parameter Hamiltonian and overlap...')
    for ia in xrange(HOLE.na_u):
        idx_a = HOLE.close_all(ia,dR=dR)
        HS[ia,idx_a[0]] = (TB['U'] ,   1.   )
        HS[ia,idx_a[1]] = (TB['n1'],TB['s1'])
        HS[ia,idx_a[2]] = (TB['n2'],TB['s2'])
        HS[ia,idx_a[3]] = (TB['n3'],TB['s3'])
    print('Converting to CSR sparsity format and saving NetCDF file...')
    H, S = HS.tocsr()
    tb = TBT_TB(HOLE,H,S,Ef=TB['U'])
    tb.save('HOLE_D_zz.nc')

    # Save an xyz file to let the user view the geometry
    HOLE.xyz('HOLE_zz.xyz',species='C')

    # Just for fun, create a HUGE graphene flake
    Nx = 40 ; Ny = 60
    print('Repeating graphene UC to huge flake containing '+str(Nx*Ny*GR_UC.na_u)+' atoms...')
    HUGE = GR_UC.repeat((0,Nx)).tile((1,Ny))
    print('Correcting lattice parameters for graphene flake...')
    HUGE.xa   *= alat
    HUGE.cell *= alat
    HUGE.dR   *= alat
    HS = TBT_Model(HUGE)
    dR = ( alat*0.5 , alat+0.1 , 2*sq3h*alat+0.1 , 2*alat+0.1 )
    print('Creating TB parameter Hamiltonian and overlap...')
    for ia in xrange(HUGE.na_u):
        idx_a = HUGE.close_all(ia,dR=dR)
        HS[ia,idx_a[0]] = (TB['U'] ,   1.   )
        HS[ia,idx_a[1]] = (TB['n1'],TB['s1'])
        HS[ia,idx_a[2]] = (TB['n2'],TB['s2'])
        HS[ia,idx_a[3]] = (TB['n3'],TB['s3'])
    print('Converting to CSR sparsity format and saving NetCDF file...')
    H, S = HS.tocsr()
    tb = TBT_TB(HUGE,H,S,Ef=TB['U'])
    tb.save('HUGE_D_zz.nc')

    HUGE.xyz('HUGE_zz.xyz',species='C')
