! 
! Copyright (C) 1996-2016	The SIESTA group
!  This file is distributed under the terms of the
!  GNU General Public License: see COPYING in the top directory
!  or http://www.gnu.org/copyleft/gpl.txt.
! See Docs/Contributors.txt for a list of contributors.
!

      program plstm

      use m_gridfunc, only: monoclinic_z
      use m_gridfunc, only: gridfunc_t, read_gridfunc

! This program PLSTM reads a charge density or local density of states
! generated by SIESTA, and simulates STM images at constant-current
! or constant-height mode using the Tersoff-Hamann approximation.

! Written by P. Ordejon, June 2001
!     (basic structure from Plrho package of J.M.Soler)
! Spin capability and restructuring by Alberto GarcÃ­a (March 2019)      

! CAVEATS:
!
! This version works assuming that the scanning plane is the XY plane.
! This plane must be perpendicular to the third lattice vector of
! the supercell (the Z direction).

! USAGE:

! This program reads grid files generated from SIESTA or other programs
! (such as ol-stm), with information on the charge density
! (filename.RHO) or local density of states (filename.LDOS) and computes
! a simulated STM image, in the Tersoff-Hamann approximation. Two modes
! are available: constant-current (simulated by computing a constant
! density surface z=z(x,y)) and constant-height (obtaining the charge
! density at the tip position at a given height).

! The program needs two input files:

! NOTE: This input file is maintained for backward compatibility
!       In the future we might use command-line options
! 1) Main input file, read by standard input. A sample of input file is:

!    --- begin input file ---
!        graf
!        rho
!        constant-current
!        1.d-4
!        unformatted     ! only unformatted for now: could extend to netcdf...
!        {x|y|z|s|q|v}      
!        [required if 'v' used above] tip_1 tip_2 tip_3
!     --- end input file ---

!    where:
!    - The first line is the label of the system, as in SIESTA SystemLabel.
!      Files will be searched as SystemLabel.* (in the example, graf.RHO).
!    - The second line is the task, which should be either rho or ldos
!      (in lowercase!!).
!    - The third line specifies the STM mode: 'constant-current' or
!      'constant-height' (in lowercase). 
!    - The fourth line is a value that determines the details of the
!      STM image. In the case of 'constant-current' mode, this is the
!      value of the density (in units of e/bohr**3). at which the isosurface 
!      is computed. For the 'constant-height' mode, the value specifies
!      the Z (in bohr) level at which the charge is computed.
!    - The fifth line indicates if the grid data file SystemLabel.TASK
!      is formatted or unformatted (the latter being the standard option
!      in SIESTA) -- formatted only for now.
!     - The last line indicates whether the charge (q) or a spin component
!       (x|y|z), or the total spin magnitude (s) is chosen for processing.     
!       By default, 'q' mode is chosen if no last line is specified, to
!       maintain compatibility with the older version of the program.      
!       An extra option 'v', followed by a line with three real numbers, serves to
!       simulate a spin-polarized tip. The scalar product of the "tip spin vector"
!       and the "local spin vector" is recorded at each point.
!     
! 2) SystemLabel.TASK file: this is a file generated by SIESTA, with
!    the values of the appropriate quantity on the grid.
!    In example above: grid.RHO. You should copy it from the directory
!    with your SIESTA output files.

! The program generates some informative output on standard output, and
! writes one file. In the case of 'constant-current' mode, this file's
! name is SystemLabel.*.CC.STM, and contains the X,Y,Z values of the
! isosurface (a grid of X,Y and the value of Z(X,Y) of the
! isosurface). In the case of 'constant-height' mode, the name is
! SystemLabel.*.CH.STM, and contains the values X,Y,RHO for each X,Y of
! the grid, where RHO is the charge (or spin component) computed at the
! point X,Y,Z (Z being the hight specified in the input).
! In the filenames, '*' stands for the 'spin code' (as entered in the last line).
c****************************************************************************

       implicit none

       type(gridfunc_t) :: gf

       integer, parameter :: dp = selected_real_kind(10,100)
       real, allocatable :: rho(:)

! Internal variables
       character
     .   name*75, fform*12, fname*80, oname*80, task*15,
     .   mode*25, spin_code*1
       integer
     .   i, ip, is, j, mesh(3), np, nspin, nt, Ind, iz, iy
       real ::    fvalue, sx, sy, sz
       real ::    fmin, fmax
       real(dp) ::    zmin, zmax
       integer :: iostat, n3
       real(dp) :: cell(3,3), origin(3)
       real(dp) :: tip_spin(3)

! Read plot data
       read(5,*) name
       read(5,*) task
       read(5,*) mode
       read(5,*) fvalue
       read(5,*) fform
       ! Maintain compatibility with older version (charge only)
       read(5,fmt=*,iostat=iostat) spin_code
       if (iostat /=0) then
          write(0,*) "Using 'total charge' ('q') mode"
          spin_code = "q"
       endif
       tip_spin(1:3) = 0.0_dp
       if (spin_code == "v") then
          read(5,*) tip_spin(1:3)
          write(6,"(a,3f10.5)") 'Tip spin: ', tip_spin(1:3)
       endif

       ! Read grid file with LDOS (density in an energy window)

       if (task .eq. 'ldos') then
         fname = trim(name)//'.LDOS'
       else if (task .eq. 'rho') then
         fname = trim(name)//'.RHO'
       else
         stop ' ERROR: Task should be "rho" or "ldos" '
       endif

       write(6,*)
       write(6,*) 'Reading grid data from file ',trim(fname)

       !! SHOULD MAKE SURE OF THE UNITS... although for plots
       !  it should not make much difference
       
       if (fform .eq. 'formatted') then
          ! call read_gridfunc_formatted(fname,gf)
          ! not implemented yet in m_gridfunc
          ! it might be useful for transporting data among computers
          ! without using netcdf
          STOP "formatted option not implemented yet"
       else
          call read_gridfunc(fname,gf)
       endif
       
       np = product(gf%n(1:3))
       nspin = gf%nspin
       cell = gf%cell
       mesh = gf%n
       origin = gf%origin
       
       write(6,*)
       write(6,*) 'Cell vectors (bohr)'
       write(6,*)
       write(6,*) cell(:,1)
       write(6,*) cell(:,2)
       write(6,*) cell(:,3)
       write(6,*)
       write(6,*) 'Grid mesh: ',mesh(1),'x',mesh(2),'x',mesh(3)
       write(6,*)
       write(6,*) 'nspin = ',nspin
       write(6,*)
       write(6,"(a,3f10.5)") 'Box origin (bohr): ', origin(1:3)

       if (.not. monoclinic_z(cell)) then
          write(0,*) 'The cell is not monoclinic with ' //
     $               'c lattice vector along z...'
          stop " *** Unsuitable cell for STM program"
       endif

          ! Note that the last slice with information in the file is
          ! the (n3-1)th plane
          n3 = mesh(3)
          zmax = (n3-1) * cell(3,3) / n3  + origin(3)
          zmin = origin(3)
          write(6,"(a,3f12.5)") "Zmin, Zmax (bohr): ", zmin, zmax

          write(6,*)
       if (mode .eq. 'constant-current') then

          ! It does not make physical sense to get topography
          ! for spin components
          if (spin_code /= "q") then
             STOP "Constant-current mode only available " //
     $            "for 'q' (charge)"
          endif
          !** Check that value is within range
          write(6,*) 'Calculating STM image in Constant Current mode'
          write(6,*) 'The STM image is obtained as the isosurface of'
          write(6,*) 'constant function value =', fvalue,' e/Bohr**3'
          oname = trim(name)// "." // spin_code // '.CC.STM'
         
       else if (mode .eq. 'constant-height') then
         
          write(6,*) 'Calculating STM image in Constant Height mode'
          write(6,*) 'The STM image is obtained as the value of the'
          write(6,*) 'charge at a given tip height Z = ', fvalue, 'Bohr'
          oname = trim(name)// "." // spin_code // '.CH.STM'

          ! Check that value is within range
          if ((fvalue > zmax) .or. (fvalue < zmin)) then
             STOP 'Z requested is beyond box limits'
          endif

       else 
         write(6,*) 'ERROR: mode must be either constant-current'
         write(6,*) '       or constant-height (in lower case)'
         stop
       endif
       write(6,*)

       allocate(rho(product(mesh(1:3))))
       call get_function(nspin, spin_code, mesh, gf%val,
     $                   rho, tip_spin, fmin, fmax)
       write(6,"(a,3f12.5)") "fmin, fmax ", fmin, fmax
       
       if (mode .eq. 'constant-current') then
          if ((fvalue > fmax) .or. (fvalue < fmin)) then
             STOP 'Function value outside range of values in box'
          endif

         ! Generate x,y,z surface (dump to output file)
         call isocharge( cell, origin,
     $                   mesh, rho, fvalue, oname)
       else
         ! Dump slice to output file
         call isoz( cell, origin, mesh, rho, fvalue, oname)
       endif

       deallocate(rho)
       
      end

      subroutine get_function(nspin, spin_code, mesh, f, rho,
     $                        tip_spin, fmin, fmax)

       integer, parameter :: dp = selected_real_kind(10,100)
       integer, parameter :: sp = kind(1.0)

       integer, intent(in)          :: nspin, mesh(3)
       real(sp), intent(in)         :: f(mesh(1)*mesh(2)*mesh(3),nspin)
       character(len=1), intent(in) :: spin_code
       real(dp), intent(in)         :: tip_spin(3)

       real(sp), intent(out) :: rho(mesh(1)*mesh(2)*mesh(3))
       real(sp), intent(out) :: fmin, fmax

       real ::    sx, sy, sz
       integer :: i, np

       np = product(mesh(1:3))
       
       if (nspin == 1) then
          select case (spin_code)
          case ( 'x', 'y', 'z', 's')
             stop "Cannot choose spin for spin-less file"
          case ( 'v')
             stop "Cannot use tip spin for spin-less file"
          case ( 'q')
             rho(:) = f(:,1) + f(:,2)
          end select
       else if (nspin == 2) then
          select case (spin_code)
          case ( 'x', 'y')
             stop "Cannot choose x, y comps for collinear file"
          case ( 'v')
             stop "Cannot use tip spin for collinear file"
          case ( 'q')
             rho(:) = f(:,1) + f(:,2)
          case ( 'z')
             rho(:) = f(:,1) - f(:,2)
          case ( 's')
             rho(:) = abs(f(:,1) - f(:,2))
          end select
       else if (nspin == 4) then
          select case (spin_code)
          case ( 'x' )
             rho(:) = 2.0 * f(:,3)
          case ( 'y' )
             rho(:) = 2.0 * f(:,4)
          case ( 'z')
             rho(:) = f(:,1) - f(:,2)
          case ( 'q')
             rho(:) = f(:,1) + f(:,2)
          case ( 's')
             do i = 1, np
                sx = 2.0 * f(i,3)
                sy = 2.0 * f(i,4)
                sz = f(i,1) - f(i,2)
                rho(i) = sqrt(sx**2 + sy**2 + sz**2)
             enddo
          case ( 'v')
             do i = 1, np
                sx = 2.0 * f(i,3)
                sy = 2.0 * f(i,4)
                sz = f(i,1) - f(i,2)
                rho(i) = tip_spin(1) * sx +
     $                   tip_spin(2) * sy +
     $                   tip_spin(3) * sz
             enddo
          end select
       endif
       fmin = minval(rho)
       fmax = maxval(rho)
      end
      
      ! Some extra optimizations and clarifications are possible in these routines
      ! for a monoclinic cell

      SUBROUTINE ISOCHARGE( CELL, origin, NMESH, F, FVALUE, ONAME)
 
! *******************************************************************
! Calculates the surface z=z(x,y) with constant function value.
! The surface is determined by the condition function=value, and
! it is printed in a file as x,y,z. The function must
! be given in a regular 3-D grid of points.
! Notice single precision in this version
C
! Written by P. Ordejon. June 2001.
!     from plsurf.f (written by J. M. Soler)
! Modified by A. Garcia, March 2019      
! ************************* INPUT ***********************************
! REAL(DP)  CELL(3,3)    : Unit cell vectors CELL(ixyz,ivector)
! INTEGER NMESH(3)     : Number of mesh divisions of each vector
! REAL    F(:,:,:)     : Function such that F=FVALUE determines
!                        the shape of the solid surface.
! REAL    FVALUE       : Value such that F=FVALUE
!                        determines the shape of the solid surface.
! CHARACTER*80 ONAME   : Output file name
! ************************* OUTPUT **********************************
! None. Results are printed on ONAME file
! *******************************************************************

       IMPLICIT NONE
       integer, parameter :: dp = selected_real_kind(10,100)

       INTEGER, intent(in) ::  NMESH(3)
       REAL(DP), intent(in)  ::  CELL(3,3)
       REAL(DP), intent(in)  ::  origin(3)
       REAL    F(0:nmesh(1)-1,0:nmesh(2)-1,0:nmesh(3)-1), FVALUE
       CHARACTER  ONAME*80


! Local variables and arrays
       LOGICAL  HIGH, ZERO
       INTEGER  IC, IX, K1, K2, K3
       REAL(dp) DXDM(3,3), ZK3
       REAL     f_cur, f_up

       OPEN( unit=2, file=oname)
       write(6,*) 'Writing STM image in file ', trim(oname)

! Find Jacobian matrix dx/dmesh and its inverse
       DO IC = 1,3
         DO IX = 1,3
           DXDM(IX,IC) = CELL(IX,IC) / NMESH(IC)
         ENDDO
       ENDDO

       ZERO = .FALSE.

       DO K1 = 0,NMESH(1)-1
          DO K2 = 0,NMESH(2)-1
             ! z-direction is scanned from top to bottom
             ! We assume that the function decreases as z increases
             ! This is reasonable for the charge density, but not
             ! necessarily true for spin components.
             ! We might need to work with absolute values
             DO K3 = NMESH(3)-1,0,-1

                !Find if this point is above FVALUE
                f_cur = f(k1,k2,k3)     
                HIGH = ( f_cur .GT. FVALUE)
 
                if (HIGH) then   ! our point is between k3 and k3+1
                   if (K3 .eq. NMESH(3)-1) then
                      stop 'Surface above box boundary!!!'
                   endif
                   ! Linear interpolation to find z-coordinate of surface
                   f_up = f(k1,k2,k3+1)
                   ! This is a real number in [k3,k3+1]
                   ZK3 = (K3+1) - (FVALUE - f_up) / (f_cur - f_up)
 
                   write(2,*)
     .                  ( DXDM(IX,1) * K1 +
     .                  DXDM(IX,2) * K2 +
     .                  DXDM(IX,3) * ZK3  + origin(ix) , IX=1,3)
             
                   goto 10
                endif

             ENDDO
             ! Note that K3 is zero here, at the end of the loop
             write(2,*)
     .            ( DXDM(IX,1) * K1 +
     .            DXDM(IX,2) * K2 +
     .            DXDM(IX,3) * K3  + origin(ix), IX=1,3)
             ZERO = .TRUE.

 10       ENDDO
          write(2,*) " "
       ENDDO

       CLOSE(2)

       IF (ZERO) THEN
          write(6,*) 'WARNING: I could not find the isosurface'
          write(6,*) '   for some X,Y points. For these, Z = ZMIN (0)'
       ENDIF

       END

       SUBROUTINE ISOZ( CELL, origin, NMESH, F, ZVALUE, ONAME)
 
! *******************************************************************
! Calculates the value of the function F at the plane Z=ZVALUE
! The function must be given in a regular 3-D grid of points.
! Notice single precision in this version
C
! Written by P. Ordejon. June 2001.
! from plsurf.f (written by J. M. Soler)
! ************************* INPUT ***********************************
! REAL(DP)  CELL(3,3)  : Unit cell vectors CELL(ixyz,ivector)
! INTEGER NMESH(3)     : Number of mesh divisions of each vector
! REAL    F(*)         : Function such that F=FVALUE determines
!                        the shape of the solid surface.
! REAL    ZVALUE       : Z level where the function is written
! CHARACTER*80 ONAME   : Output file name
! ************************* OUTPUT **********************************
! None. Results are printed on ONAME file
! *******************************************************************

       IMPLICIT NONE

       integer, parameter :: dp = selected_real_kind(10,100)

       INTEGER, intent(in) ::  NMESH(3)
       REAL(dp), intent(in)  ::  CELL(3,3)
       REAL(dp), intent(in)  ::  origin(3)
       REAL    F(0:nmesh(1)-1,0:nmesh(2)-1,0:nmesh(3)-1), ZVALUE
       CHARACTER  ONAME*80

       INTEGER  IC, IP, IPM, IX, K1, K2, K3
       REAL(dp)     DXDM(3,3), ZK3, zm, z
       REAL    f_cur, f_up, fv

       OPEN( unit=2, file=oname )

       write(6,*) 'Writing STM image in file ', trim(oname)

!     Find Jacobian matrix dx/dmesh and its inverse
       DO IC = 1,3
         DO IX = 1,3
           DXDM(IX,IC) = CELL(IX,IC) / NMESH(IC)
         ENDDO
       ENDDO

! Loop on mesh points
       DO K1 = 0,NMESH(1)-1
          DO K2 = 0,NMESH(2)-1
! z-direction is scanned from top to bottom
             DO K3 = NMESH(3)-1,0,-1

               ! Calculate Z coordinate of this point:
               Z = DXDM(3,1) * K1 + DXDM(3,2) * K2 + DXDM(3,3) * K3 +
     $               origin(3)

               IF (Z .LT. ZVALUE) THEN

                ! Linear interpolation to find the value of F at ZVALUE

                  f_cur = f(k1,k2,k3)
                  f_up = f(k1,k2,k3+1)
                  ZM = DXDM(3,1) * K1 + DXDM(3,2) * K2 +
     $                 DXDM(3,3) * (K3+1) + origin(3)

                  FV = f_up + (f_cur-f_up) * (ZVALUE - ZM) / (Z - ZM)
 
                  write(2,*)
     .                 ( DXDM(IX,1) * K1 +
     .                 DXDM(IX,2) * K2 +
     .                 DXDM(IX,3) * K3 + origin(ix) , IX=1,2), FV
             
                  GOTO 10

               ENDIF

            ENDDO

            WRITE(6,*)  'Z = ',ZVALUE,
     .           ' not found. It is probably outside your cell'
            STOP

 10      ENDDO
         write(2,*)
      ENDDO

      CLOSE(2)

      END
      
