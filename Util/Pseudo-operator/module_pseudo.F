
      module m_pseudooperator

      use precision,        only: dp
      use psop_params,      only: nrmax, lmaxd, nkbmx
      use schrodinger_m,    only: schro_eq, energ_deriv, rphi_vs_e

      implicit none

      CONTAINS

! ----------------------------------------------------------------------

      subroutine vlocal1( Zval, nrval, a, rofi, drdi, s, rgauss,
     .                    vlocal, nchloc, chlocal )

!     This routine generates a smooth local pseudopotential.
!     
!     Written by D. Sanchez-Portal, Aug. 1998
!     Separated in an independent module by JJ, April 2013.

      real(dp), intent(in)    :: Zval       ! Valence charge of the atom
      real(dp), intent(in)    :: a          ! Parameter to define the positive
                                            !   charge distribution that 
                                            !   generates vlocal
                                            !   After some numerical test,
                                            !   a = 1.82 /rcore
      integer,  intent(in)    :: nrval      ! Number of points in the 
                                            !   logarithmic grid required to 
                                            !   describe the valence eigenfunc
      real(dp), intent(in)    :: rofi(:)    ! Radial logarithmic grid
      real(dp), intent(in)    :: drdi(:)    ! Distance between consecutive 
                                            !   points of the logarithmic grid. 
                                            !   Required to perform radial 
                                            !   integrals.
      real(dp), intent(in)    :: s(:)       ! Metric function
      real(dp), intent(out)   :: vlocal(:)  ! Local component of the 
                                            !   pseudopotential
      real(dp), intent(out)   :: chlocal(:) ! Charge distribution that generates
                                            !   vlocal
      integer,  intent(out)   :: nchloc     ! Number of radial points required
                                            !   to describe chlocal
      real(dp), intent(inout) :: rgauss     !!???

!     Internal variables
      real(dp) van, factor, alp, cutoff1, cutoff2,
     .         qtot, eps, pi, chc, r, Rchloc, rhor1, rhor
      integer ir
      character loctype*3

      parameter( eps = 1.0d-4 )
      pi = acos( -1.0_dp )

!     Usual local potential
!     (generated with an optimum Vandebilt function)
      loctype = 'new'
!
!     The very first local potential used by SIESTA was
!     the electrostatic potential generated by a gaussian
!     distribution ===> loctype='old'
!     loctype = 'old'
!    

!     Local-potential size parameter 'rgauss'
!     We choose as a smooth pseudopotential the one generated
!     by a 'Vanderbilt-function' charge distribution. We have to select
!     the size of this distribution somehow.
!     'Vanderbilt-functions' are of the form :
!     p(r)=N*exp(-(sinh(van*r)/sinh(van))**2)
!     [see Eq. (7) of the technical paper of Siesta,
!     J. M. Soler et al., J. Phys.: Condens. Matter 14, 2745 (2002)]
!     when van---> 0 we will obtain a 'gaussian'
!     when van---> Inf. we will obtain a step function
!     Some test has revealed that the best election to achieve
!     a good convergence in real and reciprocal space is b in the
!     range 0.5-1.0 .

!     So, the 'gaussian' charge distribution
!     must go to zero at a distance 'rgauss'.

      if( loctype .eq. 'new' ) then

!     We take a 'Vanderbilt-function' as local potential
!     van=1.0_dp all the parameter have optimized for this value
!     In the notation of the Siesta paper, van = b in page 2747,
!     where it is said, "After some numerical tests we have taken b = 1.

         van     = 1.00_dp
         cutoff1 = 3.63_dp
         cutoff2 = 5.48_dp

!     99% of charge inside Rgauss
!     factor = 1.627_dp

!     99.9% of charge inside Rgauss
         factor = 1.815_dp

!     Scaling factor for local-pseudopotential charge
!     This "alp" corresponds with the parameter "a" in the 
!     Siesta paper, where in page 2747, it can be read
!     "After some numerical tests we have taken b = 1 and
!     a = 1.82 / rcore" 
         alp = factor / rgauss

         write(6,'(/,a,f10.3,a)')
     .     'VLOCAL1: 99.0% of the norm of Vloc inside ',
     .     ( alp * cutoff1 )**2,' Ry'
         write(6,'(a,f10.3,a)')
     .     'VLOCAL1: 99.9% of the norm of Vloc inside ',
     .     ( alp * cutoff2 )**2,' Ry'

      else

!        This is just a gaussian!!
         van    = 0.00001_dp
         rgauss = 0.80_dp
         factor = 2.0_dp
!        Scaling factor for local-pseudopot. charge
         alp = factor / rgauss
      endif

!     Define the positive charge distribution according to 
!     the Vanderbilt distribution,
!     D. Vanderbilt, Phys. Rev. B 32, 8412 (1985)
!     At this point, the charge distribution is angularly integrated,
!     this is the origin of the factor 4 * pi.
!     Notice than in Siesta the nuclear charge is negative,
!     this is the origin of the minus sign in chlocal

      qtot  = 0.0_dp
      rhor1 = vander( van, alp*rofi(1) )     ! This is 1...
      do ir = 1, nrval
        r    = rofi(ir)
        rhor = vander( van, alp*r )
        chlocal(ir) = (-4.0_dp) * pi * rhor * r * r
        qtot = qtot + rhor * drdi(ir) * r * r
      enddo
      qtot   = 4.0_dp * pi * qtot

!     Renormalize the local charge to the valence charge
!     and compute the number of logarithmic grid points required
!     to represent it
      nchloc = 0 
      do ir  = nrval, 1, -1
        chc = zval * chlocal(ir)/qtot
        chlocal(ir) = chc
        if( (abs(chc) .gt. eps) .and. (nchloc .eq. 0) ) then
           nchloc = ir + 1
        endif
      enddo
      Rchloc = rofi(nchloc)

!
!     Note that the above cutoff is for 4*pi*r*r*rho_local(r)...
!
!     Compute the potential generated by the local charge.
!     This corresponds to the local part of the pseudopotential
      call vhrtre( chlocal, vlocal, rofi, drdi, s, nrval, a )

!     Eliminate the angular integration of the local charge
!     (that is, divide by 4 pi r^2)
!     and enforce that beyond the cutoff radius for the local charge,
!     the local potential corresponds to the asymptotic Coulomb
!     behavior -2 Z_val/r. 
!     The factor of 2 is required to transform Hartrees into Rydbergs.
      do ir = 2, nrval
        r = rofi(ir)
        chlocal(ir) = chlocal(ir)/( 4.0_dp * pi * r * r )
!
!     Poor man's cutoff!! Largely irrelevant?
!     
        if (r .gt. 1.1_dp*Rchloc) then
          vlocal(ir) = (-2.0_dp) * zval/rofi(ir)
        endif
      enddo
      chlocal(1)= -rhor1 * zval/qtot

      end subroutine vlocal1

! ----------------------------------------------------------------------

      subroutine vlocal2( Zval, nrval, a, rofi, drdi, s, vps,
     .                    nrgauss, vlocal, nchloc, chlocal )

!     This routine generates the local pseudopotential appropiate
!     for species with a large core.
!     Written by D. Sanchez-Portal, Aug. 1998
!     Separated in an independent module by JJ, April 2013.

      real(dp), intent(in)    :: Zval       ! Valence charge of the atom
      real(dp), intent(in)    :: a          ! Parameter to define the positive
                                            !   charge distribution that 
                                            !   generates vlocal
                                            !   After some numerical test,
                                            !   a = 1.82 /rcore
      integer,  intent(in)    :: nrval      ! Number of points in the 
                                            !   logarithmic grid required to 
                                            !   describe the valence eigenfunc
      real(dp), intent(in)    :: rofi(:)    ! Radial logarithmic grid
      real(dp), intent(in)    :: drdi(:)    ! Distance between consecutive 
                                            !   points of the logarithmic grid. 
                                            !   Required to perform radial 
                                            !   integrals.
      real(dp), intent(in)    :: s(:)       ! Metric function
      real(dp), intent(out)   :: vlocal(:)  ! Local component of the 
                                            !   pseudopotential
      real(dp), intent(out)   :: chlocal(:) ! Charge distribution that generates
                                            !   vlocal
      integer,  intent(out)   :: nchloc     ! Number of radial points required
                                            !   to describe chlocal
      integer,  intent(inout) :: nrgauss
      real(dp), intent(in)    :: vps(:)


!     Internal variables
      real(dp)
     .  vlc, r, dev, dev2, dev3, var1, var2, var3, v1, v2, v3, v4,
     .  dm11, dm12, dm13, dm21, dm22, dm23, dm31, dm32, dm33,
     .  g0, g1, g2, g3, g4, d2g, d2u, cons, a2b4, qtot, pi
      integer
     .  ndevfit, ir

      real(dp), parameter  :: eps=1.0d-5

      pi=acos(-1.0_dp)

!     Continuity up to second derivative
      ndevfit = 2
!     Continuity up to third derivative
!     ndevfit = 3

      nrgauss=nrgauss+3        !! For good measure...

      do ir = 1,nrval
        vlocal(ir) = vps(ir) * rofi(ir)
      enddo

      ir   = nrgauss
      dev  = ( vlocal(ir+1) - vlocal(ir-1) ) * 0.5_dp
      dev2 = ( vlocal(ir+1) + vlocal(ir-1) - 2.0_dp * vlocal(ir) )
      dev3 = ( vlocal(ir+2) - 2.0_dp * vlocal(ir+1)
     .         + 2.0_dp * vlocal(ir-1) - vlocal(ir-2) ) * 0.5_dp
      dev3 = ( dev3 - 3.0_dp * a * dev2 + 2.0_dp * (a**2) * dev )
     .       / ( drdi(ir)**3 )
      dev2 = ( dev2 - a * dev ) / ( drdi(ir)**2 )
      dev  = dev / drdi(ir)

!     Local potential is Vloc(r)=v3*exp(v1*r^2+v2*r^3)
!     inside Rgauss and equals the
!     all-electron atomic potential outside Rgauss
!     We impose the continuity up to second derivative

      if(ndevfit.eq.2) then
         vlc=vlocal(nrgauss)
         r=rofi(nrgauss)

         var1=dev/vlc-1.0_dp/r
         var2=dev2/vlc-2.0_dp*var1/r -(var1**2)

         dm11=2.0_dp*r
         dm12=3.0_dp*r*r
         dm21=2.0_dp
         dm22=6.0_dp*r

         v1=(dm22*var1-dm12*var2)/(6.0_dp*r*r)
         v2=(dm11*var2-dm21*var1)/(6.0_dp*r*r)
         v3=vlc/(r*exp((v1+v2*r)*r*r))

c     elseif(ndevfit.eq.3) then
      else

C     We can also construct a local potential
C     Vloc(r)=v4*exp(v1*r^2+v2*r^3+v3*r^4),
C     this new coefficient allows us to impose the continuity
C     of the potential up  to the third derivative.

         vlc=vlocal(nrgauss)
         r=rofi(nrgauss)

         var1=dev/vlc-1.0_dp/r
         var2=dev2/vlc-2.0_dp*var1/r-(var1**2)
         var3=dev3/vlc-3.0_dp*var1*var2-(var1**3)
     .        -3.0_dp*(var1**2+var2)/r

         dm11=2.0_dp*r
         dm12=3.0_dp*r*r
         dm13=4.0_dp*r*r*r
         dm21=2.0_dp
         dm22=6.0_dp*r
         dm23=12.0_dp*r*r
         dm31=0.0_dp
         dm32=6.0_dp
         dm33=24.0_dp*r

         v1=((var1*dm22*dm33+var2*dm13*dm32+var3*dm12*dm23)
     . -(var3*dm22*dm13+var1*dm32*dm23+var2*dm12*dm33))/(48.0_dp*r*r*r)
         v2=((var2*dm11*dm33+var3*dm21*dm13+var1*dm23*dm31)
     . -(var2*dm31*dm13+var3*dm23*dm11+var1*dm21*dm33))/(48.0_dp*r*r*r)
         v3=((var3*dm11*dm22+var2*dm12*dm31+var1*dm32*dm21)
     . -(var1*dm22*dm31+var3*dm21*dm12+var2*dm11*dm32))/(48.0_dp*r*r*r)
         v4=vlc/(r*exp((v1+v2*r+v3*r*r)*r*r))

      endif

      do ir=1,nrval
         r=rofi(ir)
         if(ir.le.nrgauss) then

C**   If second derivative fit***
            if(ndevfit.eq.2) then
               vlocal(ir)=v3*exp((v1+v2*r)*r*r)

C**   If third derivative fit****
            elseif(ndevfit.eq.3) then

               vlocal(ir)=v4*exp((v1+v2*r+v3*r*r)*r*r)
c****
            endif

         else
            vlocal(ir)=vps(ir)
         endif

      enddo

C     Once we have the local potential we define the 'local-pseudopotential
C     charge' which help us to calculate the electrostatic interation
C     between the ions
!
!     Poisson's eq.:
!
!           1/r* d2(rV)/dr2 = -8*pi*rho
!
      a2b4=0.25_dp*a*a
      qtot=0._dp
      do ir=1,nrval-1

         g2=vlocal(ir)*rofi(ir)
!
!        To determine the chlocal cutoff, use the reduced_vlocal cutoff
!
         if(abs(g2+2.0_dp*zval).lt.eps) exit   !exit loop

         if(ir.gt.nrgauss) then

            if((ir.gt.2).and.(ir.lt.(nrval-1))) then
               g0=vlocal(ir-2)*rofi(ir-2)/s(ir-2)
               g1=vlocal(ir-1)*rofi(ir-1)/s(ir-1)
               g2=vlocal(ir)*rofi(ir)/s(ir)
               g3=vlocal(ir+1)*rofi(ir+1)/s(ir+1)
               g4=vlocal(ir+2)*rofi(ir+2)/s(ir+2)

               d2g=(16.0_dp*(g1+g3)-(g0+g4)-30.0_dp*g2)/12.0_dp

            else
               g1=vlocal(ir-1)*rofi(ir-1)/s(ir-1)
               g2=vlocal(ir)*rofi(ir)/s(ir)
               g3=vlocal(ir+1)*rofi(ir+1)/s(ir+1)

               d2g=g1+g3-2.0_dp*g2

            endif

            d2u=d2g-a2b4*g2

            r=rofi(ir)
            cons=8.0_dp*pi*r*drdi(ir)*s(ir)
            chlocal(ir)=(-d2u)/cons
            qtot= qtot + 0.5_dp*d2u*r/s(ir)

         else

C     If second derivative fit
            if(ndevfit.eq.2)  then
               r=rofi(ir)

               g0=v3*exp((v1+v2*r)*r**2)
               g1=(2.0_dp*v1+3.0_dp*v2*r)
               g2=2.0_dp*v1+6.0_dp*v2*r
               g3=(g2+g1*g1*r*r+2.0_dp*g1)*g0

               cons=8.0_dp*pi
               chlocal(ir)= (-g3)/cons
               qtot= qtot  + 0.5_dp*g3*r*r*drdi(ir)

C**** If third derivative fit

            elseif(ndevfit.eq.3)  then

               r=rofi(ir)

               g0=v4*exp((v1+v2*r+v3*r*r)*r*r)
               g1=(2.0_dp*v1+3.0_dp*v2*r+4.0_dp*v3*r*r)
               g2=(2.0_dp*v1+6.0_dp*v2*r+12.0_dp*v3*r*r)
               g3=(g2+g1*g1*r*r+2.0_dp*g1)*g0

               cons=8.0_dp*pi
               chlocal(ir)= -g3/cons
               qtot= qtot  + 0.5_dp*g3*r*r*drdi(ir)
            endif

         endif
      enddo      
!
!     This sets the cutoff point for chlocal in a rather
!     arbitrary way, as that in which Vlocal "equals" 2Z/r
!
      nchloc=ir  

      do ir=1,nchloc-1
         chlocal(ir)=zval*chlocal(ir)/qtot
      enddo 
      do ir=nchloc,nrval
         chlocal(ir)=0.0_dp
      enddo

      end subroutine vlocal2

! ----------------------------------------------------------------------

!
!      The famous "Vanderbilt generalized cutoff"
!
       function vander(a,x) result(f)
       real(dp), intent(in) :: a    ! Generalized gaussian shape
       real(dp), intent(in) :: x
       real(dp)             :: f

       real(dp), parameter  :: log10_e = 0.4343
       real(dp), parameter  :: exp_range = (range(1.0_dp)-1)/log10_e

!      real(dp), parameter :: exp_range = 40.0_dp
       real(dp)   :: gexp

       gexp = sinh(a*x)/sinh(a)
       gexp = gexp*gexp

       if (gexp .lt. exp_range) then
          f=exp(-gexp)
       else
          f = 0.0_dp
       endif

       end function vander

! ----------------------------------------------------------------------

      subroutine KBgen( is, a, b, rofi, drdi, s, 
     .                  vps, vlocal, ve, nrval, Zval, lmxkb, 
     .                  nkbl, erefkb, nkb, xf )

       use psop_options, only:new_kb_reference_orbitals,restricted_grid
       use psop_options, only: debug_kb_generation

! Call routines for:
! (1) The generation of the Kleinman-Bylander projectors,
! (2) cheking for the presence of ghost states, and 
! (3) the storage of all the information in the corresponding common blocks.
!
!  Written D. Sanchez-Portal, Aug. 1998.
!  Modified by DSP to allow more than one projector per l, July 1999.
!  Separated in an independent module by JJ, April 2013.
!
      use flib_wxml

      implicit none

      integer, intent(in)  :: is            ! Species index
      integer, intent(in)  :: nrval         ! Number of points in the 
                                            !   logarithmic grid required to 
                                            !   describe the valence eigenfunc
      integer, intent(in)  :: lmxkb         ! Maximum angular momentum of the
                                            !   KB projector
      integer, intent(in)  :: nkbl(0:lmaxd) ! Number of KB projectors per 
                                            !   angular momentum shell
      real(dp), intent(in) :: rofi(nrmax)   ! Radial logarithmic grid
      real(dp), intent(in) :: vps(nrmax,0:lmaxd)  
                                            ! Semilocal components of the 
                                            !   pseudopotential
      real(dp), intent(in) :: drdi(nrmax)   ! Distance between consecutive 
                                            !   points of the logarithmic grid. 
                                            !   Required to perform radial 
                                            !   integrals.
      real(dp), intent(in) :: vlocal(nrmax) ! Local component of the 
                                            !   pseudopotential
      real(dp), intent(in) :: Zval          ! Valence charge of the atom
      real(dp), intent(in) :: a             ! Step parameter of logarithmic grid
      real(dp), intent(in) :: b             ! Scale parameter of the logari grid
      real(dp), intent(in) :: ve(:)         ! Screening potential generated from
                                            !   valence charge pseudo-charge 
                                            !   given by the pseudopotential 
                                            !   generation program
      real(dp), intent(in) :: s(:)          ! Metric function
      real(dp), intent(inout) :: erefkb(nkbmx,0:lmaxd)  
                                            ! Reference energies for the 
                                            !  calculation of KB projectors
      integer, intent(out) :: nkb           ! Total number of KB projectors

      type(xmlf_t), intent(inout) :: xf


!     Internal variables
      integer 
     .  l,nprin, nnodes, ighost, nrwf, ikb, ir,
     .  nrc, nrlimit
      real(dp)
     .  rc(nkbmx,0:lmaxd), dkbcos(nkbmx,0:lmaxd),
     .  ekb(nkbmx,0:lmaxd)
               
      real(dp)
     .  rphi(nrmax,nkbmx), rmax, dnrm, 
     .  proj(nrmax)

      character(len=20) :: filename = ""
                
!     The atomic wavefunctions and/or its energy derivatives are
!     calculated only inside a sphere of radius Rmax. To define the
!     KB projectors they will not be needed very far from the nucleus,
!     and this limitation simplifies the handling of not bound states.
!     The default value has been changed from 6.0d0 to 20.0d0 by
!     J. Junquera for a better comparison with the KB projectors 
!     generated by Abinit for the non-bonding states.

      real(dp) :: Rmax_kb_default 

      character(len=1), dimension(0:4) ::
     $                  lsymb = (/'s','p','d','f','g'/)

      save ighost
      data ighost / 0 /

!     Define the radius of the sphere where the atomic wavefunctions 
!     will be computed, and the corresponding index of the point 
!     in the logarithmic grid (nrwf)

      if (new_kb_reference_orbitals) then
         Rmax_kb_default = 60.0d0
      else
         Rmax_kb_default = 6.0d0
      endif
!      rmax = fdf_physical("KB.Rmax", Rmax_kb_default, "Bohr")
      rmax = Rmax_kb_default

      nrwf = nint(log(Rmax/b+1.0d0)/a) + 1
      nrwf = min(nrwf,nrval)
      if (restricted_grid)  nrwf=nrwf+1-mod(nrwf,2)

      if (new_kb_reference_orbitals) then
        nrlimit = nrwf
      else
        nrlimit = nrval
      endif

      if (debug_kb_generation) then
        write(6,*)
     .    ' new_kb_reference_orbitals = ', new_kb_reference_orbitals
        write(6,*)
     .    ' restricted_grid = ', restricted_grid
        write(6,*)
     .    ' Rmax_kb_default = ', Rmax_kb_default
        write(6,*)
     .    ' KB.Rmax = ', rmax
        write(6,*)
     .    ' nrwf, nrval, nrlimit = ', nrwf, nrval, nrlimit
      endif



         
!     Compute the atomic wavefunctions and eigenvalues
!     for the construction of the KB projectors
!
!     Loop over all the angular momenta for which we are going to compute
!     a KB projector
      do l = 0, lmxkb  
!       Initialize the atomic wavefunction and the KB projector
        do ir = 1, nrmax
          do ikb = 1, nkbmx
            rphi(ir,ikb) = 0.0d0
          enddo 
          proj(ir) = 0.0d0
        enddo
!       For a given angular momentum, more than one KB projector 
!       might be generated
        do ikb = 1, nkbl(l)
 
!         If the reference energies have not been specifed, the eigenstates
!         with the condition of being zero at r(nrwf) will be used.
!         This is a change introduced by J. Junquera
!         with respect to the original version, where 
!         the condition of being zero at r(nrval) was imposed

          if( erefkb(ikb,l) .ge. 1.0d3 ) then             
            nnodes = ikb
            nprin  = l+1
            call schro_eq( Zval, rofi, vps(1,l), ve, s, drdi,
     .                     nrlimit, l, a, b, nnodes, nprin,
     .                     erefkb(ikb,l), rphi(1,ikb) ) 

!           Normalization of the eigenstates inside a sphere of radius Rmax  
            dnrm = 0.0d0
            do ir = 1, nrwf
              dnrm =dnrm + drdi(ir) * rphi(ir,ikb)**2
            enddo 
            dnrm = sqrt(dnrm)
            do ir = 1, nrwf
              rphi(ir,ikb) = rphi(ir,ikb)/dnrm
            enddo 
!! For debugging
!            write(6,'(a,i5)')' # l       = ', l
!            write(6,'(a,i5)')' # ikb     = ', ikb
!            write(6,'(a,i5)')' # nnodes  = ', nnodes
!            write(6,'(a,i5)')' # nprin   = ', nprin
!            do ir = 1, nrval
!              write(6,'(3f20.12)')rofi(ir), rphi(ir,ikb)
!            end do
!! End debugging
!           If the energy is specified to be 1000 Ry, the energy derivative
!           of the previous wavefunction will be used
          elseif( (erefkb(ikb,l) .le. -1.0d3) .and. (ikb .gt. 1) ) then 
            call energ_deriv( a, rofi, rphi(1,ikb-1), vps(1,l),
     .                        ve, drdi, nrwf, l, erefkb(ikb-1,l),
     .                        rphi(1,ikb), nrval )
            erefkb(ikb,l) = 0.0d0
!         If the reference energies have been specified, we just use them
          else 
            call rphi_vs_e( a, b, rofi, vps(1,l),
     .                      ve, nrval, l, erefkb(ikb,l),
     .                      rphi(1,ikb), Rmax )
          endif 

!         Search for the existence of ghost states
!         There is a change with respect to the original version,
!         Here nrwf is introduced as a variable instead of nrval
          if( nkbl(l) .eq. 1) then
            call ghost( Zval, rofi, vps(:,l), vlocal,
     .                  ve, s, drdi, nrlimit, l, a, b, nrwf,
     .                  erefkb(ikb,l), rphi(:,ikb), ighost )
          else 
            if (ikb.eq.1)
     .        write(6,'(a,i3,/a)') 
     .          'KBgen: More than one KB projector for l=',l,
     .          'KBgen: ghost states analysis will be not performed'
          endif

!         Compute the KB projectors
          call KBproj( ikb, rofi, drdi, vps(1,l), vlocal, nrwf, l,
     .                rphi(1,ikb), dkbcos(ikb,l), ekb(ikb,l), proj, nrc)      

          rc(ikb,l)=rofi(nrc)

          write(filename,"(a,i1,a,i1)")  "KBProj.", l, ".", ikb
          call file_out(nrc,rofi,proj,trim(filename)) 

            call xml_NewElement(xf,"proj")
            call my_add_attribute(xf,"l",lsymb(l))
            call my_add_attribute(xf,"n",str(ikb))
            call my_add_attribute(xf,"ekb",str(0.5_dp*ekb(ikb,l)))
            call my_add_attribute(xf,"type","KB")
             call xml_NewElement(xf,"radfunc")
               call xml_NewElement(xf,"data")
                 call xml_AddArray(xf, 0.5_dp * proj(1:nrval))
               call xml_EndElement(xf,"data")
             call xml_EndElement(xf,"radfunc")
            call xml_EndElement(xf,"proj")

!!         Common block with the information about the  KB projectors
!          call comKB(is, a, b, rofi, proj,
!     .               l, ikb, rc(ikb,l), ekb(ikb,l), nrc)

!       End of the loop for all the KB projectors for a given angular shell
        enddo 
!     End of the loop over angular momenta shell
      enddo   
        
      if ( ighost .eq. 1 ) then
         write(6,"(2a)")'KBgen: WARNING: ',
     .     'Ghost states have been detected'
         write(6,"(2a)")'KBgen: WARNING: ',
     .     'Some parameter should be changed in the '
         write(6,"(2a)")'KBgen: WARNING: ',
     .     'pseudopotential generation procedure.'
!         if ( fdf_boolean('Atom.Ignore.Ghosts',.false.) ) then
!           write(6,"(a)") " KBgen: *** Warning Ignored by User"
!           ighost = 0
!         else
           call die("Found ghost states")
!         endif
      endif

!
!     Write in the output information regarding the KB projector
!
      write(6,'(/,a)')'KBgen: Kleinman-Bylander projectors: '
      do l = 0, lmxkb
        do ikb = 1, nkbl(l)
          write(6,'(3x,a,i2,4(3x,a,f10.6))')
     .      'l=',l, 'rc=',rc(ikb,l), 'el=',erefkb(ikb,l), 
     .      'Ekb=',ekb(ikb,l),'kbcos=',dkbcos(ikb,l)
        enddo
      enddo

!
!     Compute the total number of Kleinman-Bylander projectors     
!
      nkb = 0
      do l = 0, lmxkb
        do ikb = 1, nkbl(l)
          nkb = nkb + ( 2*l + 1 ) 
        enddo 
      enddo 
      write(6,'(/,a, i4)')
     .  'KBgen: Total number of  Kleinman-Bylander projectors: ', nkb

      end  subroutine KBgen

! ----------------------------------------------------------------------

      subroutine KBproj( ikb, rofi, drdi, vps, vlocal, nrwf, l, rphi,
     .                   dkbcos, ekb, proj, nrc )

!  This routine calculates the Kleinman-Bylander projector
!  with angular momentum l.
!
!  Written by D. Sanchez-Portal, Aug. 1998
!  Modified by DSP to allow more than one projector per l, July 1999.
!  Separated in an independent module by JJ, April 2013.

      implicit none

      integer,  intent(in)  :: ikb       ! For a given l shell, many KB pro.j
                                         !   can be generated. 
                                         !   ikb is the KB index for this l.
      integer,  intent(in)  :: nrwf      ! Number of radial points required
                                         !   to store the wave functions
      integer,  intent(in)  :: l         ! Angular momentum shell for 
                                         !   which the KB projector
                                         !   will be computed 
      real(dp), intent(in)  :: rofi(*)   ! Radial logarithmic grid
      real(dp), intent(in)  :: vps(*)    ! Semilocal components of the 
                                         !   pseudopotential
      real(dp), intent(in)  :: drdi(*)   ! Distance between consecutive points
                                         !   of the logarithmic grid. 
                                         !   Required to perform radial integral
      real(dp), intent(in)  :: rphi(*)   ! Eigenstate of the semilocal pseudopot
                                         !   screened by the pseudo-valence 
                                         !   charge density
      real(dp), intent(in)  :: vlocal(*) ! Local component of the 
                                         !   pseudopotential

      real(dp), intent(out) :: proj(*)   ! KB projector
      real(dp), intent(out) :: dkbcos    ! "KB cosine" allows one to distinguish
                                         !   between an artificially or an 
                                         !   intrinsically large KB energy
      real(dp), intent(out) :: ekb       ! "KB energy" that explicitly 
                                         !   characterizes the strength of the 
                                         !   KB potential
      integer,  intent(out) :: nrc       ! Cutoff radii of the KB projector

! Internal variables
      integer   ir, jkb

      real(dp)
     .  dnrm, vl, vphi, avgv, r, phi, dknrm,
     .  dincv, rc, sum, vij(nkbmx)

      real(dp), save ::   rphi2(nrmax,nkbmx), vii(nkbmx)

      real(dp), parameter  :: eps=1.0d-6

!     We need to orthogonalize to the previous projectors.
!     We follow the scheme proposed by Blochl, PRB 41, 5414 (1990)
!     as expressed in Eq. (5) of the technical paper of Siesta
!     [J. M. Soler et al., J. Phys.: Condens. Matter 14, 2745 (2002)]
!     In the following, rphi2 is $\phi$,
!     while rphi corresponds to $\psi$ in the paper.

      if( ikb .eq. 1 ) then
!       For the first KB projector of a given shell, nothing has to be done.
        do ir = 1, nrwf
          rphi2(ir,1) = rphi(ir)
        enddo
      else
!       If there are more than one KB projector per shell, 
!       then we have to orthogonalize the KB projectors with the previous ones.
        do jkb = 1, ikb-1
          sum = 0.0d0
!         In this loop we compute the numerator at the right hand side term
!         of Eq. (5). 
          do ir = 1, nrwf
            vl = vps(ir) - vlocal(ir)
            sum = sum + rphi(ir) * vl * rphi2(ir,jkb) * drdi(ir)
          enddo
          vij(jkb) = sum
        enddo
        do ir = 1, nrwf
          sum = 0.0d0
!         Here we compute all the operations after the summatory of Eq. (5).
!         Note that the denominator was computed and saved as vii in a 
!         previous call to this subroutine
          do jkb = 1, ikb-1
            sum = sum + vij(jkb) * rphi2(ir,jkb)/(vii(jkb)+1.0d-20)
          enddo
!         Finally, we perform the differentiation in Eq. (5) of the technical
!         paper of Siesta
          rphi2(ir,ikb) = rphi(ir) - sum
        enddo
      endif

!     Normalize the new orthogonalized function
      dnrm = 0.0d0
      do ir = 1, nrwf
        dnrm = dnrm + drdi(ir) * (rphi2(ir,ikb)**2)
      enddo
      dnrm = sqrt(dnrm)
      if ( dnrm .lt. eps ) then
        do ir = 1, nrwf
          rphi2(ir,ikb) = 0.0d0
        enddo
      else
        do ir = 1, nrwf
          rphi2(ir,ikb) = rphi2(ir,ikb)/dnrm
        enddo
      endif

!     Compute the "KB energy" and the "KB cosine"
      dnrm = 0.0d0
      avgv = 0.0d0
      do 10 ir = 2, nrwf
        r    = rofi(ir)
        vl   = vps(ir) - vlocal(ir) 
        phi  = rphi2(ir,ikb)
        vphi = vl * phi
!       dnrm is the numerator of Eq. (28) in the paper by
!       X. Gonze, R. Stumpf, and M. Scheffler, Phys. Rev. B 44, 8503 (1991)
        dnrm = dnrm + vphi * vphi * drdi(ir)
!       avgv is the denominator of the previous equation
        avgv = avgv + vphi * phi  * drdi(ir)
  10  enddo   
!     vii is the denominator at the right hand side term of Eq. (5). 
      vii(ikb) = avgv

!     The "KB energy" is defined in Eq. (28) in the paper by
!     X. Gonze, R. Stumpf, and M. Scheffler, Phys. Rev. B 44, 8503 (1991)
      ekb    = dnrm  / (avgv+1.0d-20)

!     The "KB cosine" is defined in Eq. (33) in the paper by
!     X. Gonze, R. Stumpf, and M. Scheffler, Phys. Rev. B 44, 8503 (1991)
      dknrm  = 1.0d0 / (sqrt(dnrm)+1.0d-20)
      dkbcos = avgv * dknrm

!     Define the cut-off radii for the KB projectors
!     Warning these radii should be quite short, if it is not the case
!     something is probably wrong in this part of the program.
!     It will display a warning if Rc > 4.5 a.u. or Rc < 0.5a.u.!
      do 20 ir = nrwf, 2, -1
        phi   = ( rphi2(ir,ikb)/rofi(ir) ) * dknrm
        dincv = abs( (vps(ir)-vlocal(ir) ) * phi )
        if ( dincv .gt. eps ) then
          if( ir .ge. nrwf-1 ) then
            write(6,"(2a,/,2a)") 'KBproj: WARNING: ',
     .        'KB projector does not decay to zero',
     .        'KBproj: WARNING: ',
     .        'parameter Rmax in routine KBgen should be increased'
          endif
          goto 21
        endif
20    enddo    

21    nrc = ir + 1
      rc  = rofi(nrc)

      if( rc .lt. 0.5d0 ) then
        write(6,"('KBproj: WARNING: Rc(',i2,')=',f12.4)")l,rc
        write(6,"(2a)") 'KBproj: WARNING: ',
     .    'Cut of radius for the KB projector too small'
      elseif( rc .gt. 4.5d0 ) then
        write(6,"('KBproj: WARNING: Rc(',i2,')=',f12.4)")l,rc
        write(6,"(2a)") 'KBproj: WARNING: ',
     .    'Cut of radius for the KB projector too big'
        write(6,"(2a)") 'KBproj: WARNING: ',
     .    'Increasing the tolerance parameter eps'
        write(6,"(a)") 'KBproj: WARNING: might be a good idea'
      endif

!     Define the radial part of the KB projector 
!     according to Eq. (29) of the paper by
!     X. Gonze, R. Stumpf, and M. Scheffler, Phys. Rev. B 44, 8503 (1991)
!     Within this definition, the KB operator reduces to the projector
!     defined in Eq. (30) of the previous paper, that is equivalent to 
!     Eq. (2) of the technical paper of Siesta.
!     Take into account that in the Siesta paper there is a typo in Eq. (3),
!     that should read:
!     v_{ln}^{KB} = [ < \phi_ln | \delta V_{l} | \phi_{ln} > ]^(-1)
!     Note the radial part of the KB projector is divided by r**(l+1)
      do 30 ir = 2, nrc
        r        = rofi(ir)
        vl       = ( vps(ir) - vlocal(ir) )
        phi      = rphi2(ir,ikb)/r
        vphi     = vl * phi * dknrm
        proj(ir) = vphi/r**l
30    enddo   

! Extrapolation of quadratic function to r=0
      proj(1)= ( proj(2)*rofi(3)**2 - proj(3)*rofi(2)**2 ) /
     .         ( rofi(3)**2 - rofi(2)**2 )

      end subroutine KBproj

! ----------------------------------------------------------------------

      subroutine ghost( Zval, rofi, vps, vlocal,
     .                  ve, s, drdi, nrval, l, a, b,
     .                  nrc, eigenl, rphi, ighost)

! This routine checks the possible existence of ghost states.
! Compares the reference energy with the eigenvalues of the
! local potential, for ghost analysis.
! We follow the recipe given by Gonze and coworkers in page 8508 of 
! X. Gonze, R. Stumpf, and M. Scheffler, Phys. Rev. B 44, 8503 (1991)
!
! Output:
! Sets ighost to 1 if it finds a ghost state.
! ighost is a saved variable in the caller.
!
! Written by D. Sanchez-Portal, Aug. 1998
! Separated in an independent module by JJ, April 2013.
!

      integer, intent(in)   :: nrval     ! Number of points in the 
                                         !   logarithmic grid required to 
                                         !   describe the valence eigenfunction
                                         !   at the time of solving the
                                         !   Schrodinger equation to generate
                                         !   the KB projectors (nrwf in the 
                                         !   calling subroutine)
      integer, intent(in)   :: l         ! Angular momentum shell
      integer, intent(inout):: nrc       ! Number of points in the  
                                         !   logarithmic grid required to 
                                         !   describe the KB projectors
      integer, intent(inout):: ighost    ! Flag that determines whether there
                                         !   are ghost states for a given shell
                                         !   0 = no ghost state
                                         !   1 = no ghost state
      real(dp), intent(in)  :: zval      ! Valence charge of the atom
      real(dp), intent(in)  :: a         ! Step parameter of logarithmic grid
      real(dp), intent(in)  :: b         ! Scale parameter of the logari grid
      real(dp), intent(in)  :: eigenl    ! Atomic reference eigenvalue  
      real(dp), intent(in)  :: rofi(:)   ! Radial logarithmic grid
      real(dp), intent(in)  :: vps(:)    ! Semilocal component of the pseudopot
                                         !   for the angular momentum l
      real(dp), intent(in)  :: vlocal(:) ! Local component of the pseudopotent
      real(dp), intent(in)  :: ve(:)     ! Screening potential generated from
                                         !   valence charge pseudo-charge 
                                         !   given by the pseudopotential 
                                         !   generation program
      real(dp), intent(in)  :: s(:)      ! Metric function
      real(dp), intent(in)  :: drdi(:)   ! Distance between consecutive points
                                         !   of the logarithmic grid. 
                                         !   Required to perform radial integral
      real(dp), intent(in)   :: rphi(:)  ! Eigenstate of the semilocal pseudopot
                                         !   screened by the pseudo-valence 
                                         !   charge density


!     Internal variables
      real(dp)   dnrm, avgv, phi,
     .     elocal1, elocal2, g(nrmax), vl, vphi, dkbcos

      integer  ir, nprin, nnode

! Debugging
!      write(6,*) 'Entering ghost: l, eigenl', l, eigenl
! End debugging

!     Calculate the "KB energy" as defined in Eq. (28) in the paper by
!     X. Gonze, R. Stumpf, and M. Scheffler, Phys. Rev. B 44, 8503 (1991)
      nrc  = min(nrc,nrval)
      dnrm = 0.0d0
      avgv = 0.0d0
      do 30 ir = 2, nrc
         vl   = vps(ir)-vlocal(ir)
         phi  = rphi(ir)
         vphi = vl * phi
         dnrm = dnrm + vphi * vphi * drdi(ir)
         avgv = avgv + vphi * phi * drdi(ir)
 30   enddo    
      dkbcos = dnrm/(avgv+1.0d-20)

!     Perform the ghost analysis
!     We follow the recipe given by Gonze and coworkers in page 8508 of 
!     X. Gonze, R. Stumpf, and M. Scheffler, Phys. Rev. B 44, 8503 (1991)

!     If the "KB energy" < 0, there is a ghost level under the atomic reference
!     level if, and only if, the atomic reference eigenvalue is
!     higher in energy than the ground-state of the local Hamiltonian
      if ( dkbcos .lt. 0d0 ) then


         nprin = l+1
         nnode = 1
         call schro_eq( Zval, rofi, vlocal, ve, s, drdi,
     .                  nrval, l, a, b, nnode, nprin,
     .                  elocal1, g )
!         if( eigenl .gt. elocal1 ) then
         if (above_significatively(eigenl,elocal1)) then
           write(6,"(a,i3,/,a,g20.10,/,a,2g20.10)")
     .       'GHOST: WARNING: Ghost state for L =', l,
     .       ' dkbcos: ', dkbcos,
     .       ' eigenl, eigenl - elocal1: ', eigenl, eigenl - elocal1
           ighost = 1
         else
           write(6,'(a,i3)') 'GHOST: No ghost state for L =',l
         endif

!     If the "KB energy" > 0, there is a ghost level under the atomic reference
!     level if, and only if, the atomic reference eigenvalue is
!     higher in energy than the first excited level of the local Hamiltonian
      else if ( dkbcos .gt. 0.0d0 ) then

         nprin = l+1
         nnode = 2
         call schro_eq( Zval, rofi, vlocal, ve, s, drdi,
     .                  nrval, l, a, b, nnode, nprin,
     .                  elocal2, g )

!         if( eigenl .gt. elocal2 ) then
         if (above_significatively(eigenl,elocal2)) then
           write(6,"(a,i3,/,a,g20.10,/,a,2g20.10)")
     .       'GHOST: WARNING: Ghost state for L =', l,
     .       ' dkbcos: ', dkbcos,
     .       ' eigenl, eigenl - elocal2: ', eigenl, eigenl - elocal2
           ighost = 1
         else
           write(6,'(a,i3)') 'GHOST: No ghost state for L =',l
         endif

      else if (dkbcos.eq.0.0d0) then

         write(6,"('GHOST: vps = vlocal, no ghost for L =',i3)") l

      endif

! Debugging
!      write(6,*) 'GHOST: Ground state vlocal for L=',l,elocal1
!      write(6,*) 'GHOST: First excited state for L=',l,elocal2
! End debugging

        CONTAINS

        function above_significatively(x,y) result (gt)
        real(dp), intent(in) :: x, y
        logical              :: gt

        ! Request that x is "well over" y in case of noise.
        ! This is an "absolute noise" for now.

        real(dp), parameter :: eps = 1.e-8_dp

        gt = (x .gt. y + eps)

        end function above_significatively

      end subroutine ghost

! ----------------------------------------------------------------------

      subroutine radii_ps( vps, rofi, Zval, nrval, lmxkb,
     .                     nrgauss, rgauss, rgauss2)

      use psop_options, only: rmax_ps_check

C     This routine returns the maximum radius for the
C     Kleinman-Bylander projectors with a standard choice
C     of the local potential.
C     Check also at which radius the asymptotic 2*Zval/r
C     behaviour is achieved.
C     D. Sanchez-Portal, Aug. 1998

      real(dp), intent(in)    :: Zval       ! Valence charge of the atom
      integer,  intent(in)    :: nrval      ! Number of points in the 
                                            !   logarithmic grid required to 
                                            !   describe the valence eigenfunc
      real(dp), intent(in)    :: rofi(:)    ! Radial logarithmic grid
      real(dp), intent(in)    :: vps(:,0:)  ! Semilocal components of the 
                                            !   pseudopotential
      integer,  intent(in)    :: lmxkb      ! Maximum angular momentum of the
                                            !   KB projector
      integer,  intent(out)   ::  nrgauss   ! Number of points in the logarith.
                                            !   grid required to describe the 
                                            !   KB projectors
      real(dp), intent(out)   ::  rgauss    ! Approximately the maximum cut-off 
                                            !   radius used in the
                                            !   pseudopotential generation.
      real(dp), intent(out)   ::  rgauss2   ! Radius where the pseudopotentials
                                            !   reach  the asymptotic behaviour
                                            !   2*Zval/r.

!     Internal variables
      real(dp) dincv, r
      integer ir, l, nrgauss2

      real(dp), parameter     ::  eps=1.0d-4

!     Iterate over the possible local potentials

      rgauss   = 0.0_dp
      rgauss2  = 0.0_dp
      nrgauss  = 0
      nrgauss2 = 0

      if (rmax_ps_check == 0.0_dp) rmax_ps_check = rofi(nrval)

      do l = 0, lmxkb-1
         do ir = nrval, 2, -1
            if (rofi(ir) > rmax_ps_check) cycle
            dincv = abs( vps(ir,l) - vps(ir,lmxkb) )
            if( dincv .gt. eps ) exit
         enddo
         rgauss  = max( rofi(ir), rgauss )
         nrgauss = max( ir, nrgauss )
      enddo
!
!     New: Use all potentials, not just l=0, since
!     potentials with larger l can converge later...
!
      do l = 0, lmxkb
         do ir = nrval, 2, -1
            if (rofi(ir) > rmax_ps_check) cycle
            r = rofi(ir)
            dincv = abs( vps(ir,l)*r + 2.0_dp*zval )
            if( dincv .gt. eps ) exit
         enddo
         write(6,'(a,i1,a,f8.4)')
     .     'V l=', l,' = -2*Zval/r beyond r=', rofi(ir)
         rgauss2  = max( rofi(ir), rgauss2 )
         nrgauss2 = max( ir, nrgauss2 )
      enddo

      if( lmxkb .eq. 0 ) then
         rgauss  = rgauss2
         nrgauss = nrgauss2
      endif

      write(6,'(a,f8.4)') 'All V_l potentials equal beyond r=', rgauss
      write(6,'(a)')
     .     'This should be close to max(r_c) in ps generation'
      write(6,'(a,f8.4)')
     .     'All pots = -2*Zval/r beyond r=', rgauss2

      end subroutine radii_ps

! ----------------------------------------------------------------------
      subroutine file_out(n,r,f,name)
!     Convenience routine to plot radial magnitudes  
      integer, intent(in)  :: n
      real(dp), intent(in) :: r(n), f(n)
      character(len=*), intent(in) :: name

      integer lun, i
      call get_free_lun(lun)
      open(unit=lun,file=trim(name),form="formatted",
     $     action="write",position="rewind",status="unknown")
      do i=1,n
         write(lun,*) r(i), f(i)
      enddo
      close(lun)

      end subroutine file_out

        subroutine get_free_lun(lun)
        integer, intent(out) :: lun

        logical :: used
        integer :: iostat

        do lun= 10,90
           inquire(unit=lun, opened=used, iostat=iostat)
           if (iostat .ne. 0) used = .true.
           if (.not. used) return ! normal return with 'lun' value                                        
        enddo
        call die("No luns available")

        end subroutine get_free_lun

      subroutine my_add_attribute(xf,name,value)
      use flib_wxml 
      type(xmlf_t), intent(inout)   :: xf
      character(len=*), intent(in)  :: name
      character(len=*), intent(in)  :: value

       call xml_AddAttribute(xf,name,trim(value))
      end subroutine my_add_attribute

      end module m_pseudooperator
