%denchar.tex
%
%   Javier Junquera  Feb 04, 2002
%
%   Manual for the DENCHAR program


%\documentstyle[twocolumn,prb,aps]{revtex}
%\documentstyle[prb,aps]{revtex}
\documentstyle[11pt]{article}
%\documentstyle{article}

\tolerance 10000
\textheight 22cm
\textwidth 16cm
\oddsidemargin 1mm
\topmargin -15mm

\baselineskip=14pt
\parskip 5pt
\parindent 1em

\begin{document}

% TITLE PAGE --------------------------------------------------------------

\begin{titlepage}

\begin{center}

\vspace{1cm}

{\huge {\sc User's Guide}}

\vspace{4cm}

{\Huge {\bf {\sc Denchar} 1.1.0} }

\vspace{3cm}

{\Large {\it February 04, 2002. 15:00:00} }

\vspace{3cm}

{\Large Javier Junquera}

\vspace{5pt}

{\it D\'epartament de Physique, Universit\'e de Li\`ege,
B\^atiment B-5, B-4000 Sart-Tilman, Belgium},

\vspace{7mm}

\vspace{3cm}
{\bf Javier.Junquera@ulg.ac.be}

\end{center}

\end{titlepage}

% END TITLE PAGE --------------------------------------------------------------

\tableofcontents

\newpage



\section{INTRODUCTION}

{\sc Denchar} program calculates the charge density at the points of a plane
in real space. It is a program included in the utilities package of the
{\sc Siesta} code and shares with it many subroutines. Its principal 
features are:

\begin{itemize}

\item
Flexibility for defining the plane in which we are going to calculate
the charge density. Possible options are: the normal vector, 
two lines contained in the plane,
three points included in the plane or three atoms contained in it.

\item
For spin-unpolarized calculations, the fully self-consistent charge and
the difference between the SCF charge density and the superposition of atomic
densities are calculated. In this way, we can study how the chemical bonds 
change the charge distribution.
 
\item
For spin-polarized calculations, the magnetization (difference between
the charge density for spin up and down) is calculated.

\item 
Many of the subroutines used by {\sc Denchar} 
are taken from {\sc Siesta}. These are:

atm\_types.f, atmfuncs.f, atmparams.f, basis\_io.F, basis\_types.f, 
bessph.f, bsd.f, chemical.f, chkdim.f, dismin.f, dot.f, io.f, iodm.F, 
ionew.F, listsc.f, memory.F, memoryinfo.F, neighb.f, 
parallel.f, paste.f, precision.F, prmem.f, pseudopotential.f,
radfft.f, radial.f, ranger.f, recipes.f, spher\_harm.f, sys.F, 
version.F, volcel.f, xmol.f \\
 
and the subdirectories MPI, NetCDF and fdf.
 
I would like to thank the authors of these subroutines,
in spetial many thanks to A. Garc\'{\i}a and
J. Gale,  for allowing me 
to use them.

\end{itemize}

This is a short description of the compilation procedures
and of the datafile format for the {\sc Denchar} code.
This version is a very preliminary release of the code.
Please report problems, bugs and suggestions to
Javier.Junquera@ulg.ac.be

\section{HOW TO COMPILE AND RUN THE PROGRAM}

In this section we give all the steps required to install
and run the program. 
We assume that you use UNIX, that you will install {\sc Denchar} in 
$\sim$/siesta/Util/Denchar/Src, and {\sc Siesta} source directory is:
$\sim$/siesta/Src,
 where $\sim$ indicates your home directory.
The commands that you must type are in {\tt typewriter} font, 
and {\tt \#} indicates the prompt.

\subsection{Compilation}

  \begin{itemize}

   \item Change to the directory where the sources of {\sc Denchar} are:

         {\tt \# cd $\sim$/siesta/Util/Denchar/Src}

   \item Copy the arch.make from the source directory of {\sc Siesta}:

         {\tt \# cp $\sim$/siesta/Src/arch.make .}

         You can learn about this arch.make file reading the 
         {\sc Siesta} User's Guide.

   \item Edit the arch.make file and, if they are defined,
         delete all the set values
         of the variables related with the parallelization
         (DEFS\_MPI, MPI\_INTERFACE, MPI\_INCLUDE,...) and
         the references to Blacs or Scalapack libraries.

   \item Type make:

         {\tt \# make}

   \item The program should compile and an executable file called
         denchar should be created.

  \end{itemize}

\subsection{Running the code}

 {\sc Denchar} needs some information that will be supplied by {\sc Siesta}. 
 The first thing we must do is to run {\sc Siesta} for 
 the system we are interested in,
 setting up variable WriteDenchar to true. 
 In this way {\sc Siesta} will generate
 two files called {\it SystemLabel}.PLD and {\it SystemLabel}.DIM
 where all the information 
 needed to plot the charge density at the points of a plane will be stored.

 Then, from the directory you have run {\sc Siesta}, 
 you can create a link to the executable file:

 {\tt \# ln -s $\sim$/siesta/Util/Denchar/Src/denchar . }

 Edit an input file for {\sc Denchar}, input.fdf, following the 
 instructions given in Section \ref{cap:input}.


 {\tt \# denchar < {\it input}.fdf } 


 The output is dumped into files, which will be described
 in Section \ref{cap:output}.

\section{INPUT DATA FILE}
\label{cap:input} 

The input data file is written in an special format called FDF, developed
by Alberto Garc\'{\i}a and Jos\'e M. Soler (see {\sc Siesta} USER'S GUIDE).
It contains all the parameters needed to define the plane.
Here follows a description of the variables that you can define in your 
{\sc Denchar} input files,
with their data types and default values.

\vspace{5pt}
\subsection{General system descriptors}

\begin{description}
\itemsep 10pt
\parsep 0pt

\item[{\bf SystemLabel}] ({\it string}): 
A {\bf single} word (max. 20 characters {\bf without blanks})
containing a nickname of the system, used to name output files. 
{\bf It must be the same that you use when you run {\sc Siesta}!!}

{\it Default value:} siesta

\item[{\bf 2D.CoorUnits}] ({\it string}): 
Character string to specify the format of the position of the points that
define the plane in input.
These can be expressed in two forms:

\begin{itemize}
\item[-] Ang        : Angstroms 
\item[-] Bohr       : Bohrs
\end{itemize}

\item[{\bf 2D.DensityUnits}] ({\it string}): 
Character string to specify the units of the charge density in output. 
These can be expressed in three forms:

\begin{itemize}
\item[-] Ele/Bohr**3      : Electrons/bohr**3
\item[-] Ele/Ang**3       : Electrons/angstrom**3
\item[-] Ele/UnitCell     : Electrons/Unit Cell (The volume is the volume
                            of the Supercell generated by {\sc Siesta}).
\end{itemize}


\item[{\bf 2D.NumberPointsX}] ({\it integer}):
 Number of subdivision of the plane in the x-direction. Together
 with 2D.NumberPointsY, it will define the 
 number of points in which we are going to compute the charge density.

{\it Default value:} 50

\item[{\bf 2D.NumberPointsY}] ({\it integer}):
 Number of subdivision of the plane in the y-direction. Together
 with 2D.NumberPointsX, it will define the 
 number of points in which we are going to compute the charge density.

{\it Default value:} 50

 The total number of points where we are going to calculate the charge density
 will be 2D.NumberPointsX $\times$ 2D.NumberPointsY.

\noindent 
 The next four variables define the size of the window inside the plane where
 we will focuss our attention.

\item[{\bf 2D.MinX}] ({\it real length}):
 Define the minimum value of the x-component of the window, in a system 
 of reference in which the third component is normal to the plane.
{\it Default value:} -3.0 bohrs

\item[{\bf 2D.MaxX}] ({\it real length}):
 Define the maximum value of the x-component of the window, in a system 
 of reference in which the third component is normal to the plane.
{\it Default value:} +3.0 bohrs

\item[{\bf 2D.MinY}] ({\it real length}):
 Define the minimum value of the y-component of the window, in a system 
 of reference in which the third component is normal to the plane.
{\it Default value:} -3.0 bohrs

\item[{\bf 2D.MaxY}] ({\it real length}):
 Define the maximum value of the y-component of the window, in a system 
 of reference in which the third component is normal to the plane.
{\it Default value:} +3.0 bohrs

\item[{\bf 2D.PlaneGeneration}] ({\it string}): 
 Select the option to generate the plane:

\begin{itemize}
\item[-] NormalVector : If we want to choose the normal vector to describe the
                        plane.
\item[-] TwoLines       : If we want to specify two vectors contained in the 
                        plane.
\item[-] ThreePoints  : If we want to give the coordinates of three points 
                        of the plane.
\item[-] ThreeAtomicIndices : If we want the plane that contains three 
                        given atoms.
\end{itemize}
\noindent
{\it Default value:} {\tt NormalVector}


\item[{\bf 2D.CompNormalVector}] ({\it data block}): 
Components of the normal vector. A normal vector defines a family of parallel
planes. So we must specify which of these planes is the one 
 we are interested in.
So, when we select the option {\it NormalVector} to generate the plane, we must 
also input the origin of our plane (one point belonging to it), and another
point to define the x direction inside the plane (see below).

{\it Use:} Used only if 2D.PlaneGeneration is {\tt NormalVector}
    
{\it Default value:} 
\begin{verbatim}
  0.000   0.000   1.000
\end{verbatim}

\item[{\bf 2D.Comp2Vectors}] ({\it data block}): 
Components of two vectors containes in the plane. 
When we select the option {\it TwoLines} we must also supply the origin 
of the plane, it is said, the coordinates of one point inside the plane (see
below). The first vector will define the x direction inside the plane.

{\it Use:} Used only if 2D.PlaneGeneration is {\tt TwoLines}
    
{\it Default value:} 
\begin{verbatim}
  1.000   0.000   0.000
  0.000   1.000   0.000
\end{verbatim}

\item[{\bf 2D.Coor3Points}] ({\it data block}): 
Coordinates of three points inside the plane. The first one will be taken
as the origin of the plane. The vector between the first and the second one 
will determine the x-direction inside the plane.

{\it Use:} Used only if 2D.PlaneGeneration is {\tt ThreePoints}
    
{\it Default value:} 
\begin{verbatim}
  1.000   0.000   0.000
  0.000   1.000   0.000
  0.000   0.000   1.000
\end{verbatim}

\item[{\bf 2D.Indices3Atoms}] ({\it data block}): 
Indices of three atoms that will belong to the plane. In this way, we
define the plane that contains three given atoms. The coordinates
of the first atom are taken as the origin of the plane, 
and the vector between
the first and second atom will define the x-direction within
the plane.

{\it Use:} Used only if 2D.PlaneGeneration is {\tt ThreeAtomicIndices}
    
{\it Default value:} 
\begin{verbatim}
  1 2 3
\end{verbatim}

\item[{\bf 2D.PlaneOrigin}] ({\it data block}): 
Coordinates of one point inside the plane that will be taken as the origin. 
This is neccesary if we want to define the plane from the normal vector or
from two lines, because we must select one of the planes of the family of
parallel planes.

{\it Use:} Used only if 2D.PlaneGeneration is {\tt NormalVector} or
{\tt TwoLines}. If 2D.PlaneGeneration is {\tt ThreePoints}
or {\tt ThreeAtomicIndices}, the 2D.PlaneOrigin is
automatically chosen (see description of variables 2D.Coor3Points
and 2D.Indices3Atoms).
    
{\it Default value:} 
\begin{verbatim}
  0.000   0.000   0.000
\end{verbatim}
        
\item[{\bf 2D.X-Axis}] ({\it data block}): 
Coordinates of one point inside the plane needed to define the x-direction,
when the normal vector is selected to define the plane. The vector between 
the origin and this new point will define the x-direction.

{\it Units:} bohrs.

{\it Use:} Used only if 2D.PlaneGeneration is {\tt NormalVector} 
    
{\it Default value:} 
\begin{verbatim}
  1.000   0.000   0.000
\end{verbatim}

\item[{\bf 2D.AtomsInPlane}] ({\it data block}): 
Indices of the atoms whose coordinates will be rotated to the in-plane 
reference frame. In this system of reference, atoms in the plane will have 
the third coordinate equal to zero. 
The coordinates will be written in the corresponding output files. The
units of the output coordinates will be determined by 2D.CoorUnits.
One index per line.

{\it Default value:} No default value 

\end{description}

\section{OUTPUT FILES}
\label{cap:output} 

Several output files are produced, with quantities related
with the system charge densities.
Each file is defined in the following paragraph.
For all of them, the output format is the same: there are three 
columns in each file; the first two columns give the coordinates of the points
in the plane (in the reference frame in which the third axis is normal  
to the plane);
the third column gives the corresponding charge density at that
point.

If we are not taking into account the spin polarization in our calculation 
two output files will be generated by {\sc Denchar}:

\begin{description}
\itemsep 10pt
\parsep 0pt

\item[{\bf {\it SystemLabel}.CON.SCF}]: 
Fully Self-Consistent Charge Density at the points of the plane in real space.

\item[{\bf {\it SystemLabel}.CON.DEL}]: 
Difference between fully self-consistent charge density and the superposition
of atomic densities. 
 
\end{description}

If spin polarization is taken into account, then there are 
 four output files, named:

\begin{description}
\itemsep 10pt
\parsep 0pt


\item[{\bf {\it SystemLabel}.CON.UP}]: 
Fully self-consistent charge density for electrons with spin {\bf UP}.

\item[{\bf {\it SystemLabel}.CON.DOWN}]: 
Fully self-consistent charge density for electrons with spin {\bf DOWN}.

\item[{\bf {\it SystemLabel}.CON.MAG}]: 
{\bf Magnetization}. Difference between fully self-consistent charge density 
with spin up and spin down.

\item[{\bf {\it SystemLabel}.CON.DEL}]: 
Difference between fully self-consistent charge density (equal to the 
sum of charge density for both spines) and the superposition
of atomic densities. 

\end{description}

\section{EXAMPLES}

In directory {\tt $\sim$/siesta/Util/Denchar/Examples} you will find some
examples of input files for the different options. The physical system is a
cell of Si in the diamond structure at the experimental lattice constant.

\end{document}
