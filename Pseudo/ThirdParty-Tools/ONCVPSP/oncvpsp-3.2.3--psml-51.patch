diff -Naur oncvpsp-3.2.3/INSTALL oncvpsp-3.2.3--psml-51/INSTALL
--- oncvpsp-3.2.3/INSTALL	2016-09-30 21:12:39.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/INSTALL	2017-01-17 17:29:43.000000000 +0100
@@ -1,3 +1,20 @@
+****
+AG Notes for installation of the PSML version of oncvpsp
+---
+For the time being, the patched version of oncvpsp with PSML support
+has to be compiled by going directly to the 'src' subdirectory, editing
+the 'fortran.mk' file, and typing 'make all'.
+
+Note that you need to pre-compile the (lightweight) xmlf90 library,
+which can be obtained from http://launchpad.net/xmlf90, and insert
+the appropriate path in 'fortran.mk'.
+
+The 'run*' scripts in 'tests' have been modified to support PSML. The
+environmental variable ONCVPSP_BIN must be set to the location of the
+directory holding the executables.
+
+-- The original installation notes follow
+****
 
                     ONCVPST INSTALLATION AND USAGE
 
diff -Naur oncvpsp-3.2.3/scripts/README oncvpsp-3.2.3--psml-51/scripts/README
--- oncvpsp-3.2.3/scripts/README	2015-08-06 16:05:26.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/scripts/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-The *.sh scripts are replicated in the tests directory.
-
-The first line of fldiff.pl may have to be edited to specify the proper
-location of perl.
diff -Naur oncvpsp-3.2.3/scripts/replot.sh oncvpsp-3.2.3--psml-51/scripts/replot.sh
--- oncvpsp-3.2.3/scripts/replot.sh	2015-08-06 16:05:26.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/scripts/replot.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,26 +0,0 @@
-#!/bin/sh
-#invoking this script with <prefix> as the command-line argument in a
-#directory with a corresponding <prefix>.out file lets you review the
-#graphics that you saw when you ran the calculation.
-
-INFILE=$1.dat
-
-OUTFILE=$1.out
-
-GNUFILE=$$.scr
-
-PLOTFILE=$1.plot
-
-TEMP=$$.tmp
-
-awk 'BEGIN{out=0};/GNUSCRIPT/{out=0}; {if(out == 1) {print}};\
-	/DATA FOR PLOTTING/{out=1}' $OUTFILE >$PLOTFILE
-
-awk 'BEGIN{out=0};/END_GNU/{out=0}; {if(out == 1) {print}};\
-	/GNUSCRIPT/{out=1}' $OUTFILE >$TEMP
-
-sed -e 1,1000s/t1/$PLOTFILE/ $TEMP >$GNUFILE
-
-gnuplot $GNUFILE
-
-rm  $GNUFILE $TEMP $PLOTFILE
diff -Naur oncvpsp-3.2.3/src/Makefile oncvpsp-3.2.3--psml-51/src/Makefile
--- oncvpsp-3.2.3/src/Makefile	2016-09-30 21:35:42.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/Makefile	2017-01-17 17:29:43.000000000 +0100
@@ -1,10 +1,16 @@
-# Makefile for ONCVPSP
+# Makefile for ONCVPSP+psml
 #
 # Copyright (c) 1989-2016 by D. R. Hamann, Mat-Sim Research LLC and Rutgers
 # University
+# Copyright (c) 2015-2016 by Alberto Garcia (PSML part)
 #
-
-include ../make.inc
+include fortran.mk
+#
+.SUFFIXES:
+.SUFFIXES: .f .f90 .F .F90 .o .a
+#
+default: all
+###include ../make.inc
 
 OBJS_ALL =	aeo.o check_data.o const_basis.o dpnint.o eresid.o exchdl.o \
 		exc_off_pbe.o excpzca.o excwig.o ldiracfb.o ldiracfs.o \
@@ -14,51 +20,45 @@
 		sbf_rc_der.o tfapot.o vkboutwf.o vkbphsft.o vout.o vpinteg.o \
 		vploc.o wf_rc_der.o modcore2.o gg1cc.o gp1cc.o gpp1cc.o \
 		der2exc.o modcore3.o
-
 OBJS_NRSR =	fphsft.o fpovlp.o gnu_script.o linout.o psatom.o \
 		relatom.o run_config.o run_diag.o run_phsft.o run_plot.o \
 		run_vkb.o sratom.o upfout.o wellstate.o
-
 OBJS_SR =	oncvpsp.o
-
 OBJS_NR =	oncvpsp_nr.o
-
 OBJS_R =	oncvpsp_r.o fphsft_r.o fpovlp_r.o gnu_script_r.o linout_r.o \
 		psatom_r.o relatom.o renorm_r.o run_config_r.o run_diag_r.o \
 		run_diag_sr_so_r.o run_phsft_r.o run_plot_r.o run_vkb_r.o \
 		sr_so_r.o upfout_r.o wellstate_r.o
+#
+OBJS_PSML = m_psmlout.o m_uuid.o
+#
+m_psmlout.o: m_uuid.o
+exc_off_pbe.o: FFLAGS=$(FFLAGS_NOCHECKS)
 
-OBJS_OPSP = 	$(OBJS_SR) $(OBJS_NRSR) $(OBJS_ALL) $(OBJS_LIBXC)
-
-OBJS_OPSPNR = 	$(OBJS_NR) $(OBJS_NRSR) $(OBJS_ALL) $(OBJS_LIBXC)
-
-OBJS_OPSPR = 	$(OBJS_R) $(OBJS_ALL) $(OBJS_LIBXC)
-
+OBJS_OPSP = 	$(OBJS_SR) $(OBJS_NRSR) $(OBJS_ALL) $(OBJS_LIBXC) $(OBJS_PSML)
+#
+OBJS_OPSPNR = 	$(OBJS_NR) $(OBJS_NRSR) $(OBJS_ALL) $(OBJS_LIBXC) $(OBJS_PSML)
+#
+OBJS_OPSPR = 	$(OBJS_R) $(OBJS_ALL) $(OBJS_LIBXC) $(OBJS_PSML)
+#
+oncvpsp.o oncvpsp_r.o oncvpsp_nr.o: m_psmlout.o
+m_psmlout.o: m_uuid.o
+#
 all:	oncvpsp oncvpspnr oncvpspr
 
-oncvpsp:	$(OBJS_OPSP)
-		$(FLINKER) -o oncvpsp.x $(OBJS_OPSP) $(LIBS)
+oncvpsp:	$(OBJS_OPSP) 
+		$(FLINKER) -o oncvpsp.x $(OBJS_OPSP) $(LIBS) 
 
 oncvpspnr:	$(OBJS_OPSPNR)
 		$(FLINKER) -o oncvpspnr.x $(OBJS_OPSPNR) $(LIBS)
 
-oncvpspr:	$(OBJS_OPSPR)
-		$(FLINKER) -o oncvpspr.x $(OBJS_OPSPR) $(LIBS)
-
-.SUFFIXES: .c .o .f .f90 .F90
-
-.F90.o:
-	$(FCCPP) $(FCCPPFLAGS) $*.F90  > $*_cpp.f90
-	$(F90) $(FFLAGS) $(INC) -o $*.o -c $*_cpp.f90
-
-.f90.o:
-	$(F90) $(FFLAGS) $(INC) -c $*.f90
-
-.f.o:
-	$(F90) $(FFLAGS) $(INC) -c $*.f
+oncvpspr:	$(OBJS_OPSPR) 
+		$(FLINKER) -o oncvpspr.x $(OBJS_OPSPR) $(LIBS) 
+#
 
-.c.o:
-	$(CC) $(CFLAGS) $(INC) -c $*.c
+#.F90.o:
+#	$(FCCPP) $(FCCPPFLAGS) $*.F90  > $*_cpp.f90
+#	$(F90) $(FFLAGS) $(INC) -o $*.o -c $*_cpp.f90
 
 clean:
 	 /bin/rm -f *.o  *.d  *.mod *.log *_cpp.f90
diff -Naur oncvpsp-3.2.3/src/exc_libxc.f90 oncvpsp-3.2.3--psml-51/src/exc_libxc.f90
--- oncvpsp-3.2.3/src/exc_libxc.f90	2016-09-15 16:20:11.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/exc_libxc.f90	2017-01-17 17:29:43.000000000 +0100
@@ -182,3 +182,59 @@
  end do
  
 end subroutine derivs
+
+!
+! Adapted from libxc example in wiki
+! Alberto Garcia, for use by PSML module
+!
+subroutine libxc_info(id,libxc_str,libxc_type)
+  use xc_f90_types_m
+  use xc_f90_lib_m
+
+  implicit none
+
+  integer, intent(in) :: id
+  character(len=*), intent(out) :: libxc_str, libxc_type
+
+  TYPE(xc_f90_pointer_t) :: xc_func
+  TYPE(xc_f90_pointer_t) :: xc_info
+!  integer :: i
+  character(len=120) :: s1, s2
+!  type(xc_f90_pointer_t) :: str
+
+  call xc_f90_func_init(xc_func, xc_info, id, XC_UNPOLARIZED)
+
+  select case(xc_f90_info_kind(xc_info))
+  case(XC_EXCHANGE)
+     libxc_type = 'exchange'
+  case(XC_CORRELATION)
+     libxc_type = 'correlation'
+  case(XC_EXCHANGE_CORRELATION)
+     write(*, '(a)') 'Correlation'
+     libxc_type =  'exchange-correlation'
+  case(XC_KINETIC)
+     write(*, '(a)') 'Correlation'
+     libxc_type =  'kinetic'
+  end select
+
+  call xc_f90_info_name(xc_info, s1)
+  select case(xc_f90_info_family(xc_info))
+  case (XC_FAMILY_LDA);       write(s2,'(a)') "LDA"
+  case (XC_FAMILY_GGA);       write(s2,'(a)') "GGA"
+  case (XC_FAMILY_HYB_GGA);   write(s2,'(a)') "Hybrid GGA"
+  case (XC_FAMILY_MGGA);      write(s2,'(a)') "MGGA"
+  case (XC_FAMILY_HYB_MGGA);  write(s2,'(a)') "Hybrid MGGA"
+  case (XC_FAMILY_LCA);       write(s2,'(a)') "LCA"
+  end select
+  write(libxc_str, '(4a)') trim(s1), ' (', trim(s2), ')'
+
+!  i = 0
+!  call xc_f90_info_refs(xc_info, i, str, s1)
+!  do while(i >= 0)
+!     write(*, '(a,i1,2a)') '[', i, '] ', trim(s1)
+!     call xc_f90_info_refs(xc_info, i, str, s1)
+!  end do
+
+  call xc_f90_func_end(xc_func)
+
+end subroutine libxc_info
diff -Naur oncvpsp-3.2.3/src/exc_libxc_stub.f90 oncvpsp-3.2.3--psml-51/src/exc_libxc_stub.f90
--- oncvpsp-3.2.3/src/exc_libxc_stub.f90	2016-09-15 16:20:11.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/exc_libxc_stub.f90	2017-01-17 17:29:43.000000000 +0100
@@ -38,3 +38,18 @@
  stop
  return
 end subroutine exc_libxc
+!
+! Just a stub
+!
+subroutine libxc_info(id,libxc_str,libxc_type)
+!  dummy substitute to allow successful
+!  build without the libxc library
+  
+
+  implicit none
+
+  integer, intent(in) :: id
+  character(len=*), intent(out) :: libxc_str, libxc_type
+
+end subroutine libxc_info
+
diff -Naur oncvpsp-3.2.3/src/fortran.mk oncvpsp-3.2.3--psml-51/src/fortran.mk
--- oncvpsp-3.2.3/src/fortran.mk	1970-01-01 01:00:00.000000000 +0100
+++ oncvpsp-3.2.3--psml-51/src/fortran.mk	2017-01-17 17:29:43.000000000 +0100
@@ -0,0 +1,67 @@
+#
+# 
+#
+F77        = gfortran	#EDIT
+F90        = gfortran	#EDIT
+CC         = gcc	#EDIT
+RANLIB     = echo
+AR         = ar
+
+FLINKER     = $(F90)
+
+FFLAGS     = -O3 -msse3 #EDIT
+CFLAGS     = -O3		#EDIT
+
+FCCPPFLAGS = -DLIBXC_VERSION=203  #This probably should not be changed
+
+#LIBS = -L/usr/local/opt/lapack/lib -llapack  -L/usr/local/opt/openblas/lib  -lopenblas	#EDIT
+
+#
+# This line works for MacOSX with veclibFort (a patch for Apple's veclib)
+# (See https://github.com/mcg1969/vecLibFort)
+# You might get good results simply with -framework veclib, but your mileage might vary
+# In case of doubt, get any of the fine blas/lapack packages out there.
+#
+LIBS = -lvecLibFort
+
+#
+# The xmlf90 library (its wxml subsystem) is needed to generate XML.
+# You can download xmlf90 from http://launchpad.net/xmlf90
+#
+XMLF90_ROOT=$(HOME)/lib/gfortran-5.2.0/xmlf90-1.5.0
+LIBS += -L$(XMLF90_ROOT)/lib -lxmlf90
+INC += -I$(XMLF90_ROOT)/include
+
+#
+# Optional LIBXC support
+
+# oncvpsp is presently compatible with libxc-2.0.3, not later releases (???)
+
+# To build oncvpsp with libxc, use the following lines and edit
+# the paths to point to your libxc library and include directories
+# make clean in src before rebuilding after changing this
+#
+LIBXC_ROOT=$(HOME)/lib/libxc/2.2.0/gfortran-5.2.0
+LIBS += -L$(LIBXC_ROOT)/lib -lxc -lxcf90
+INC += -I$(LIBXC_ROOT)/include
+OBJS_LIBXC =	functionals.o exc_libxc.o
+#
+# Otherwise, use only the following line
+#
+#OBJS_LIBXC =	exc_libxc_stub.o
+#
+#-------------------------------------------
+
+
+#
+
+#
+.f90.o:
+	$(F90) $(FFLAGS) $(INC) -c $*.f90
+.F90.o:
+	$(F90) $(FFLAGS) $(FCCPPFLAGS) $(INC) -c $*.F90
+.f.o:
+	$(F90) $(FFLAGS) $(INC) -c $*.f
+.F.o:
+	$(F90) $(FFLAGS) $(FCCPPFLAGS) $(INC) -c $*.F
+
diff -Naur oncvpsp-3.2.3/src/gnu_script.f90 oncvpsp-3.2.3--psml-51/src/gnu_script.f90
--- oncvpsp-3.2.3/src/gnu_script.f90	2016-09-15 16:20:11.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/gnu_script.f90	2017-01-17 17:29:43.000000000 +0100
@@ -134,7 +134,7 @@
 
  write(6,'(a)') 'GNUSCRIPT'
 
- set='set term wxt font "arial,14" size 800,600'
+ set='set term x11 font "arial,14" size 800,600'
  write(6,'(a/)') trim(set)
  set='set termoption dash'
  write(6,'(a/)') trim(set)
diff -Naur oncvpsp-3.2.3/src/gnu_script_r.f90 oncvpsp-3.2.3--psml-51/src/gnu_script_r.f90
--- oncvpsp-3.2.3/src/gnu_script_r.f90	2016-09-15 16:20:11.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/gnu_script_r.f90	2017-01-17 17:29:43.000000000 +0100
@@ -178,7 +178,7 @@
 
  write(6,'(a)') 'GNUSCRIPT'
 
- set='set term wxt font "arial,14" size 800,600'
+ set='set term x11 font "arial,14" size 800,600'
  write(6,'(a/)') trim(set)
  set='set termoption dash'
  write(6,'(a/)') trim(set)
diff -Naur oncvpsp-3.2.3/src/m_psmlout.f90 oncvpsp-3.2.3--psml-51/src/m_psmlout.f90
--- oncvpsp-3.2.3/src/m_psmlout.f90	1970-01-01 01:00:00.000000000 +0100
+++ oncvpsp-3.2.3--psml-51/src/m_psmlout.f90	2017-01-17 17:29:43.000000000 +0100
@@ -0,0 +1,1438 @@
+!
+! Copyright (c) 1989-2015 by D. R. Hamann, Mat-Sim Research LLC and Rutgers
+! University
+! Copyright (c) 2015-2017 by Alberto Garcia, ICMAB-CSIC, for PSML output
+!
+! 
+! This program is free software: you can redistribute it and/or modify
+! it under the terms of the GNU General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+! 
+! This program is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU General Public License for more details.
+! 
+! You should have received a copy of the GNU General Public License
+! along with this program.  If not, see <http://www.gnu.org/licenses/>.
+!
+! Support for PSML file creation
+!
+module m_psmlout
+
+  
+  public :: psmlout, psmlout_r, copy_input_file_for_psml
+  private
+
+  integer, parameter :: dp = selected_real_kind(10,100)
+  character(len=1), dimension(0:4) :: lsymb = (/'s','p','d','f','g'/)
+  
+  character(len=*), parameter :: PSML_VERSION = "1.0"
+  character(len=*), parameter, public :: PSML_CREATOR = "ONCVPSP-3.2.3+psml-51"
+  character(len=*), parameter :: PSML_FILENAME = "ONCVPSPPSML"
+
+  CONTAINS
+
+ subroutine psmlout(lmax,lloc,rc,vkb,evkb,nproj,rr,vpuns,rho,rhomod, &
+&                  irct, srel, &
+&                  zz,zion,mmax,iexc,icmod,nrl0,drl,atsym,epstot, &
+&                  na,la,ncon,nbas,nvcnf,nacnf,lacnf,nc,nv,lpopt,ncnf, &
+&                  fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
+&                  epsh1,epsh2,depsh,rlmax,psfile,uua)
+
+!lmax  maximum angular momentum
+!lloc  l for local potential
+!rc  core radii
+!vkb  VKB projectors
+!evkb  coefficients of VKB projectors
+!nproj  number of vkb projectors for each l
+!rr  log radial grid
+!vpuns  unscreened semi-local pseudopotentials (vp(:,5) is local potential 
+!  if linear combination is used)
+!rho  valence pseudocharge
+!rhomod  model core charge
+!zz  atomic number
+!zion  at this point, total valence charge (becomes pseudoion charge)
+!mmax  size of log radial grid
+!iexc  type of exchange-correlation
+!icmod  1 if model core charge is used, otherwise 0
+!nrl0 suggested size of linear radial grid in input file
+!drl spacing of linear radial grid
+!atsym  atomic symbol
+!epstot  pseudoatom total energy
+!psfile  should be 'upf' or 'psp8'
+!uua pseudo-atomic orbital array
+
+  ! Alberto Garcia, February 1, 2015
+
+  use xmlf90_wxml     ! To write XML files
+  use m_uuid        ! To generate uuid
+
+ implicit none
+
+ real(dp), parameter :: pi=3.141592653589793238462643383279502884197_dp
+
+!Input variables
+ integer :: lmax,lloc,iexc,mmax,nrl0,icmod
+ integer :: nproj(6)
+ integer :: irct ! index of point at which rho_core is matched
+ logical :: srel ! whether it is scalar-relativistic or not
+ real(dp) :: drl,fcfact,zz,zion,epstot
+ real(dp), target :: rr(mmax),vpuns(mmax,5),rho(mmax),vkb(mmax,2,4)
+ real(dp), target :: rhomod(mmax,5)
+ real(dp):: rc(6),evkb(2,4)
+ character*2 :: atsym
+ character(len=40) :: fname
+
+!additional input for upf output to echo input file, all as defined
+! in the main progam
+ integer :: na(30),la(30),ncon(6),nbas(6)
+ integer :: nvcnf(5),nacnf(30,5),lacnf(30,5)
+ integer :: nc,nv,lpopt,ncnf
+ real(dp) :: fa(30),rc0(6),ep(6),qcut(6),debl(6),facnf(30,5)
+ real(dp) :: dvloc0,epsh1,epsh2,depsh,rlmax
+ character*4 :: psfile
+ real(dp) :: uua(mmax,nv)
+
+!Local variables
+ integer :: dtime(8), nrl
+ logical :: nrl_changed
+
+!-------
+!psml stuff
+
+  type(xmlf_t) :: xf
+
+  integer   :: i, j, npts
+  integer   :: ii, jj, l1
+  real(dp)  :: rcore
+  real(dp)  :: total_valence_charge
+  real(dp), pointer :: r(:), chval(:), chcore(:)
+  real(dp), pointer :: vps(:), vlocal(:)
+  real(dp), allocatable :: r0(:), f0(:), div_by_r(:)
+  character(len=100)    :: line
+  character*4      :: polattrib, coreattrib
+  character*1      :: pscode, char_dummy
+  character(len=2) :: nameat
+  character(len=40):: psflavor
+
+  character(len=1), dimension(0:4) :: lsymb = (/'s','p','d','f','g'/)
+
+  integer          :: ncore, nval, ncp, norbs, npots
+
+  integer, allocatable  :: n(:), l(:)
+  integer, allocatable  :: nn(:), ll(:)
+  real(dp), allocatable :: f(:), ff(:)
+  real(dp), allocatable :: fdown(:), fup(:)
+
+  character(len=10)     :: datestr
+
+  logical :: tdopsp, nonrel, polarized, there_is_core, found
+  integer :: lun, stat
+
+  external :: dpnint   ! Resampler + extrapolator to r=0
+
+!---
+
+ call date_and_time(VALUES=dtime)
+ write(datestr,"(i4,'-',i2.2,'-',i2.2)") dtime(1:3)
+
+  call xml_OpenFile(PSML_FILENAME,xf, indent=.false.)
+
+  call xml_AddXMLDeclaration(xf,"UTF-8")
+
+  call xml_NewElement(xf,"psml")
+  call my_add_attribute(xf,"version",PSML_VERSION)
+  call my_add_attribute(xf,"energy_unit","hartree")
+  call my_add_attribute(xf,"length_unit","bohr")
+  call my_add_attribute(xf,"uuid",generate_uuid(version=1))
+
+  call xml_NewElement(xf,"provenance")
+  call my_add_attribute(xf,"creator",PSML_CREATOR)
+  call my_add_attribute(xf,"date",datestr)
+  call xml_NewElement(xf,"input-file")
+  call my_add_attribute(xf,"name","oncvpsp-input")
+!
+!    Use INP_COPY (generated in the main program)
+!
+  call cdata_section_from_file(xf,"INP_COPY")
+
+  call xml_EndElement(xf,"input-file")
+  !
+  call xml_EndElement(xf,"provenance")
+
+!  nameat = symbol(nint(zz))
+  nameat = atsym
+  ncore  = nc
+  nval   = nv
+
+  norbs = ncore + nval
+  allocate (n(norbs), l(norbs), f(norbs))
+
+  total_valence_charge = 0.0_dp
+  ncp = ncore + 1
+  do i = 1, norbs
+     n(i) = na(i)
+     l(i) = la(i)
+     f(i) = fa(i)
+     if (i > ncore) then
+        total_valence_charge =   total_valence_charge + f(i)
+     endif
+  enddo
+  lmax = lmax
+
+  npots = lmax + 1
+  allocate (ll(npots), nn(npots), ff(npots))
+  do i = 1, npots
+     ll(i) = i - 1
+     found = .false.
+     ! look for the appropriate shell in the valence
+     do j = ncp, norbs
+        if (l(j) == ll(i)) then
+           found = .true.
+           nn(i) = n(j)
+           ff(i) = f(j)
+           exit
+        endif
+     enddo
+     if (.not. found) then
+        ! generate the appropriate effective n
+        nn(i) = ll(i) + 1
+        do j = 1, ncore
+           if (l(j) == ll(i)) then
+              nn(i) = nn(i) + 1
+           endif
+           ff(i) = 0.0_dp
+        enddo
+     endif
+  enddo
+
+  psflavor ="Hamann's oncvpsp"
+
+  polarized = .false.
+  polattrib = "no"
+  there_is_core = (icmod >= 1)
+  if (there_is_core) then
+     coreattrib = "yes"
+  else
+     coreattrib = "no"
+  endif
+
+  !
+  !
+  call xml_NewElement(xf,"header")
+  call my_add_attribute(xf,"atomic-label",nameat)
+  call my_add_attribute(xf,"atomic-number",str(zz))
+  call my_add_attribute(xf,"z-pseudo",str(zion))
+  call my_add_attribute(xf,"flavor",psflavor)
+  if (srel) then
+     call my_add_attribute(xf,"relativity","scalar")
+  else
+     call my_add_attribute(xf,"relativity","no")
+  endif
+  call my_add_attribute(xf,"polarized",polattrib)
+  call my_add_attribute(xf,"core-corrections",coreattrib)
+
+  ! XC name handling
+  call exchange_correlation_info(xf,iexc)
+  !
+  call configuration_info()
+  call xml_EndElement(xf,"header")
+
+!AG: save
+   if(lloc==4) then
+       ! fitted local potential
+   else
+       ! 'l_local="',lloc,'"'
+   end if
+!AG -- decide how to handle the case of Vlocal as one of the sl pots.
+
+
+!AG: decide whether to use a single mesh (Hamann's own) or have the
+! projectors use another one (linear, shorter)
+
+ npts = mmax
+ nrl  = nrl0
+
+ allocate(div_by_r(mmax))
+ r => rr(:)
+ chval => rho(:)
+ chcore => rhomod(:,1)
+
+  allocate(r0(nrl))
+  do  ii=1,nrl
+     r0(ii)=drl*dble(ii-1)
+  end do
+
+  call xml_NewElement(xf,"grid")
+  call my_add_attribute(xf,"npts",str(nrl))
+
+  call xml_NewElement(xf,"annotation")
+  call my_add_attribute(xf,"type","linear with r=0")
+  if (nrl_changed) then
+     call my_add_attribute(xf,"oncvpsp-suggested-nrl",str(nrl0))
+  endif
+  call my_add_attribute(xf,"oncvpsp-nrl",str(nrl))
+  call my_add_attribute(xf,"oncvpsp-drl",trim(str(drl)))
+  call xml_EndElement(xf,"annotation")
+
+  call xml_NewElement(xf,"grid-data")
+  call xml_AddArray(xf,r0(1:nrl))
+  call xml_EndElement(xf,"grid-data")
+
+  call xml_EndElement(xf,"grid")
+
+  call xml_NewElement(xf,"semilocal-potentials")
+  if (srel) then
+     call my_add_attribute(xf,"set","scalar_relativistic")
+  else
+     call my_add_attribute(xf,"set","non_relativistic")
+  endif
+  !  
+  allocate(f0(nrl))
+  vpsd: do i = 1, npots
+     vps => vpuns(:,i)
+     ! For linear grid:  (assuming r0 and nrl have been set earlier)
+     ! This call resamples vps onto r0, and extrapolates to r=0
+     ! In future we might select 'npoly' instead of using the hardwired
+     ! value of '7'.
+     call dpnint(r,vps,npts,r0,f0,nrl)
+     call write_psml_item(xf, class="slps", &
+                          n=nn(i), l=ll(i), &
+                          rc=rc(i),flavor=psflavor,&
+                          f=f0)
+  enddo vpsd
+  call xml_EndElement(xf,"semilocal-potentials")
+!
+!--------
+! Check that the range of the linear grid is appropriate to hold the orbitals
+! (and, by implication, the charge density) correctly
+
+  call get_new_nrl(nrl0,drl,mmax,rr,nv,uua,nrl,nrl_changed)
+
+  call xml_NewElement(xf,"valence-charge")
+  call my_add_attribute(xf,"total-charge",  &
+                      str(total_valence_charge))
+  call xml_NewElement(xf,"radfunc")
+
+  if (nrl_changed) then
+     deallocate(r0,f0)
+     allocate(r0(nrl),f0(nrl))
+     do  ii=1,nrl
+        r0(ii)=drl*dble(ii-1)
+     end do
+
+     call xml_NewElement(xf,"grid")
+     call my_add_attribute(xf,"npts",str(nrl))
+
+     call xml_NewElement(xf,"annotation")
+      call my_add_attribute(xf,"type","linear with r=0")
+      call my_add_attribute(xf,"oncvpsp-nrl-adjusted",str(nrl))
+      call my_add_attribute(xf,"oncvpsp-drl",trim(str(drl)))
+     call xml_EndElement(xf,"annotation")
+
+     call xml_NewElement(xf,"grid-data")
+     call xml_AddArray(xf,r0(1:nrl))
+     call xml_EndElement(xf,"grid-data")
+
+     call xml_EndElement(xf,"grid")
+  endif
+     
+  call xml_NewElement(xf,"data")
+  call dpnint(r,chval,npts,r0,f0,nrl)
+  call check_grid(r,chval,npts,r0,f0,nrl,"chval.check")
+  call xml_AddArray(xf,f0(1:nrl))
+  call xml_EndElement(xf,"data")
+  call xml_EndElement(xf,"radfunc")
+  call xml_EndElement(xf,"valence-charge")
+
+  if (nrl_changed) then
+     ! Go back to the standard grid
+     deallocate(r0,f0)
+     nrl = nrl0
+     allocate(r0(nrl),f0(nrl))
+     do  ii=1,nrl
+        r0(ii)=drl*dble(ii-1)
+     end do
+  endif
+
+  if (there_is_core) then
+     rcore = rr(irct)
+     call xml_NewElement(xf,"pseudocore-charge")
+     call my_add_attribute(xf,"matching-radius",str(rcore))
+     call my_add_attribute(xf,"number-of-continuous-derivatives", &
+                                    str(4))
+     call xml_NewElement(xf,"annotation")
+     select case (icmod)
+        case (1)
+           call my_add_attribute(xf,"model-charge-form",  &
+                "Polynomial")
+        case (2)
+           call my_add_attribute(xf,"model-charge-form",  &
+                "Teter function fitted using value and slope")
+        case (3)
+           call my_add_attribute(xf,"model-charge-form",  &
+                "Teter function with specified parameters")
+        case (4)
+           call my_add_attribute(xf,"model-charge-form",  &
+                "Teter function optimized using XC hardness")
+        end select
+     call xml_EndElement(xf,"annotation")
+        
+     call xml_NewElement(xf,"radfunc")
+
+     call xml_NewElement(xf,"data")
+     call dpnint(r,chcore,npts,r0,f0,nrl)
+     call check_grid(r,chcore,npts,r0,f0,nrl,"chcore.check")
+     call xml_AddArray(xf,f0(1:nrl))
+     call xml_EndElement(xf,"data")
+     call xml_EndElement(xf,"radfunc")
+     call xml_EndElement(xf,"pseudocore-charge")
+     deallocate(chcore)
+  endif
+
+        vlocal => vpuns(:,lloc+1)
+        call xml_NewElement(xf,"local-potential")
+            if (lloc > lmax) then
+               call my_add_attribute(xf,"type","oncv-fit")
+            else
+               call my_add_attribute(xf,"type","l="//str(lloc))
+            endif
+            call xml_NewElement(xf,"radfunc")
+               call xml_NewElement(xf,"data")
+               call dpnint(r,vlocal,npts,r0,f0,nrl)
+               call check_grid(r,vlocal,npts,r0,f0,nrl,"vlocal.check")
+               call xml_AddArray(xf,f0(1:nrl))
+               call xml_EndElement(xf,"data")
+            call xml_EndElement(xf,"radfunc")
+        call xml_EndElement(xf,"local-potential")
+
+      call xml_NewElement(xf,"nonlocal-projectors")
+      if (srel) then
+         call my_add_attribute(xf,"set","scalar_relativistic")
+      else
+         call my_add_attribute(xf,"set","non_relativistic")
+      endif
+
+      do l1=1,lmax+1
+         if(l1==lloc+1) cycle
+         do jj=1,nproj(l1)
+            ! Store projectors without r factor
+            div_by_r(:) = vkb(:,jj,l1)/r(:)
+            call dpnint(r,div_by_r,npts,r0,f0,nrl)
+            write(fname,"(a,i1,a,i1,a)") "vkb.", l1-1, ".", jj,".check"
+            call check_grid(r,div_by_r,npts,r0,f0,nrl,fname)
+            call write_psml_item(xf, class="proj", &
+                                 seq=jj, l=l1-1, &
+                                 ekb=evkb(jj,l1), &
+                                 type="oncv", f=f0)
+         enddo
+      enddo
+      call xml_EndElement(xf,"nonlocal-projectors")
+
+  call xml_EndElement(xf,"psml")
+
+
+  call xml_Close(xf)
+
+  deallocate(f0,r0, div_by_r)
+
+CONTAINS
+  subroutine configuration_info()
+
+  call xml_NewElement(xf,"valence-configuration")
+  call my_add_attribute(xf,"total-valence-charge", str(total_valence_charge))
+  do i = ncp, norbs
+     if (f(i) .lt. 1.0e-10_dp) cycle
+     call xml_NewElement(xf,"shell")
+     call my_add_attribute(xf,"n",str(n(i)))
+     call my_add_attribute(xf,"l",lsymb(l(i)))
+     call my_add_attribute(xf,"occupation",str(f(i)))
+     if (polarized) then
+        call my_add_attribute(xf,"occupation-down",str(fdown(i)))
+        call my_add_attribute(xf,"occupation-up",str(fup(i)))
+     endif
+     call xml_EndElement(xf,"shell")
+  enddo
+  call xml_EndElement(xf,"valence-configuration")
+end subroutine configuration_info
+
+end subroutine psmlout
+!
+!=================================================
+! Fully relativistic version
+!
+ subroutine psmlout_r(lmax,lloc,rc,vkb,evkb,nproj,rr,vpuns,rho,rhomod, &
+&                  irct, &
+&                  vsr,esr,vso,eso, &
+&                  zz,zion,mmax,iexc,icmod,nrl0,drl,atsym,epstot, &
+&                  na,la,ncon,nbas,nvcnf,nacnf,lacnf,nc,nv,lpopt,ncnf, &
+&                  fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
+&                  epsh1,epsh2,depsh,rlmax,psfile,uua)
+
+!lmax  maximum angular momentum
+!lloc  l for local potential
+!rc  core radii
+!vkb  VKB projectors
+!evkb  coefficients of VKB projectors
+!nproj  number of vkb projectors for each l
+!rr  log radial grid
+!vpuns  unscreened semi-local pseudopotentials (vp(:,5) is local potential 
+!  if linear combination is used)
+!rho  valence pseudocharge
+!rhomod  model core charge
+!zz  atomic number
+!zion  at this point, total valence charge (becomes pseudoion charge)
+!mmax  size of log radial grid
+!iexc  type of exchange-correlation
+!icmod  1 if model core charge is used, otherwise 0
+!nrl size of linear radial grid
+!drl spacing of linear radial grid
+!atsym  atomic symbol
+!epstot  pseudoatom total energy
+!psfile  should be 'upf' or 'psp8'
+!uua pseudo-atomic orbital array
+
+  ! Alberto Garcia, February 1, 2015
+
+  use xmlf90_wxml     ! To write XML files
+  use m_uuid        ! To generate uuid
+
+ implicit none
+
+ real(dp), parameter :: pi=3.141592653589793238462643383279502884197_dp
+
+!Input variables
+ integer :: lmax,lloc,iexc,mmax,nrl0,icmod
+ integer :: nproj(6)
+ integer :: irct ! index of point at which rho_core is matched
+ real(dp) :: drl,fcfact,zz,zion,epstot
+ real(dp), target :: rr(mmax),vpuns(mmax,5,2),rho(mmax),vkb(mmax,2,4,2)
+ real(dp), target :: rhomod(mmax,5)
+ real(dp):: rc(6),evkb(2,4,2)
+ real(dp), target :: vsr(mmax,4,4),vso(mmax,4,4)
+ real(dp) :: esr(4,4),eso(4,4)
+ character*2 :: atsym
+
+!additional input for upf output to echo input file, all as defined
+! in the main progam
+ integer :: na(30),la(30),ncon(6),nbas(6)
+ integer :: nvcnf(5),nacnf(30,5),lacnf(30,5)
+ integer :: nc,nv,lpopt,ncnf
+ real(dp) :: fa(30),rc0(6),ep(6),qcut(6),debl(6),facnf(30,5)
+ real(dp) :: dvloc0,epsh1,epsh2,depsh,rlmax
+ character*4 :: psfile
+ real(dp) :: uua(mmax,2,nv)
+
+
+!Local variables
+ integer :: dtime(8), nrl
+ logical :: nrl_changed
+ integer :: npr_so(4), npr_sr(4)
+
+  type(xmlf_t) :: xf
+
+  integer   :: i, j, npts
+  integer   :: ii, jj, l1, jk
+  real(dp)  :: rcore, jval
+  real(dp)  :: total_valence_charge
+  real(dp), pointer :: r(:), chval(:), chcore(:)
+  real(dp), pointer :: vlocal(:)
+  real(dp), allocatable :: r0(:), f0(:), vps(:), div_by_r(:)
+
+  character(len=100)    :: line
+  character*4      :: polattrib, coreattrib
+  character*1      :: pscode, char_dummy
+  character(len=2) :: nameat
+  character(len=40):: psflavor
+
+  character(len=1), dimension(0:4) :: lsymb = (/'s','p','d','f','g'/)
+
+  integer          :: ncore, nval, ncp, norbs, npots
+
+  integer, allocatable  :: n(:), l(:)
+  integer, allocatable  :: nn(:), ll(:)
+  real(dp), allocatable :: f(:), ff(:)
+  real(dp), allocatable :: fdown(:), fup(:)
+  character(len=10)     :: datestr
+
+  logical :: tdopsp, nonrel, polarized, there_is_core, found
+  integer :: lun, stat
+
+!---
+
+ call date_and_time(VALUES=dtime)
+ write(datestr,"(i4,'-',i2.2,'-',i2.2)") dtime(1:3)
+
+  call xml_OpenFile(PSML_FILENAME,xf, indent=.false.)
+
+  call xml_AddXMLDeclaration(xf,"UTF-8")
+
+  call xml_NewElement(xf,"psml")
+  call my_add_attribute(xf,"version",PSML_VERSION)
+  call my_add_attribute(xf,"energy_unit","hartree")
+  call my_add_attribute(xf,"length_unit","bohr")
+  call my_add_attribute(xf,"uuid",generate_uuid(version=1))
+
+  call xml_NewElement(xf,"provenance")
+  call my_add_attribute(xf,"creator",PSML_CREATOR)
+  call my_add_attribute(xf,"date",datestr)
+  call xml_NewElement(xf,"input-file")
+  call my_add_attribute(xf,"name","oncvpsp-input")
+!
+!    Use INP_COPY (generated in the main program)
+!                                                                                               
+  call cdata_section_from_file(xf,"INP_COPY")
+  call xml_EndElement(xf,"input-file")
+  !
+  call xml_EndElement(xf,"provenance")
+
+!  nameat = symbol(nint(zz))
+  nameat = atsym
+  ncore  = nc
+  nval   = nv
+
+  norbs = ncore + nval
+  allocate (n(norbs), l(norbs), f(norbs))
+
+  total_valence_charge = 0.0_dp
+  ncp = ncore + 1
+  do i = 1, norbs
+     n(i) = na(i)
+     l(i) = la(i)
+     f(i) = fa(i)
+     if (i > ncore) then
+        total_valence_charge =   total_valence_charge + f(i)
+     endif
+  enddo
+  lmax = lmax
+
+  npots = lmax + 1
+  allocate (ll(npots), nn(npots), ff(npots))
+  do i = 1, npots
+     ll(i) = i - 1
+     found = .false.
+     ! look for the appropriate shell in the valence
+     do j = ncp, norbs
+        if (l(j) == ll(i)) then
+           found = .true.
+           nn(i) = n(j)
+           ff(i) = f(j)
+           exit
+        endif
+     enddo
+     if (.not. found) then
+        ! generate the appropriate effective n
+        nn(i) = ll(i) + 1
+        do j = 1, ncore
+           if (l(j) == ll(i)) then
+              nn(i) = nn(i) + 1
+           endif
+           ff(i) = 0.0_dp
+        enddo
+     endif
+  enddo
+
+  psflavor ="Hamann's oncvpsp"
+
+  polarized = .false.
+  polattrib = "no"
+  there_is_core = (icmod >= 1)
+  if (there_is_core) then
+     coreattrib = "yes"
+  else
+     coreattrib = "no"
+  endif
+
+  call xml_NewElement(xf,"header")
+  call my_add_attribute(xf,"atomic-label",nameat)
+  call my_add_attribute(xf,"atomic-number",str(zz))
+  call my_add_attribute(xf,"z-pseudo",str(zion))
+  call my_add_attribute(xf,"flavor",psflavor)
+  call my_add_attribute(xf,"relativity","dirac")
+  call my_add_attribute(xf,"polarized",polattrib)
+  call my_add_attribute(xf,"core-corrections",coreattrib)
+
+  ! XC name handling
+  call exchange_correlation_info(xf,iexc)
+  !
+  call configuration_info()
+  call xml_EndElement(xf,"header")
+
+!AG: save
+   if(lloc==4) then
+       ! fitted local potential
+   else
+       ! 'l_local="',lloc,'"'
+   end if
+!AG -- decide how to handle the case of Vlocal as one of the sl pots.
+
+
+!AG: decide whether to use a single mesh (Hamann's own) or have the
+! projectors use another one (linear, shorter)
+
+ npts = mmax
+ nrl  = nrl0
+
+ allocate(div_by_r(mmax))
+ r => rr(:)
+ chval => rho(:)
+ chcore => rhomod(:,1)
+ allocate(vps(npts))
+
+  allocate(r0(nrl))
+  do  ii=1,nrl
+     r0(ii)=drl*dble(ii-1)
+  end do
+
+  call xml_NewElement(xf,"grid")
+  call my_add_attribute(xf,"npts",str(nrl))
+
+  call xml_NewElement(xf,"annotation")
+  call my_add_attribute(xf,"type","linear with r=0")
+  if (nrl_changed) then
+     call my_add_attribute(xf,"oncvpsp-suggested-nrl",str(nrl0))
+  endif
+  call my_add_attribute(xf,"oncvpsp-nrl",str(nrl))
+  call my_add_attribute(xf,"oncvpsp-drl",trim(str(drl)))
+  call xml_EndElement(xf,"annotation")
+
+  call xml_NewElement(xf,"grid-data")
+  call xml_AddArray(xf,r0(1:nrl))
+  call xml_EndElement(xf,"grid-data")
+
+  call xml_EndElement(xf,"grid")
+
+  !  
+  ! Semilocal potentials
+  !
+  allocate(f0(nrl))
+
+  if (trim(psfile)=="psp8") then
+
+     call xml_NewElement(xf,"semilocal-potentials")
+     call my_add_attribute(xf,"set","scalar_relativistic")
+! sr components
+    do i = 1, npots
+     l1 = i
+     ! last index:  1: j=l+1/2; 2: j=l-1/2; l=0,j=0 stored in index 1
+     vps(:) = ((ll(i)+1)*vpuns(:,l1,1)+ ll(i)*vpuns(:,l1,2)) / dble(2*ll(i)+1)
+     call dpnint(r,vps,npts,r0,f0,nrl)
+     call write_psml_item(xf, class="slps", &
+                          n=nn(i), l=ll(i), &
+                          rc=rc(i),flavor=psflavor,&
+                          f=f0)
+  enddo
+  call xml_EndElement(xf,"semilocal-potentials")
+!
+! so components
+!
+  call xml_NewElement(xf,"semilocal-potentials")
+   call my_add_attribute(xf,"set","spin_orbit")
+
+ do i = 2, npots
+     l1 = i
+     vps(:) = 2*(vpuns(:,l1,1) - vpuns(:,l1,2)) / dble(2*ll(i)+1)
+     call dpnint(r,vps,npts,r0,f0,nrl)
+     call write_psml_item(xf, class="slps", &
+                          n=nn(i), l=ll(i), &
+                          rc=rc(i),flavor=psflavor,&
+                          f=f0)
+  enddo
+
+  call xml_EndElement(xf,"semilocal-potentials")
+
+  else   ! upf
+
+     call xml_NewElement(xf,"semilocal-potentials")
+     call my_add_attribute(xf,"set","lj")
+
+     do i = 1, npots
+        l1 = i
+        if (i == 1) then
+           jval = 0.0
+           ! last index:  1: j=l+1/2; 2: j=l-1/2; l=0,j=0 stored in index 1
+           vps(:) = vpuns(:,l1,1)
+           call dpnint(r,vps,npts,r0,f0,nrl)
+           call write_psml_item(xf, class="slps", &
+                          n=nn(i), l=ll(i), j=jval, &
+                          rc=rc(i),flavor=psflavor,&
+                          f=f0)
+        else
+           do jj=1,2
+              jval = ll(i) + (3-2*jj)*0.5  ! convert (1,2) to (1,-1)*1/2
+              ! last index:  1: j=l+1/2; 2: j=l-1/2; l=0,j=0 stored in index 1
+              vps(:) = vpuns(:,l1,jj)
+              call dpnint(r,vps,npts,r0,f0,nrl)
+              call write_psml_item(xf, class="slps", &
+                          n=nn(i), l=ll(i), j=jval, &
+                          rc=rc(i),flavor=psflavor,&
+                          f=f0)
+           enddo
+        endif
+     enddo
+     call xml_EndElement(xf,"semilocal-potentials")
+
+  endif ! upf vs psp8
+!
+!--------
+! Check that the range of the linear grid is appropriate to hold the orbitals
+! (and, by implication, the charge density) correctly
+
+  call get_new_nrl_r(nrl0,drl,mmax,rr,nc,nv,la,uua,nrl,nrl_changed)
+
+  call xml_NewElement(xf,"valence-charge")
+  call my_add_attribute(xf,"total-charge",  &
+                      str(total_valence_charge))
+  call xml_NewElement(xf,"radfunc")
+
+  if (nrl_changed) then
+     deallocate(r0,f0)
+     allocate(r0(nrl),f0(nrl))
+     do  ii=1,nrl
+        r0(ii)=drl*dble(ii-1)
+     end do
+
+     call xml_NewElement(xf,"grid")
+     call my_add_attribute(xf,"npts",str(nrl))
+
+     call xml_NewElement(xf,"annotation")
+      call my_add_attribute(xf,"type","linear with r=0")
+      call my_add_attribute(xf,"oncvpsp-nrl-adjusted",str(nrl))
+      call my_add_attribute(xf,"oncvpsp-drl",trim(str(drl)))
+     call xml_EndElement(xf,"annotation")
+
+     call xml_NewElement(xf,"grid-data")
+     call xml_AddArray(xf,r0(1:nrl))
+     call xml_EndElement(xf,"grid-data")
+
+     call xml_EndElement(xf,"grid")
+  endif
+     
+  call xml_NewElement(xf,"data")
+  call dpnint(r,chval,npts,r0,f0,nrl)
+  call check_grid(r,chval,npts,r0,f0,nrl,"chval.check")
+  call xml_AddArray(xf,f0(1:nrl))
+  call xml_EndElement(xf,"data")
+  call xml_EndElement(xf,"radfunc")
+  call xml_EndElement(xf,"valence-charge")
+
+  if (nrl_changed) then
+     ! Go back to the standard grid
+     deallocate(r0,f0)
+     nrl = nrl0
+     allocate(r0(nrl),f0(nrl))
+     do  ii=1,nrl
+        r0(ii)=drl*dble(ii-1)
+     end do
+  endif
+
+  if (there_is_core) then
+     rcore = rr(irct)
+     call xml_NewElement(xf,"pseudocore-charge")
+     call my_add_attribute(xf,"matching-radius",str(rcore))
+     call my_add_attribute(xf,"number-of-continuous-derivatives", &
+          str(4))
+     
+     call xml_NewElement(xf,"annotation")
+
+     select case (icmod)
+        case (1)
+           call my_add_attribute(xf,"model-charge-form",  &
+                "Polynomial")
+        case (2)
+           call my_add_attribute(xf,"model-charge-form",  &
+                "Teter function fitted using value and slope")
+        case (3)
+           call my_add_attribute(xf,"model-charge-form",  &
+                "Teter function with specified parameters")
+        case (4)
+           call my_add_attribute(xf,"model-charge-form",  &
+                "Teter function optimized using XC hardness")
+        end select
+     call xml_EndElement(xf,"annotation")
+        
+     call xml_NewElement(xf,"radfunc")
+
+     call xml_NewElement(xf,"data")
+     call dpnint(r,chcore,npts,r0,f0,nrl)
+     call check_grid(r,chcore,npts,r0,f0,nrl,"chcore.check")
+     call xml_AddArray(xf,f0(1:nrl))
+     call xml_EndElement(xf,"data")
+     call xml_EndElement(xf,"radfunc")
+     call xml_EndElement(xf,"pseudocore-charge")
+     deallocate(chcore)
+  endif
+
+        vlocal => vpuns(:,lloc+1,1)
+        call xml_NewElement(xf,"local-potential")
+            if (lloc > lmax) then
+               call my_add_attribute(xf,"type","oncv-fit")
+            else
+               call my_add_attribute(xf,"type","l="//str(lloc))
+            endif
+            call xml_NewElement(xf,"radfunc")
+               call xml_NewElement(xf,"data")
+               call dpnint(r,vlocal,npts,r0,f0,nrl)
+               call check_grid(r,vlocal,npts,r0,f0,nrl,"vlocal.check")
+               call xml_AddArray(xf,f0(1:nrl))
+               call xml_EndElement(xf,"data")
+            call xml_EndElement(xf,"radfunc")
+        call xml_EndElement(xf,"local-potential")
+
+!
+!     Scalar-relativistic projectors
+!
+  if (trim(psfile)=="psp8") then
+
+! set up projector number for sr_so calculations based on non-zero coefficients
+  npr_sr(:)=0 
+  npr_so(:)=0
+  do l1=1,lmax+1
+   do ii=1,4
+    if(abs(esr(ii,l1))>0.0d0) npr_sr(l1)=npr_sr(l1)+1
+    if(abs(eso(ii,l1))>0.0d0) npr_so(l1)=npr_so(l1)+1
+   end do
+  end do
+
+      call xml_NewElement(xf,"nonlocal-projectors")
+      call my_add_attribute(xf,"set","scalar_relativistic")
+ 
+      do l1=1,lmax+1
+         if(l1==lloc+1) cycle
+         do jj=1,npr_sr(l1)
+            ! Store projectors without r factor
+            div_by_r(:) = vsr(:,jj,l1)/r(:)
+            call dpnint(r,div_by_r,npts,r0,f0,nrl)
+            call write_psml_item(xf, class="proj", &
+                                 seq=jj, l=l1-1, &
+                                 ekb=esr(jj,l1), &
+                                 type="oncv", f=f0)
+         enddo
+      enddo
+      call xml_EndElement(xf,"nonlocal-projectors")
+!
+!     Spin-orbit part
+!
+      call xml_NewElement(xf,"nonlocal-projectors")
+      call my_add_attribute(xf,"set","spin_orbit")
+
+      do l1=2,lmax+1
+         if(l1==lloc+1) cycle
+         do jj=1,npr_so(l1)
+            ! Store projectors without r factor
+            div_by_r(:) = vso(:,jj,l1)/r(:)
+            call dpnint(r,div_by_r,npts,r0,f0,nrl)
+            call write_psml_item(xf, class="proj", &
+                                 seq=jj, l=l1-1, &
+                                 ekb=eso(jj,l1), &
+                                 type="oncv", f=f0)
+         enddo
+      enddo
+
+      call xml_EndElement(xf,"nonlocal-projectors")
+
+ else  ! upf
+
+      call xml_NewElement(xf,"nonlocal-projectors")
+      call my_add_attribute(xf,"set","lj")
+
+      do l1=1,lmax+1
+         if(l1==lloc+1) cycle
+
+         if (l1 == 1) then
+            ! l=0, only one j=0
+            jval = 0.0
+
+            do jj=1,nproj(l1)
+               ! Store projectors without r factor
+               div_by_r(:) = vkb(:,jj,l1,1)/r(:)
+               call dpnint(r,div_by_r,npts,r0,f0,nrl)
+               call write_psml_item(xf, class="proj", &
+                                 seq=jj, l=l1-1, j=jval, &
+                                 ekb=evkb(jj,l1,1), &
+                                 type="oncv", f=f0)
+            enddo
+
+         else  ! l1 /=1  (l/=0)
+
+           ! two j values
+           do jk=1,2
+              jval = l1-1 + (3-2*jk)*0.5  ! convert (1,2) to (1,-1)*1/2
+              do jj=1,nproj(l1)
+                 ! Store projectors without r factor
+                 div_by_r(:) = vkb(:,jj,l1,jk)/r(:)
+                 call dpnint(r,div_by_r,npts,r0,f0,nrl)
+                 call write_psml_item(xf, class="proj", &
+                                 seq=jj, l=l1-1, j=jval, &
+                                 ekb=evkb(jj,l1,jk), &
+                                 type="oncv", f=f0)
+              enddo
+           enddo
+
+        endif  ! l1 == 1
+
+      enddo ! over l shells
+      call xml_EndElement(xf,"nonlocal-projectors")
+!
+   endif ! upf vs psp8
+   
+  call xml_EndElement(xf,"psml")
+
+
+  call xml_Close(xf)
+
+  deallocate(f0,r0,div_by_r)
+
+CONTAINS
+  subroutine configuration_info()
+
+  call xml_NewElement(xf,"valence-configuration")
+  call my_add_attribute(xf,"total-valence-charge", str(total_valence_charge))
+  do i = ncp, norbs
+     if (f(i) .lt. 1.0e-10_dp) cycle
+     call xml_NewElement(xf,"shell")
+     call my_add_attribute(xf,"n",str(n(i)))
+     call my_add_attribute(xf,"l",lsymb(l(i)))
+     call my_add_attribute(xf,"occupation",str(f(i)))
+     if (polarized) then
+        call my_add_attribute(xf,"occupation-down",str(fdown(i)))
+        call my_add_attribute(xf,"occupation-up",str(fup(i)))
+     endif
+     call xml_EndElement(xf,"shell")
+  enddo
+  call xml_EndElement(xf,"valence-configuration")
+end subroutine configuration_info
+
+
+end subroutine psmlout_r
+
+     subroutine my_add_attribute(xf,name,value)
+       use xmlf90_wxml, only: xmlf_t, xml_AddAttribute
+
+       type(xmlf_t), intent(inout)   :: xf
+       character(len=*), intent(in)  :: name
+       character(len=*), intent(in)  :: value
+
+       call xml_AddAttribute(xf,name,trim(value))
+     end subroutine my_add_attribute
+
+    subroutine get_unit(lun)
+
+!     Get an available Fortran unit number
+
+      integer, intent(out) ::  lun
+
+      integer i
+      logical unit_used
+
+      do i = 10, 99
+         lun = i
+         inquire(lun,opened=unit_used)
+         if (.not. unit_used) return
+      enddo
+      stop 'NO LUNS'
+    end subroutine get_unit
+
+    subroutine write_psml_item(xf,class, &
+                               n, l, j, s, &
+                               seq, &
+                               rc, ekb, &
+                               flavor, type, set, &
+                               f)
+
+       use xmlf90_wxml
+
+
+       type(xmlf_t), intent(inout)   :: xf
+       character(len=*), intent(in)  :: class
+
+       integer, intent(in), optional  :: n
+       integer, intent(in), optional  :: l
+       real(dp), intent(in), optional  :: j
+       real(dp), intent(in), optional  :: s
+
+       ! for sl potentials
+       real(dp), intent(in), optional  :: rc
+       character(len=*), intent(in), optional  :: flavor
+
+       ! for projectors
+       integer, intent(in), optional   :: seq
+       real(dp), intent(in), optional  :: ekb
+       character(len=*), intent(in), optional  :: type
+
+       character(len=*), intent(in), optional  :: set
+       real(dp), intent(in), optional  :: f(:)
+       
+       call xml_NewElement(xf,trim(class))
+         if (present(set))  call my_add_attribute(xf,"set",set)
+
+         ! we might want to check input values
+         if (present(n))  call my_add_attribute(xf,"n",str(n))
+         if (present(l))  call my_add_attribute(xf,"l",lsymb(l))
+         if (present(j))  call my_add_attribute(xf,"j", &
+                                                str(j,format="(f3.1)"))
+         ! spin: +0.5 or -0.5
+         if (present(s))  call my_add_attribute(xf,"s", &
+                                                str(s,format="(f4.1)"))
+
+         if (present(seq)) call my_add_attribute(xf,"seq",str(seq))
+
+         if (present(rc))  call my_add_attribute(xf,"rc",str(rc))
+         if (present(ekb))  call my_add_attribute(xf,"ekb",str(ekb))
+
+         if (present(flavor))  call my_add_attribute(xf,"flavor",flavor)
+         if (present(type))  call my_add_attribute(xf,"type",type)
+
+         call xml_NewElement(xf,"radfunc")
+           call xml_NewElement(xf,"data")
+           call xml_AddArray(xf,f(:))
+           call xml_EndElement(xf,"data")
+         call xml_EndElement(xf,"radfunc")
+
+       call xml_EndElement(xf,trim(class))
+
+     end subroutine write_psml_item
+
+     subroutine check_grid(r1,v1,n1,rg,vg,ng,fname)
+       integer, intent(in) :: n1, ng
+       real(dp), intent(in), dimension(n1) :: r1, v1
+       real(dp), intent(in), dimension(ng) :: rg, vg
+       character(len=*), intent(in) :: fname
+
+       integer  :: i
+       real(dp) :: v2
+       
+       open(unit=77,file=trim(fname),form="formatted", &
+            status="unknown",action="write",position="rewind")
+       do i = 1, n1
+          if (r1(i) > rg(ng)) exit
+          call dpnint1(7,rg,vg,ng,r1(i),v2,.false.)
+          write(77,"(3es24.16)") r1(i), v1(i), v2
+       end do
+     end subroutine check_grid
+!
+! Copyright (c) 1989-2014 by D. R. Hamann, Mat-Sim Research LLC and Rutgers
+! University
+! 
+! Modified by Alberto Garcia, March 2015
+! This routine is included in this module with permission from D.R. Hamann.
+!
+ subroutine dpnint1(npoly, xx, yy, nn, r, val, debug)
+
+! Modified by Alberto Garcia, March 2015 from routine
+! dpnint by D.R. Hamann. 
+! Changes:
+!   -- A single value is returned
+!   -- It can extrapolate, instead of stopping,
+!      when called with an abscissa outside the
+!      data range.
+!   -- If the number of data points is less than
+!      npoly+1, npoly is implicitly reduced, without
+!      error, and without warning.
+!   -- Debug interface 
+!
+! local polynomial interpolation of data yy on nn points xx
+! giving value val on point r
+! npoly sets order of polynomial
+! xx must be ordered in ascending order
+! output interpolated value val on point r
+
+ implicit none
+
+ integer, parameter :: dp=kind(1.0d0)
+
+!Input variables
+ real(dp), intent(in) :: xx(*),yy(*)
+ real(dp), intent(in) :: r
+ real(dp), intent(out) :: val
+ integer, intent(in)   ::  nn,npoly
+ logical, intent(in)   ::  debug
+
+!Local variables
+ real(dp) :: sum,term,zz
+ integer ii,imin,imax,iprod,iy,istart,kk,iend
+
+! interval halving search for xx(ii) points bracketing r
+
+   imin = 1
+   imax = nn
+   do kk = 1, nn
+     ii = (imin + imax) / 2
+     if(r>xx(ii)) then
+       imin = ii
+     else
+       imax = ii
+     end if
+     if(imax - imin .eq. 1) then
+       exit
+     end if
+   end do
+
+
+   zz=r
+
+!   if (debug) print *, "imin, imax: ", imin, imax
+
+   if(mod(npoly,2)==1) then
+    istart=imin-npoly/2
+   else if(zz-xx(imin) < xx(imax)-zz) then
+     istart=imin-npoly/2
+   else
+     istart=imax-npoly/2
+   end if
+
+   istart = min(istart, nn - npoly)
+   istart = max(istart, 1)
+   iend = min(istart+npoly,nn)
+
+ !  if (debug) print *, "istart, iend: ", istart, iend
+   sum=0.0d0
+   do iy=istart,iend
+    if(yy(iy)==0.0d0) cycle
+    term=yy(iy)
+    do iprod=istart, iend
+     if(iprod==iy) cycle
+     term=term*(zz-xx(iprod))/(xx(iy)-xx(iprod))
+    end do
+    sum=sum+term
+   end do
+   val=sum
+
+ end subroutine dpnint1
+
+ subroutine get_new_nrl(nrl,drl,mmax,rr,nv,uua,nrl_new,nrl_changed)
+   integer, intent(in)  :: nrl, mmax, nv
+   real(dp), intent(in) :: drl, rr(mmax), uua(mmax,nv)
+   integer, intent(out) :: nrl_new
+   logical, intent(out) :: nrl_changed
+
+   real(dp) :: al, uurcut, nrmsum
+   integer  :: ii, jj
+
+! adjust nrl to properly accomodate atomic orbitals
+ nrl_changed = .false.
+ al = dlog(rr(2)/rr(1))
+ uurcut = 0.d0
+ do ii=1,nv
+   nrmsum = 0.d0
+   do jj=mmax,1,-1
+     nrmsum = nrmsum + (uua(jj,ii)**2) * rr(jj)*al
+     if (nrmsum > 1.d-6) then
+       exit  ! Cutoff radius such that uu norm accurate to 10^-6
+     end if
+   end do
+   if (rr(jj) > uurcut) uurcut = rr(jj)  
+ end do
+ if (uurcut > drl*dble(nrl-1)) then
+   nrl_changed = .true.
+   nrl_new = 1 + uurcut/drl
+   if(mod(nrl_new,2)/=0) nrl_new=nrl_new+1
+   write(6,'(a,i5,a,f10.5)') "Updating nrl = ", nrl_new, " for uurcut = ", uurcut
+ end if
+end subroutine get_new_nrl
+
+ subroutine get_new_nrl_r(nrl,drl,mmax,rr,nc,nv,la,uua,nrl_new,nrl_changed)
+   integer, intent(in)  :: nrl, mmax, nc, nv, la(30)
+   real(dp), intent(in) :: drl, rr(mmax), uua(mmax,2,nv)
+   integer, intent(out) :: nrl_new
+   logical, intent(out) :: nrl_changed
+
+   real(dp) :: al, uurcut, nrmsum
+   integer  :: ii, jj, l1, ikap, mkap
+
+! adjust nrl to properly accomodate atomic orbitals
+ nrl_changed = .false.
+ al = dlog(rr(2)/rr(1))
+ uurcut = 0.d0
+ do ii=1,nv
+   l1 = la(nc+ii)
+   if(l1==0) then
+     mkap=1
+   else
+     mkap=2
+   end if
+   do ikap=1,mkap
+     nrmsum = 0.d0
+     do jj=mmax,1,-1
+       nrmsum = nrmsum + (uua(jj,ikap,ii)**2) * rr(jj)*al
+       if (nrmsum > 1.d-6) then
+         exit  ! Cutoff radius such that uu norm accurate to 10^-6
+       end if
+     end do
+     if (rr(jj) > uurcut) uurcut = rr(jj)  
+   end do
+ end do
+ if (uurcut > drl*dble(nrl-1)) then
+   nrl_changed = .true.
+   nrl_new = 1 + uurcut/drl
+   if(mod(nrl_new,2)/=0) nrl_new=nrl_new+1
+   write(6,'(a,i5,a,f10.5)') "Updating nrl = ", nrl_new, " for uurcut = ", uurcut
+ end if
+end subroutine get_new_nrl_r
+
+subroutine copy_input_file_for_psml()
+! Makes two copies of the input file: one for oncvpsp
+! to read, and another to echo the input in the PSML file
+
+      character(len=132) :: line
+      integer            :: stat
+
+      open(unit=55,file='INPUT_FILE',action='write',status='replace', &
+           form='formatted')
+      open(unit=66,file='INP_COPY',action='write',status='replace', &
+           form='formatted')
+      do
+         read(5,fmt="(a)",iostat=stat) line
+         if (stat .ne. 0) exit
+         write(55,fmt="(a)") trim(line)
+         write(66,fmt="(a)") trim(line)
+      enddo
+      close(5)
+      close(55)
+      close(66)
+
+!  Now re-open INPUT_FILE as unit 5 for further processing
+!  by oncvpsp
+      
+      open(unit=5,file='INPUT_FILE',action='read',status='old', &
+           form='formatted',position='rewind')
+      
+end subroutine copy_input_file_for_psml
+
+subroutine cdata_section_from_file(xf,filename)
+  use xmlf90_wxml
+
+  type(xmlf_t), intent(inout)   :: xf
+  character(len=*), intent(in) :: filename
+
+  integer :: stat
+  character(len=512) :: line
+  character(len=1)   :: nl = char(10)
+  
+  character(len=32000) :: buffer ! to accumulate characters
+  
+      open(44,file=trim(filename),form="formatted",status="old", &
+           position="rewind",action="read")
+      buffer = ""
+      do
+         read(44,fmt="(a)",iostat=stat) line
+         if (stat .ne. 0) exit
+         buffer = trim(buffer) // trim(line) // nl
+      enddo
+      close(44)
+      
+      call xml_AddCDATASection(xf,trim(buffer),line_feed=.true.)
+!                                                                     
+    end subroutine cdata_section_from_file
+    
+    subroutine exchange_correlation_info(xf,iexc)
+      use xmlf90_wxml
+
+      type(xmlf_t), intent(inout)   :: xf
+      integer, intent(in)           :: iexc
+      
+      character(len=120) :: xcfuntype, names(2), libxc_string
+      character(len=60)  :: types(2), libxc_type
+      integer :: x_code, c_code
+      integer :: i, nfuncs
+      
+      integer :: libxc_id(2)
+
+      external :: libxc_info
+
+      call xml_NewElement(xf,"exchange-correlation")
+
+      select case(iexc)
+
+      case(1) 
+         xcfuntype    = 'LDA -- Wigner'
+         nfuncs = 2
+         libxc_id = (/ 1, 2 /)
+         names(1) = "Slater exchange (LDA)"
+         names(2) = "Wigner (LDA)"
+         types(1) = "exchange"
+         types(2) = "correlation" 
+      case(2) 
+         xcfuntype    = 'LDA -- Hedin-Lundqvist'
+         nfuncs = 2
+         libxc_id = (/ 1, 4 /)
+         names(1) = "Slater exchange (LDA)"
+         names(2) = "Hedin & Lundqvist (LDA)"
+         types(1) = "exchange"
+         types(2) = "correlation" 
+      case(3) 
+         xcfuntype    = 'LDA -- Ceperley-Alder Perdew-Zunger'
+         nfuncs = 2
+         libxc_id = (/ 1, 9 /)
+         names(1) = "Slater exchange (LDA)"
+         names(2) = "Perdew & Zunger (LDA)"
+         types(1) = "exchange"
+         types(2) = "correlation" 
+
+      case(4) 
+         xcfuntype    = 'GGA -- Perdew-Burke-Ernzerhof'
+         nfuncs = 2
+         libxc_id = (/ 101, 130 /)
+         names(1) = "Perdew, Burke & Ernzerhof (GGA)"
+         names(2) = "Perdew, Burke & Ernzerhof (GGA)"
+         types(1) = "exchange"
+         types(2) = "correlation" 
+
+      case(:-1)      ! libxc encoding -XXXCCC
+                     !             or -YYY for single exc functional
+         xcfuntype    = 'libxc-interface'
+         if (-iexc < 1000) then
+            ! Special syntax for single functional
+            ! (For example, Teter exch-corr functional: iexc=-020
+            nfuncs = 1
+            libxc_id(1) = -iexc
+         else
+            x_code = -iexc/1000
+            c_code = -iexc - 1000*x_code
+            nfuncs = 2 
+            libxc_id = (/ x_code, c_code /)
+         endif
+     
+      end select
+
+     call xml_NewElement(xf,"annotation")
+     call my_add_attribute(xf,"oncvpsp-xc-code",str(iexc))
+     call my_add_attribute(xf,"oncvpsp-xc-type",trim(xcfuntype))
+     call xml_EndElement(xf,"annotation")
+
+     call xml_NewElement(xf,"libxc-info")
+     select case(iexc)
+
+     case(1:4) 
+        call my_add_attribute(xf,"number-of-functionals",str(nfuncs))
+        do i = 1, nfuncs
+           call xml_NewElement(xf,"functional")
+           call my_add_attribute(xf,"name",trim(names(i)))
+           call my_add_attribute(xf,"type",trim(types(i)))
+           call my_add_attribute(xf,"id",str(libxc_id(i)))
+           call xml_EndElement(xf,"functional")
+        enddo
+        
+     case(:-1)      ! libxc encoding -XXXCCC
+                    !             or -YYY for single exc functional
+        call my_add_attribute(xf,"number-of-functionals",str(nfuncs))
+        do i = 1, nfuncs
+           call xml_NewElement(xf,"functional")
+           call libxc_info(libxc_id(i),libxc_string,libxc_type)
+           call my_add_attribute(xf,"name",trim(libxc_string))
+           call my_add_attribute(xf,"type",trim(libxc_type))
+           call my_add_attribute(xf,"id",str(libxc_id(i)))
+           call xml_EndElement(xf,"functional")
+        enddo
+        
+     end select
+  
+        call xml_EndElement(xf,"libxc-info")
+  
+  call xml_EndElement(xf,"exchange-correlation")
+
+end subroutine exchange_correlation_info
+
+end module m_psmlout
diff -Naur oncvpsp-3.2.3/src/m_uuid.f90 oncvpsp-3.2.3--psml-51/src/m_uuid.f90
--- oncvpsp-3.2.3/src/m_uuid.f90	1970-01-01 01:00:00.000000000 +0100
+++ oncvpsp-3.2.3--psml-51/src/m_uuid.f90	2017-01-17 17:29:43.000000000 +0100
@@ -0,0 +1,607 @@
+module mtprng
+
+!---------------------------------------------------------------------
+! From the Algorithmic Conjurings of Scott Robert Ladd comes...
+!---------------------------------------------------------------------
+!
+!  mtprng.f90 (a Fortran 95 module)
+!
+!  An implementation of the Mersenne Twister algorithm for generating
+!  psuedo-random sequences.
+!
+!  History
+!  -------
+!   1.0.0   Initial release
+!
+!   1.1.0   6 February 2002
+!           Updated to support algorithm revisions posted
+!           by Matsumoto and Nishimura on 26 January 2002
+!
+!   1.5.0   12 December 2003
+!           Added to hypatia project
+!           Minor style changes
+!           Tightened code
+!           Now state based; no static variables
+!           Removed mtprng_rand_real53
+!
+!   2.0.0   4 January 2004
+!           Corrected erroneous unsigned bit manipulations
+!           Doubled resolution by using 64-bit math
+!           Added mtprng_rand64
+
+!  Version for distribution with FoX <http://uszla.me.uk/FoX>
+!  Very small cosmetic changes to fit FoX naming scheme and
+!  avoid additional dependencies.
+!  Toby White <tow@uszla.me.uk>, 2007
+
+!
+!  ORIGINAL ALGORITHM COPYRIGHT
+!  ============================
+!  Copyright (C) 1997,2002 Makoto Matsumoto and Takuji Nishimura.
+!  Any feedback is very welcome. For any question, comments, see
+!  http://www.math.keio.ac.jp/matumoto/emt.html or email
+!  matumoto@math.keio.ac.jp
+!---------------------------------------------------------------------
+!
+!  COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
+!
+!  This notice applies *only* to this specific expression of this
+!  algorithm, and does not imply ownership or invention of the
+!  implemented algorithm.
+!  
+!  If you modify this file, you may insert additional notices
+!  immediately following this sentence.
+!  
+!  Copyright 2001, 2002, 2004 Scott Robert Ladd.
+!  All rights reserved, except as noted herein.
+!
+!  This computer program source file is supplied "AS IS". Scott Robert
+!  Ladd (hereinafter referred to as "Author") disclaims all warranties,
+!  expressed or implied, including, without limitation, the warranties
+!  of merchantability and of fitness for any purpose. The Author
+!  assumes no liability for direct, indirect, incidental, special,
+!  exemplary, or consequential damages, which may result from the use
+!  of this software, even if advised of the possibility of such damage.
+!  
+!  The Author hereby grants anyone permission to use, copy, modify, and
+!  distribute this source code, or portions hereof, for any purpose,
+!  without fee, subject to the following restrictions:
+!  
+!      1. The origin of this source code must not be misrepresented.
+!  
+!      2. Altered versions must be plainly marked as such and must not
+!         be misrepresented as being the original source.
+!  
+!      3. This Copyright notice may not be removed or altered from any
+!         source or altered source distribution.
+!  
+!  The Author specifically permits (without fee) and encourages the use
+!  of this source code for entertainment, education, or decoration. If
+!  you use this source code in a product, acknowledgment is not required
+!  but would be appreciated.
+!  
+!  Acknowledgement:
+!      This license is based on the wonderful simple license that
+!      accompanies libpng.
+!
+!-----------------------------------------------------------------------
+!
+!  For more information on this software package, please visit
+!  Scott's web site, Coyote Gulch Productions, at:
+!
+!      http://www.coyotegulch.com
+!  
+!-----------------------------------------------------------------------
+
+    implicit none
+
+    ! Kind types for 64-, 32-, 16-, and 8-bit signed integers
+    integer, parameter :: INT64 = selected_int_kind(18)
+    integer, parameter :: INT32 = selected_int_kind(9)
+    integer, parameter :: INT16 = selected_int_kind(4)
+    integer, parameter :: INT08 = selected_int_kind(2)
+
+    ! Kind types for IEEE 754/IEC 60559 single- and double-precision reals
+    integer, parameter :: IEEE32 = selected_real_kind(  6,  37 )
+    integer, parameter :: IEEE64 = selected_real_kind( 15, 307 )
+
+    !------------------------------------------------------------------------------
+    ! Everything is private unless explicitly made public
+    private
+
+    public :: mtprng_state, &
+              mtprng_init, mtprng_init_by_array, &
+              mtprng_rand64, mtprng_rand, mtprng_rand_range, &
+              mtprng_rand_real1, mtprng_rand_real2, mtprng_rand_real3
+
+    !------------------------------------------------------------------------------
+    ! Constants
+    integer(INT32), parameter :: N = 624_INT32
+    integer(INT32), parameter :: M = 397_INT32
+
+    !------------------------------------------------------------------------------
+    ! types
+    type mtprng_state
+        integer(INT32)                   :: mti = -1
+        integer(INT64), dimension(0:N-1) :: mt
+    end type 
+
+contains
+    !--------------------------------------------------------------------------
+    !  Initializes the generator with "seed"
+    subroutine mtprng_init(seed, state)
+    
+        ! arguments
+        integer(INT32),     intent(in)  :: seed
+        type(mtprng_state), intent(out) :: state
+        
+        ! working storage
+        integer :: i
+
+        ! save seed        
+        state%mt(0) = seed
+        
+        ! Set the seed using values suggested by Matsumoto & Nishimura, using
+        !   a generator by Knuth. See original source for details.
+        do i = 1, N - 1
+            state%mt(i) = iand(4294967295_INT64,1812433253_INT64 * ieor(state%mt(i-1),ishft(state%mt(i-1),-30_INT64)) + i)
+        end do
+        
+        state%mti = N
+
+    end subroutine mtprng_init
+    
+    !--------------------------------------------------------------------------
+    ! Initialize with an array of seeds
+    subroutine mtprng_init_by_array(init_key, state)
+    
+        ! arguments
+        integer(INT32), dimension(:), intent(in) :: init_key
+        type(mtprng_state), intent(out) :: state
+        
+        ! working storage
+        integer :: key_length
+        integer :: i
+        integer :: j
+        integer :: k
+        
+        call mtprng_init(19650218_INT32,state)
+        
+        i = 1
+        j = 0
+        key_length = size(init_key)
+        
+        do k = max(N,key_length), 0, -1
+            state%mt(i) = ieor(state%mt(i),(ieor(state%mt(i-1),ishft(state%mt(i-1),-30_INT64) * 1664525_INT64))) + init_key(j) + j
+            
+            i = i + 1
+            j = j + 1
+            
+            if (i >= N) then
+                state%mt(0) = state%mt(N-1)
+                i = 1
+            end if
+            
+            if (j >= key_length) j = 0
+        end do
+        
+        do k = N-1, 0, -1
+            state%mt(i) = ieor(state%mt(i),(ieor(state%mt(i-1),ishft(state%mt(i-1),-30_INT64) * 1566083941_INT64))) - i
+            
+            i = i + 1
+            
+            if (i>=N) then
+                state%mt(0) = state%mt(N-1)
+                i = 1
+            end if
+        end do
+
+        state%mt(0) = 1073741824_INT64 ! 0x40000000, assuring non-zero initial array 
+        
+    end subroutine mtprng_init_by_array
+    
+    !--------------------------------------------------------------------------
+    !   Obtain the next 32-bit integer in the psuedo-random sequence
+    function mtprng_rand64(state) result(r)
+    
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+    
+        !return type
+        integer(INT64) :: r
+
+        ! internal constants
+        integer(INT64), dimension(0:1), parameter :: mag01 = (/ 0_INT64, -1727483681_INT64 /)
+
+        ! Period parameters
+        integer(INT64), parameter :: UPPER_MASK =  2147483648_INT64
+        integer(INT64), parameter :: LOWER_MASK =  2147483647_INT64
+
+        ! Tempering parameters
+        integer(INT64), parameter :: TEMPERING_B = -1658038656_INT64
+        integer(INT64), parameter :: TEMPERING_C =  -272236544_INT64
+        
+        ! Note: variable names match those in original example
+        integer(INT32) :: kk
+        
+        ! Generate N words at a time
+        if (state%mti >= N) then
+            ! The value -1 acts as a flag saying that the seed has not been set.
+            if (state%mti == -1) call mtprng_init(4357_INT32,state)
+            
+            ! Fill the mt array
+            do kk = 0, N - M - 1
+                r = ior(iand(state%mt(kk),UPPER_MASK),iand(state%mt(kk+1),LOWER_MASK))
+                state%mt(kk) = ieor(ieor(state%mt(kk + M),ishft(r,-1_INT64)),mag01(iand(r,1_INT64)))
+            end do
+            
+            do kk = N - M, N - 2
+                r = ior(iand(state%mt(kk),UPPER_MASK),iand(state%mt(kk+1),LOWER_MASK))
+                state%mt(kk) = ieor(ieor(state%mt(kk + (M - N)),ishft(r,-1_INT64)),mag01(iand(r,1_INT64)))
+            end do
+            
+            r = ior(iand(state%mt(N-1),UPPER_MASK),iand(state%mt(0),LOWER_MASK))
+            state%mt(N-1) = ieor(ieor(state%mt(M-1),ishft(r,-1)),mag01(iand(r,1_INT64)))
+            
+            ! Start using the array from first element
+            state%mti = 0
+        end if
+        
+        ! Here is where we actually calculate the number with a series of
+        !   transformations 
+        r = state%mt(state%mti)
+        state%mti = state%mti + 1
+        
+        r = ieor(r,ishft(r,-11))
+        r = iand(4294967295_INT64,ieor(r,iand(ishft(r, 7),TEMPERING_B)))
+        r = iand(4294967295_INT64,ieor(r,iand(ishft(r,15),TEMPERING_C)))
+        r = ieor(r,ishft(r,-18))
+        
+    end function mtprng_rand64
+    
+    !--------------------------------------------------------------------------
+    !   Obtain the next 32-bit integer in the psuedo-random sequence
+    function mtprng_rand(state) result(r)
+    
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+    
+        !return type
+        integer(INT32) :: r
+        
+        ! working storage
+        integer(INT64) :: x
+        
+        ! done
+        x = mtprng_rand64(state)
+        
+        if (x > 2147483647_INT64) then
+            r = x - 4294967296_INT64
+        else
+            r = x
+        end if
+        
+    end function mtprng_rand
+    
+    !---------------------------------------------------------------------------
+    !   Obtain a psuedorandom integer in the range [lo,hi]
+    function mtprng_rand_range(state, lo, hi) result(r)
+
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+        integer, intent(in) :: lo
+        integer, intent(in) :: hi
+        
+        ! return type
+        integer(INT32) :: r
+        
+        ! Use real value to caluclate range
+        r = lo + floor((hi - lo + 1.0_IEEE64) * mtprng_rand_real2(state))
+        
+    end function mtprng_rand_range
+
+    !--------------------------------------------------------------------------
+    !   Obtain a psuedorandom real number in the range [0,1], i.e., a number
+    !   greater than or equal to 0 and less than or equal to 1.
+    function mtprng_rand_real1(state) result(r)
+
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+    
+        ! return type
+        real(IEEE64) :: r
+        
+        ! Local constant; precalculated to avoid division below
+        real(IEEE64), parameter :: factor = 1.0_IEEE64 / 4294967295.0_IEEE64
+        
+        ! compute
+        r = real(mtprng_rand64(state),IEEE64) * factor
+        
+    end function mtprng_rand_real1
+
+    !--------------------------------------------------------------------------
+    !   Obtain a psuedorandom real number in the range [0,1), i.e., a number
+    !   greater than or equal to 0 and less than 1.
+    function mtprng_rand_real2(state) result(r)
+
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+    
+        ! return type
+        real(IEEE64) :: r
+        
+        ! Local constant; precalculated to avoid division below
+        real(IEEE64), parameter :: factor = 1.0_IEEE64 / 4294967296.0_IEEE64
+        
+        ! compute
+        r = real(mtprng_rand64(state),IEEE64) * factor
+        
+    end function mtprng_rand_real2
+
+    !--------------------------------------------------------------------------
+    !   Obtain a psuedorandom real number in the range (0,1), i.e., a number
+    !   greater than 0 and less than 1.
+    function mtprng_rand_real3(state) result(r)
+
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+    
+        ! return type
+        real(IEEE64) :: r
+        
+        ! Local constant; precalculated to avoid division below
+        real(IEEE64), parameter :: factor = 1.0_IEEE64 / 4294967296.0_IEEE64
+        
+        r = (real(mtprng_rand64(state),IEEE64) + 0.5_IEEE64) * factor
+        
+    end function mtprng_rand_real3
+
+end module mtprng
+
+module m_uuid
+  ! Fortran module to generate UUIDs
+  ! Extracted from FoX (work by Toby White and Andrew Walker)
+
+
+  !This generates UUIDs according to RFC 4122
+
+  ! Only types 1 (time-based) and 4 (pseudo-RNG-based) are implemented.
+
+  use mtprng, only : mtprng_state, mtprng_init, mtprng_rand64
+
+  implicit none
+  private
+  
+  integer, parameter :: i4b = selected_int_kind(9)
+  integer, parameter :: i8b = selected_int_kind(18)
+  
+  character, parameter :: hexdigits(0:15) = &
+    (/'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'/)
+  
+  type(mtprng_state), save :: rng_state
+  logical, save :: initialized = .false.
+  integer, save :: values_save ! must be default for date_and_time
+  integer(kind=i4b), save :: hires_count = 0
+
+! clock-seq holds a random number constant for the lifetime of the program
+! using this module. That's the best we can do per S 4.1.5
+  integer, save :: clock_seq = 0
+
+  public :: generate_uuid
+  
+contains
+  
+  function generate_uuid(version) result(uuid)
+    integer, intent(in), optional :: version
+    character(len=36) :: uuid
+
+    integer(kind=i8b) :: timestamp, node
+    integer(kind=i4b) :: clock_sequence
+
+    integer(kind=i4b) :: time_low, time_mid, time_hi_and_version
+    integer(kind=i4b) :: clk_seq_hi_res, clk_seq_low
+
+    integer :: values(8) ! must be default for date_and_time
+    integer(kind=i4b) :: variant, v
+
+
+    if (.not.initialized) then
+      ! Use the current date and time to init mtprng
+      ! but this gives limited varaibility, so mix 
+      ! the result up.  Can we do better? In any
+      ! case, this gets passed through a quick 
+      ! generator inside mtprng_init.
+      call date_and_time(values=values)
+      values(7) = values(7)*1000+values(5)*100+values(3)*10+values(1)
+      values(8) = values(2)*1000+values(4)*100+values(6)*10+values(8)
+      call mtprng_init(int(values(7)*10000+values(8), i4b), rng_state)
+      clock_seq = int(mtprng_rand64(rng_state), i4b)
+      initialized = .true.
+    endif
+
+    variant = 1
+
+    if (present(version)) then
+      v = version
+    else
+      v = 4
+    endif
+
+    select case (v)
+    case (0)
+      ! Nil UUID  - S 4.1.7
+      uuid = repeat('0',8)//'-'//repeat('0',4)//'-'//repeat('0',4)// &
+        '-'//repeat('0',4)//'-'//repeat('0',12)
+      return
+    case(1)
+      call date_and_time(values=values)
+      ! In case of too-frequent requests, we will replace time_low
+      ! with the count below ...
+      if (all(values==values_save)) then
+        hires_count = hires_count + 1
+      else
+        hires_count = 0
+      endif
+    case(2-3)
+      !Unimplemented
+      uuid = ''
+      return
+    case(4)
+      continue
+    case(5)
+      !Unimplemented
+      uuid = ''
+      return
+    case default
+      !Unspecified
+      uuid = ''
+      return
+    end select
+
+!4.1.4 Timestamp
+
+    select case(v)
+    case(1)
+      timestamp = get_utc_since_1582(values)
+    case(4)
+      timestamp = ior(mtprng_rand64(rng_state), ishft(mtprng_rand64(rng_state), 28))
+    end select
+
+!4.1.5 Clock Sequence
+    ! 14 bits
+    select case(v)
+    case(1)
+      clock_sequence = clock_seq
+    case(4)
+      clock_sequence = int(mtprng_rand64(rng_state), i4b)
+    end select
+
+!4.1.6 Node
+    ! 48 bits
+    select case(v)
+    case(1)
+      node = ior(mtprng_rand64(rng_state), ishft(mtprng_rand64(rng_state), 16))
+      ! No MAC address accessible - see section 4.5 !FIXME
+    case(4)
+      node = ior(mtprng_rand64(rng_state), ishft(mtprng_rand64(rng_state), 16))
+    end select
+
+    time_low = ibits(timestamp, 0, 32)
+    time_mid = ibits(timestamp, 32, 16)
+    if (hires_count==0) then
+      time_hi_and_version = ior(int(ibits(timestamp, 48, 12), i4b), ishft(v, 12))
+    else
+      time_hi_and_version = ior(hires_count, ishft(v, 12))
+    endif
+
+    clk_seq_low = ibits(clock_sequence, 0, 8)
+    clk_seq_hi_res = ior(ibits(clock_sequence, 8, 6), ishft(variant, 6))
+
+    uuid = int32ToHexOctets(time_low, 4)//"-"// &
+      int32ToHexOctets(time_mid, 2)//"-"// &
+      int32ToHexOctets(time_hi_and_version, 2)//"-"// & 
+      int32ToHexOctets(clk_seq_hi_res, 1)// &
+      int32ToHexOctets(clk_seq_low, 1)//"-"// &
+      int64ToHexOctets(node, 6)
+
+  contains
+
+    function int32ToHexOctets(b, n) result(s)
+      integer(i4b), intent(in) :: b
+      integer, intent(in) :: n ! number of octets to print
+      character(len=2*n) :: s
+      
+      integer :: i
+      
+      do i = 0, 2*n-1
+        s(2*n-i:2*n-i) = hexdigits(ibits(b, i*4, 4))
+      enddo
+      
+    end function int32ToHexOctets
+    function int64ToHexOctets(b, n) result(s)
+      integer(i8b), intent(in) :: b
+      integer, intent(in) :: n ! number of octets to print
+      character(len=2*n) :: s
+      
+      integer :: i
+      
+      do i = 0, 2*n-1
+        s(2*n-i:2*n-i) = hexdigits(ibits(b, i*4, 4))
+      enddo
+      
+    end function int64ToHexOctets
+
+  end function generate_uuid
+
+  function get_utc_since_1582(values) result(ns)
+    ! This subroutine is a little broken. It only works
+    ! for times after 1/1/2006 and takes no account
+    ! of any future leapseconds. It ought to serve regardless.
+
+    ! It returns the number of 100-ns intervals since 1582-10-15-00-00-00
+
+    integer, dimension(8), intent(in) :: values
+    integer(kind=i8b) :: ns
+
+    integer :: days
+    integer :: years
+
+    integer, parameter :: days_in_normal_year(12) = &
+      (/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)
+
+    ns = 23_i8b * 1000_i8b * 1000_i8b * 10_i8b ! 23 leap seconds until 24:00:00 31/12/2005
+
+    ! A count of the 100-nanosecond intervals since the
+    ! beginning of the day.
+    ns = ns &
+      ! milliseconds
+      + int(values(8), i8b)             * 10_i8b * 1000_i8b &
+      ! seconds
+      + int(values(7), i8b)             * 10_i8b * 1000_i8b * 1000_i8b &
+      ! minutes (with timezone adjustment)
+      + int(values(6) + values(4), i8b) * 10_i8b * 1000_i8b * 1000_i8b * 60_i8b &
+      ! hours
+      + int(values(5), i8b)             * 10_i8b * 1000_i8b * 1000_i8b * 60_i8b * 60_i8b
+
+    ! Number of days this year:
+    days = sum(days_in_normal_year(:values(2)-1))
+    days = days + values(3) - 1 !add days in current month
+    if (values(2)>2 .and. isLeapYear(values(1))) then
+      days = days + 1
+    endif
+    !That's all the time since the turn of this year
+
+    days = days + 78 ! From the start of 15th Oct to the end of 31st Dec in 1582
+    !That's the additional time before the turn of the year 1583
+
+    days = days + 102  ! 102 leap years from 1584 to 2000 inclusive
+    ! That's all the intercalataed days until 2000
+    
+    years = values(1) - 2000 - 1 ! years since 2000 - not including this year
+
+    days = days + years/4 - years/100 + years/400 !Add extra leap days to this total:
+    ! That's all out intercalated days - remaining years are all 365 days long.
+
+    years = years + 418 ! Add the years from 1583-2000 inclusive back on.
+
+    ! Multiply by number of time units in one day & add to today's total.
+    ns = ns + 864000000000_i8b * (int(days,i8b) + 365_i8b * int(years,i8b))
+
+  contains
+    function isLeapYear(y) result(p)
+      integer, intent(in) :: y
+      logical :: p
+      p = (mod(y,4)==0 .and. .not.mod(y,100)==0 .or. mod(y,400)==0)
+    end function isLeapYear
+
+  end function get_utc_since_1582
+
+end module m_uuid
+
+subroutine get_uuid(uuid)
+  use m_uuid, only: generate_uuid
+
+    character(len=36), intent(out) :: uuid
+
+    uuid = generate_uuid(version=1)
+end subroutine get_uuid
diff -Naur oncvpsp-3.2.3/src/modcore.f90 oncvpsp-3.2.3--psml-51/src/modcore.f90
--- oncvpsp-3.2.3/src/modcore.f90	2016-09-15 16:20:11.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/modcore.f90	2017-01-17 17:29:43.000000000 +0100
@@ -24,7 +24,7 @@
 ! Teter, Phys. Rev. B 48, 5031 (1993) , Appendix, as 
 
  subroutine modcore(icmod,rhops,rhotps,rhoc,rhoae,rhotae,rhomod, &
-&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, ircc)
 
 !icmod  3 coefficient optimizaion, 4 for specivied fcfact and rfact
 !rhops  state-by-state pseudocharge density
@@ -43,6 +43,7 @@
 !la  angular-momenta
 !zion  ion charge
 !iexc  exchange-correlation function to be used
+!ircc  index of matching point
 
  implicit none
  integer, parameter :: dp=kind(1.0d0)
@@ -57,10 +58,10 @@
 
 !Output variables
  real(dp) :: rhomod(mmax,5)
+ integer  :: ircc            ! Index of matching point
 
 !convergence criterion
  real(dp), parameter :: eps=1.0d-7
-
 !Local variables
  real(dp) :: a0,al,et,yy,gg,a0min,a0max,dermax,psum,sf,eeel,eexc
  real(dp) :: d2mdiff,rmatch,rhocmatch
@@ -68,7 +69,7 @@
  real(dp) :: aco(5),polym(5,5),work(5,5),constm(5,5),xpow(9),fmatch(5)
  real(dp), allocatable :: vxcae(:),vxcpsp(:),vo(:),d2excae(:,:),d2excps(:,:)
  real(dp), allocatable :: dvxcae(:,:),dvxcps(:,:),vxct(:)
- integer :: ii,ierr,ircc,irmod,iter,jj,kk,ll,l1,mch
+ integer :: ii,ierr,irmod,iter,jj,kk,ll,l1,mch
  integer :: ipvt(5),nodes(4)
 
 
diff -Naur oncvpsp-3.2.3/src/modcore2.f90 oncvpsp-3.2.3--psml-51/src/modcore2.f90
--- oncvpsp-3.2.3/src/modcore2.f90	2016-09-15 16:20:11.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/modcore2.f90	2017-01-17 17:29:43.000000000 +0100
@@ -22,7 +22,7 @@
 ! Teter, Phys. Rev. B 48, 5031 (1993) , Appendix, as 
 
  subroutine modcore2(icmod,rhops,rhotps,rhoc,rhoae,rhotae,rhomod, &
-&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, ircc)
 
 !icmod  3 coefficient optimizaion, 4 for specivied fcfact and rfact
 !rhops  state-by-state pseudocharge density
@@ -41,6 +41,7 @@
 !la  angular-momenta
 !zion  ion charge
 !iexc  exchange-correlation function to be used
+!ircc  index of matching point
 
  implicit none
  integer, parameter :: dp=kind(1.0d0)
@@ -55,6 +56,7 @@
 
 !Output variables
  real(dp) :: rhomod(mmax,5)
+ integer  :: ircc            ! Index of matching point
 
 !convergence criterion
  real(dp), parameter :: eps=1.0d-7
@@ -67,7 +69,7 @@
  real(dp) :: fmatch(5)
  real(dp), allocatable :: vxcae(:),vxcpsp(:),vo(:),d2excae(:,:),d2excps(:,:)
  real(dp), allocatable :: dvxcae(:,:),dvxcps(:,:),vxct(:)
- integer :: ii,ierr,ircc,irmod,iter,jj,kk
+ integer :: ii,ierr,irmod,iter,jj,kk
 
  allocate(vxcae(mmax),vxcpsp(mmax),vo(mmax))
  allocate(dvxcae(mmax,nv),dvxcps(mmax,nv),vxct(mmax))
diff -Naur oncvpsp-3.2.3/src/modcore3.f90 oncvpsp-3.2.3--psml-51/src/modcore3.f90
--- oncvpsp-3.2.3/src/modcore3.f90	2016-09-15 16:20:11.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/modcore3.f90	2017-01-17 17:29:43.000000000 +0100
@@ -24,7 +24,7 @@
 ! Teter, Phys. Rev. B 48, 5031 (1993) , Appendix, as 
 
  subroutine modcore3(icmod,rhops,rhotps,rhoc,rhoae,rhotae,rhomod, &
-&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, ircc)
 
 !icmod  3 coefficient optimizaion, 4 for specivied fcfact and rfact
 !rhops  state-by-state pseudocharge density
@@ -43,6 +43,7 @@
 !la  angular-momenta
 !zion  ion charge
 !iexc  exchange-correlation function to be used
+!ircc  index of matching point
 
  implicit none
  integer, parameter :: dp=kind(1.0d0)
@@ -57,6 +58,7 @@
 
 !Output variables
  real(dp) :: rhomod(mmax,5)
+ integer  :: ircc            ! Index of matching point
 
 !convergence criterion
  real(dp), parameter :: eps=1.0d-7
@@ -68,7 +70,7 @@
  real(dp) :: gg,tt,yy
  real(dp), allocatable :: vxcae(:),vxcpsp(:),vo(:),d2excae(:,:),d2excps(:,:)
  real(dp), allocatable :: dvxcae(:,:),dvxcps(:,:),vxct(:)
- integer :: ii,ierr,ircc,ircross,irmod,iter,jj,kk
+ integer :: ii,ierr,ircross,irmod,iter,jj,kk
 
 !2-dimensional Nelder-Mead variables
  real(dp), parameter :: alpha_nm=1.0d0
diff -Naur oncvpsp-3.2.3/src/oncvpsp.f90 oncvpsp-3.2.3--psml-51/src/oncvpsp.f90
--- oncvpsp-3.2.3/src/oncvpsp.f90	2016-09-15 16:23:30.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/oncvpsp.f90	2017-01-17 17:29:43.000000000 +0100
@@ -32,6 +32,9 @@
 !
 !   Output format for ABINIT pspcod=8
 !
+ use m_psmlout, only: psmlout, copy_input_file_for_psml
+ use m_psmlout, only: PSML_CREATOR
+
  implicit none
  integer, parameter :: dp=kind(1.0d0)
 
@@ -39,6 +42,7 @@
  integer :: ii,ierr,iexc,iexct,ios,iprint,irps,it,icmod,lpopt
  integer :: jj,kk,ll,l1,lloc,lmax,lt,inline
  integer :: mch,mchf,mmax,n1,n2,nc,nlim,nlloc,nlmax,irpsh,nrl
+ integer :: nrl0
  integer :: nv,irct,ncnf
 !
  integer :: dtime(8),na(30),la(30),np(6)
@@ -84,6 +88,8 @@
 &      'ONCVPSP  (Optimized Norm-Conservinng Vanderbilt PSeudopotential)', &
 &      'scalar-relativistic version 3.2.3 09/16/2016'
 
+ write(6,'(a,/)') 'PSML module version: ' // PSML_CREATOR
+
  write(6,'(a/a/a//)') &
 &      'While it is not required under the terms of the GNU GPL, it is',&
 &      'suggested that you cite D. R. Hamann, Phys. Rev. B 88, 085117 (2013)', &
@@ -98,6 +104,7 @@
  ep(:)=0.0d0
 
 ! read input data
+ call copy_input_file_for_psml()
  inline=0
 
 ! atom and reference configuration
@@ -197,6 +204,7 @@
 &                ncnf,na,la,nvcnf,nacnf,lacnf,ncon,nbas,nproj,psfile)
 
  nrl=int((rlmax/drl)-0.5d0)+1
+ nrl0 = nrl
 
 !PWSCF wants an even number of mesh pointe
 !if(trim(psfile)=='upf') then
@@ -522,15 +530,15 @@
 
  if(icmod==1) then
    call modcore(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod==2) then
    call modcore2(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod>=3) then
    call modcore3(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
 !   call modcore3(icmod,rho,rhoc,rhomod,fcfact,rcfact,mmax,rr, &
 !&                na,la,ea,fa,nc,nv,iexc,zz,vfull,srel, &
@@ -554,6 +562,13 @@
  do l1=1,max(lmax+1,lloc+1)
    vpuns(:,l1)=vp(:,l1)-vo(:)
  end do
+ write(66,"(a)") "# screening potential"
+ do ii = 1, mmax
+    write(66,"(2es24.16)") rr(ii), vo(ii)
+ enddo
+
+
+
 
 ! fix unscreening error due to greater range of all-electron charge
  do ii=mmax,1,-1
@@ -625,6 +640,15 @@
 &             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact,rcfact, &
 &             epsh1,epsh2,depsh,rlmax,psfile, uua,eacopy)
  end if
+!
+! Write info for PSML format
+!
+ call psmlout(lmax,lloc,rc,vkb,evkb,nproj,rr,vpuns,rho,rhomod, &
+&             irct, srel, &
+&             zz,zion,mmax,iexc,icmod,nrl0,drl,atsym,epstot, &
+&             na,la,ncon,nbas,nvcnf,nacnf,lacnf,nc,nv,lpopt,ncnf, &
+&             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
+&             epsh1,epsh2,depsh,rlmax,psfile,uua)
 
  stop
  end program oncvpsp
diff -Naur oncvpsp-3.2.3/src/oncvpsp_nr.f90 oncvpsp-3.2.3--psml-51/src/oncvpsp_nr.f90
--- oncvpsp-3.2.3/src/oncvpsp_nr.f90	2016-09-15 16:26:39.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/oncvpsp_nr.f90	2017-01-17 17:29:43.000000000 +0100
@@ -32,6 +32,9 @@
 !
 !   Output format for ABINIT pspcod=8
 !
+ use m_psmlout, only: psmlout, copy_input_file_for_psml
+ use m_psmlout, only: PSML_CREATOR
+
  implicit none
  integer, parameter :: dp=kind(1.0d0)
 
@@ -39,6 +42,7 @@
  integer :: ii,ierr,iexc,iexct,ios,iprint,irps,it,icmod,lpopt
  integer :: jj,kk,ll,l1,lloc,lmax,lt,inline
  integer :: mch,mchf,mmax,n1,n2,nc,nlim,nlloc,nlmax,irpsh,nrl
+ integer :: nrl0
  integer :: nv,irct,ncnf
 !
  integer :: dtime(8),na(30),la(30),np(6)
@@ -84,6 +88,8 @@
 &      'ONCVPSP  (Optimized Norm-Conservinng Vanderbilt PSeudopotential)', &
 &      'non-relativistic version 3.2.3 09/16/2016'
 
+ write(6,'(a,/)') 'PSML module version: ' // PSML_CREATOR
+
  write(6,'(a/a/a//)') &
 &      'While it is not required under the terms of the GNU GPL, it is',&
 &      'suggested that you cite D. R. Hamann, Phys. Rev. B 88, 085117 (2013)', &
@@ -98,6 +104,7 @@
  ep(:)=0.0d0
 
 ! read input data
+ call copy_input_file_for_psml()
  inline=0
 
 ! atom and reference configuration
@@ -197,6 +204,7 @@
 &                ncnf,na,la,nvcnf,nacnf,lacnf,ncon,nbas,nproj,psfile)
 
  nrl=int((rlmax/drl)-0.5d0)+1
+ nrl0 = nrl
 
 !PWSCF wants an even number of mesh pointe
 !if(trim(psfile)=='upf') then
@@ -522,15 +530,15 @@
 
  if(icmod==1) then
    call modcore(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod==2) then
    call modcore2(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod>=3) then
    call modcore3(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
 !   call modcore3(icmod,rho,rhoc,rhomod,fcfact,rcfact,mmax,rr, &
 !&                na,la,ea,fa,nc,nv,iexc,zz,vfull,srel, &
@@ -625,6 +633,16 @@
 &             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact,rcfact, &
 &             epsh1,epsh2,depsh,rlmax,psfile, uua,eacopy)
  end if
+!
+! Write info for PSML format
+!
+ call psmlout(lmax,lloc,rc,vkb,evkb,nproj,rr,vpuns,rho,rhomod, &
+&             irct, srel, &
+&             zz,zion,mmax,iexc,icmod,nrl0,drl,atsym,epstot, &
+&             na,la,ncon,nbas,nvcnf,nacnf,lacnf,nc,nv,lpopt,ncnf, &
+&             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
+&             epsh1,epsh2,depsh,rlmax,psfile,uua)
+
 
  stop
  end program oncvpsp
diff -Naur oncvpsp-3.2.3/src/oncvpsp_r.f90 oncvpsp-3.2.3--psml-51/src/oncvpsp_r.f90
--- oncvpsp-3.2.3/src/oncvpsp_r.f90	2016-09-30 20:40:33.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/oncvpsp_r.f90	2017-01-17 17:29:43.000000000 +0100
@@ -33,6 +33,9 @@
 !
 !   Output format for ABINIT pspcod=8
 !
+ use m_psmlout, only: psmlout_r, copy_input_file_for_psml
+ use m_psmlout, only: PSML_CREATOR
+
  implicit none
  integer, parameter :: dp=kind(1.0d0)
 
@@ -40,6 +43,7 @@
  integer :: ii,ierr,iexc,iexct,ios,iprint,irps,it,icmod,lpopt
  integer :: jj,kk,ll,l1,lloc,lmax,lt,inline
  integer :: mch,mchf,mmax,n1,n2,nc,nlim,nlloc,nlmax,irpsh,nrl
+ integer :: nrl0
  integer :: nv,irct,ncnf
  integer :: ikap,kap,mkap
 !
@@ -78,6 +82,7 @@
  real(dp), allocatable :: rhomod(:,:),rhoae(:,:),rhops(:,:),rhotae(:)
  real(dp), allocatable :: uua(:,:,:), uuatmp(:,:,:)
  real(dp), allocatable :: vsr(:,:,:),vso(:,:,:),vpsr(:,:)
+ real(dp), allocatable :: vpsml(:,:,:)
 
 
  character*2 :: atsym
@@ -89,6 +94,9 @@
 &      'ONCVPSP  (Optimized Norm-Conservinng Vanderbilt PSeudopotential)', &
 &      'fully-relativistic version 3.2.3 09/16/2016'
 
+ write(6,'(a,/)') 'PSML module version: ' // PSML_CREATOR
+
+
  write(6,'(a,a,a,a//)') &
 &      'While it is not required under the terms of the GNU GPL, it is',&
 &      'suggested that you cite the arXiv preprint or Phys. Rev. B paper',&
@@ -100,6 +108,7 @@
  rcfact=0.0d0
 
 ! read input data
+ call copy_input_file_for_psml()
  inline=0
 
 ! atom and reference configuration
@@ -211,6 +220,7 @@
  end if
 
  nrl=int((rlmax/drl)-0.5d0)+1
+ nrl0 = nrl
 
 !PWSCF wants an even number of mesh pointe
  if(trim(psfile)=='upf') then
@@ -583,7 +593,10 @@
 ! for abinit output, need decomposition into scalar-relativistic and
 ! spin-orbit projectors
 
- if(trim(psfile)=='psp8' .or. trim(psfile)=='both') then
+! Do it unconditionally, so that PSML has all the information
+
+  if (.true.) then
+!if(trim(psfile)=='psp8' .or. trim(psfile)=='both') then
   call sr_so_r(lmax,irc,nproj,rr,mmax,evkb,vkb, &
 &              vsr,esr,vso,eso)
 
@@ -611,15 +624,15 @@
 
  if(icmod==1) then
    call modcore(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod==2) then
    call modcore2(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod>=3) then
    call modcore3(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  end if
 
@@ -646,6 +659,14 @@
 
  end if
 
+! save full info for psml 
+ allocate(vpsml(mmax,5,2))
+ do l1=1,max(lmax+1,lloc+1)
+    ll=l1-1
+    vpsml(:,l1,1) = vp(:,l1,1) - vo(:)
+    vpsml(:,l1,2) = vp(:,l1,2) - vo(:)
+ end do
+
 ! unscreen semi-local potentials taking scalar-relativistic average
 
  do l1=1,max(lmax+1,lloc+1)
@@ -734,6 +755,14 @@
 &             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact,rcfact, &
 &             epsh1,epsh2,depsh,rlmax,psfile, uua,eacopy)
  end if
+!
+  call psmlout_r(lmax,lloc,rc,vkb,evkb,nproj,rr,vpsml,rho,rhomod, &
+&             irct, &
+&             vsr,esr,vso,eso, &
+&             zz,zion,mmax,iexc,icmod,nrl0,drl,atsym,epstot, &
+&             na,la,ncon,nbas,nvcnf,nacnf,lacnf,nc,nv,lpopt,ncnf, &
+&             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
+&             epsh1,epsh2,depsh,rlmax,psfile,uua)
 
  stop
  end program oncvpsp_r
diff -Naur oncvpsp-3.2.3/src/vploc.f90 oncvpsp-3.2.3--psml-51/src/vploc.f90
--- oncvpsp-3.2.3/src/vploc.f90	2016-09-15 16:20:12.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/src/vploc.f90	2017-01-17 17:29:43.000000000 +0100
@@ -111,6 +111,7 @@
 
 ! create polynomial potential inside irc
 
+ write(55,"(a,/,4(es24.16,/))") "Vlocal coeffs:", aco, bco, cco, dco
 
  if(lpopt .eq. 1) then
    do ii=1,irc
diff -Naur oncvpsp-3.2.3/tests/data/57_La.dat oncvpsp-3.2.3--psml-51/tests/data/57_La.dat
--- oncvpsp-3.2.3/tests/data/57_La.dat	2015-08-06 16:05:26.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/tests/data/57_La.dat	2017-01-17 17:29:43.000000000 +0100
@@ -1,6 +1,6 @@
 # ATOM AND REFERENCE CONFIGURATION
 # atsym, z, nc, nv, iexc   psfile
-    la  57.0   9   4   3   psp8
+    La  57.0   9   4   3   psp8
 #
 # n, l, f  (nc+nv lines)
     1    0    2.0
diff -Naur oncvpsp-3.2.3/tests/extract.sh oncvpsp-3.2.3--psml-51/tests/extract.sh
--- oncvpsp-3.2.3/tests/extract.sh	2016-09-06 21:29:12.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/tests/extract.sh	2017-01-17 17:29:43.000000000 +0100
@@ -13,7 +13,7 @@
 
 if [ "$STR1" ]
 	then
-	PSPFILE=~/$2/$1.oncvpsp.psp8
+	PSPFILE=$1.oncvpsp.psp8
 
 	awk 'BEGIN{out=0};/END_PSP/{out=0}; \
 		{if(out == 1) {print}};/PSPCODE8/{out=1}' \
@@ -24,7 +24,7 @@
 
 if [ "$STR2" ]
 	then
-	PSPFILE=~/$2/$1.oncvpsp.upf
+	PSPFILE=$1.oncvpsp.upf
 
 	awk 'BEGIN{out=0};/END_PSP/{out=0}; \
 		{if(out == 1) {print}};/PSP_UPF/{out=1}' \
diff -Naur oncvpsp-3.2.3/tests/pg.sh oncvpsp-3.2.3--psml-51/tests/pg.sh
--- oncvpsp-3.2.3/tests/pg.sh	1970-01-01 01:00:00.000000000 +0100
+++ oncvpsp-3.2.3--psml-51/tests/pg.sh	2017-01-17 17:29:43.000000000 +0100
@@ -0,0 +1,42 @@
+#!/bin/sh
+#runs ONCVPSP with the command-line argument <prefix> and the graphics
+#which review the results
+#uses the scalar-relativistic all-electron atom calculation
+
+name=$1
+dir=$name.$$
+mkdir $dir; 
+
+INFILE=$1.dat
+cp -p $INFILE $dir
+cd $dir
+
+OUTFILE=$1.out
+PSMLFILE=$1.psml
+
+GNUFILE=$1.scr
+
+PLOTFILE=$1.plot
+
+TEMP=$$.tmp
+
+${ONCVPSP_BIN}/oncvpsp.x <$INFILE >$OUTFILE  #Edit if your executable is
+                                            #in another directory
+
+awk 'BEGIN{out=0};/GNUSCRIPT/{out=0}; {if(out == 1) {print}};\
+	/DATA FOR PLOTTING/{out=1}' $OUTFILE >$PLOTFILE
+
+awk 'BEGIN{out=0};/END_GNU/{out=0}; {if(out == 1) {print}};\
+	/GNUSCRIPT/{out=1}' $OUTFILE >$TEMP
+
+sed -e 1,1000s/t1/$PLOTFILE/ $TEMP >$GNUFILE
+
+mv ONCVPSPPSML $PSMLFILE
+
+##gnuplot $GNUFILE
+
+rm  $TEMP $PLOTFILE
+
+cd ..
+echo "Results in $dir"
+
diff -Naur oncvpsp-3.2.3/tests/run.sh oncvpsp-3.2.3--psml-51/tests/run.sh
--- oncvpsp-3.2.3/tests/run.sh	2016-09-06 21:21:14.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/tests/run.sh	2017-01-17 17:29:43.000000000 +0100
@@ -3,19 +3,19 @@
 #which review the results
 #uses the scalar-relativistic all-electron atom calculation
 
-PREFIX=/home/drh/oncvpsp-3.2.3
 
 INFILE=$1.dat
 
 OUTFILE=$1.out
+PSMLFILE=$1.psml
 
-GNUFILE=$$.scr
+GNUFILE=$1.scr
 
 PLOTFILE=$1.plot
 
 TEMP=$$.tmp
 
-$PREFIX/src/oncvpsp.x <$INFILE >$OUTFILE  #Edit if your executable is
+${ONCVPSP_BIN}/oncvpsp.x <$INFILE >$OUTFILE  #Edit if your executable is
                                             #in another directory
 
 awk 'BEGIN{out=0};/GNUSCRIPT/{out=0}; {if(out == 1) {print}};\
@@ -26,9 +26,12 @@
 
 sed -e 1,1000s/t1/$PLOTFILE/ $TEMP >$GNUFILE
 
+mv ONCVPSPPSML $PSMLFILE
 if [ "$2" != "-np" ]
 then
 	gnuplot $GNUFILE
 fi
 
-rm  $GNUFILE $TEMP $PLOTFILE
+##gnuplot $GNUFILE
+
+rm  $TEMP $PLOTFILE
diff -Naur oncvpsp-3.2.3/tests/run_nr.sh oncvpsp-3.2.3--psml-51/tests/run_nr.sh
--- oncvpsp-3.2.3/tests/run_nr.sh	2016-09-06 21:21:14.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/tests/run_nr.sh	2017-01-17 17:29:43.000000000 +0100
@@ -3,19 +3,18 @@
 #which review the results
 #uses the non-relativistic all-electron atom calculation
 
-PREFIX=/home/drh/oncvpsp-3.2.3
-
 INFILE=$1.dat
 
 OUTFILE=$1_nr.out
+PSMLFILE=$1_nr.psml
 
-GNUFILE=$$.scr
+GNUFILE=$$_nr.scr
 
 PLOTFILE=$1.plot
 
 TEMP=$$.tmp
 
-$PREFIX/src/oncvpspnr.x <$INFILE >$OUTFILE
+${ONCVPSP_BIN}/oncvpspnr.x <$INFILE >$OUTFILE
 
 awk 'BEGIN{out=0};/GNUSCRIPT/{out=0}; {if(out == 1) {print}};\
 	/DATA FOR PLOTTING/{out=1}' $OUTFILE >$PLOTFILE
@@ -25,10 +24,12 @@
 
 sed -e 1,1000s/t1/$PLOTFILE/ $TEMP >$GNUFILE
 
-
+mv ONCVPSPPSML $PSMLFILE
 if [ "$2" != "-np" ]
 then
 	gnuplot $GNUFILE
 fi
 
-rm  $GNUFILE $TEMP $PLOTFILE
+#gnuplot $GNUFILE
+
+rm  $TEMP $PLOTFILE
diff -Naur oncvpsp-3.2.3/tests/run_r.sh oncvpsp-3.2.3--psml-51/tests/run_r.sh
--- oncvpsp-3.2.3/tests/run_r.sh	2016-09-06 21:21:14.000000000 +0200
+++ oncvpsp-3.2.3--psml-51/tests/run_r.sh	2017-01-17 17:29:43.000000000 +0100
@@ -4,19 +4,18 @@
 #_r is appended to the prefix of the output file
 #uses the fully-relativistic all-electron atom calculation
 
-PREFIX=/home/drh/oncvpsp-3.2.3
-
 INFILE=$1.dat
 
 OUTFILE=$1_r.out
+PSMLFILE=$1_r.psml
 
-GNUFILE=$$.scr
+GNUFILE=$1_r.scr
 
 PLOTFILE=$1.plot
 
 TEMP=$$.tmp
 
-$PREFIX/src/oncvpspr.x <$INFILE >$OUTFILE  #Edit if your executable is
+${ONCVPSP_BIN}/oncvpspr.x <$INFILE >$OUTFILE  #Edit if your executable is
                                             #in another directory
 
 awk 'BEGIN{out=0};/GNUSCRIPT/{out=0}; {if(out == 1) {print}};\
@@ -27,9 +26,11 @@
 
 sed -e 1,1000s/t1/$PLOTFILE/ $TEMP >$GNUFILE
 
+mv ONCVPSPPSML $PSMLFILE
+##gnuplot $GNUFILE
 if [ "$2" != "-np" ]
 then
 	gnuplot $GNUFILE
 fi
 
-rm  $GNUFILE $TEMP $PLOTFILE
+rm  $TEMP $PLOTFILE
