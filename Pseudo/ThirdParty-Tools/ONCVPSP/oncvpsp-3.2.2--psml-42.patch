diff -Naur oncvpsp-3.2.2/INSTALL oncvpsp-3.2.2--psml-42/INSTALL
--- oncvpsp-3.2.2/INSTALL	2015-08-06 16:05:26.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/INSTALL	2016-06-30 16:57:17.000000000 +0200
@@ -1,3 +1,14 @@
+****
+AG Notes for installation of the PSML version of oncvpsp
+---
+For the time being, the patched version of oncvpsp with PSML support
+has to be compiled by going directly to the 'src' subdirectory, editing
+the 'fortran.mk' file, and typing 'make all'.
+
+The 'run*' scripts in 'tests' have been modified to support PSML. The
+environmental variable ONCVPSP_BIN must be set to the location of the
+directory holding the executables.
+****
 
                     ONCVPST INSTALLATION AND USAGE
 
diff -Naur oncvpsp-3.2.2/make oncvpsp-3.2.2--psml-42/make
--- oncvpsp-3.2.2/make	2015-08-06 16:05:26.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/make	1970-01-01 01:00:00.000000000 +0100
@@ -1,86 +0,0 @@
-cd src ; make all ; cd ..
-make[1]: Entering directory `/home/drh/temp2/oncvpsp-3.2.1/src'
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c oncvpsp.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c fphsft.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c fpovlp.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c gnu_script.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c linout.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c psatom.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c relatom.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_config.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_diag.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_phsft.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_plot.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_vkb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c sratom.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c upfout.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c wellstate.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c aeo.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c check_data.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c const_basis.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c dpnint.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c eresid.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c exchdl.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c exc_off_pbe.f
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c excpzca.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c excwig.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c ldiracfb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c ldiracfs.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschfb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschfs.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschkb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschpb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschpse.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschps.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschvkbbe.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschvkbb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschvkbs.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c modcore.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c optimize.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c pspot.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c qroots.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_optimize.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c sbf8.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c sbf_basis.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c sbf_rc_der.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c tfapot.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c vkboutwf.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c vkbphsft.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c vout.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c vpinteg.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c vploc.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c wf_rc_der.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c modcore2.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c gg1cc.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c gp1cc.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c gpp1cc.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c der2exc.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c fcrossover.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c modcore3.f90
-cpp -ansi -DLIBXC_VERSION=203   functionals.F90  > functionals_cpp.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -o functionals.o -c functionals_cpp.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c exc_libxc.f90
-gfortran -o oncvpsp.x oncvpsp.o fphsft.o fpovlp.o gnu_script.o linout.o psatom.o relatom.o run_config.o run_diag.o run_phsft.o run_plot.o run_vkb.o sratom.o upfout.o wellstate.o aeo.o check_data.o const_basis.o dpnint.o eresid.o exchdl.o exc_off_pbe.o excpzca.o excwig.o ldiracfb.o ldiracfs.o lschfb.o lschfs.o lschkb.o lschpb.o lschpse.o lschps.o lschvkbbe.o lschvkbb.o lschvkbs.o modcore.o optimize.o pspot.o qroots.o run_optimize.o sbf8.o sbf_basis.o sbf_rc_der.o tfapot.o vkboutwf.o vkbphsft.o vout.o vpinteg.o vploc.o wf_rc_der.o modcore2.o gg1cc.o gp1cc.o gpp1cc.o der2exc.o fcrossover.o modcore3.o functionals.o exc_libxc.o  -L/usr/local/lapack/lib -llapack -lrefblas -L/home/drh/abinit/fallbacks/exports/lib -lxc
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c oncvpsp_nr.f90
-gfortran -o oncvpspnr.x oncvpsp_nr.o fphsft.o fpovlp.o gnu_script.o linout.o psatom.o relatom.o run_config.o run_diag.o run_phsft.o run_plot.o run_vkb.o sratom.o upfout.o wellstate.o aeo.o check_data.o const_basis.o dpnint.o eresid.o exchdl.o exc_off_pbe.o excpzca.o excwig.o ldiracfb.o ldiracfs.o lschfb.o lschfs.o lschkb.o lschpb.o lschpse.o lschps.o lschvkbbe.o lschvkbb.o lschvkbs.o modcore.o optimize.o pspot.o qroots.o run_optimize.o sbf8.o sbf_basis.o sbf_rc_der.o tfapot.o vkboutwf.o vkbphsft.o vout.o vpinteg.o vploc.o wf_rc_der.o modcore2.o gg1cc.o gp1cc.o gpp1cc.o der2exc.o fcrossover.o modcore3.o functionals.o exc_libxc.o  -L/usr/local/lapack/lib -llapack -lrefblas -L/home/drh/abinit/fallbacks/exports/lib -lxc
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c oncvpsp_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c fphsft_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c fpovlp_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c gnu_script_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c linout_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c psatom_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c renorm_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_config_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_diag_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_diag_sr_so_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_phsft_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_plot_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_vkb_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c sr_so_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c upfout_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c wellstate_r.f90
-gfortran -o oncvpspr.x oncvpsp_r.o fphsft_r.o fpovlp_r.o gnu_script_r.o linout_r.o psatom_r.o relatom.o renorm_r.o run_config_r.o run_diag_r.o run_diag_sr_so_r.o run_phsft_r.o run_plot_r.o run_vkb_r.o sr_so_r.o upfout_r.o wellstate_r.o aeo.o check_data.o const_basis.o dpnint.o eresid.o exchdl.o exc_off_pbe.o excpzca.o excwig.o ldiracfb.o ldiracfs.o lschfb.o lschfs.o lschkb.o lschpb.o lschpse.o lschps.o lschvkbbe.o lschvkbb.o lschvkbs.o modcore.o optimize.o pspot.o qroots.o run_optimize.o sbf8.o sbf_basis.o sbf_rc_der.o tfapot.o vkboutwf.o vkbphsft.o vout.o vpinteg.o vploc.o wf_rc_der.o modcore2.o gg1cc.o gp1cc.o gpp1cc.o der2exc.o fcrossover.o modcore3.o functionals.o exc_libxc.o  -L/usr/local/lapack/lib -llapack -lrefblas -L/home/drh/abinit/fallbacks/exports/lib -lxc
-make[1]: Leaving directory `/home/drh/temp2/oncvpsp-3.2.1/src'
-./set_path
-cd tests/data ; ./TEST.sh
-make: *** No rule to make target `log'.  Stop.
diff -Naur oncvpsp-3.2.2/make.log oncvpsp-3.2.2--psml-42/make.log
--- oncvpsp-3.2.2/make.log	2015-08-11 23:58:01.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/make.log	1970-01-01 01:00:00.000000000 +0100
@@ -1,85 +0,0 @@
-cd src ; make all
-make[1]: Entering directory `/home/drh/oncvpsp-3.2.2/src'
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c oncvpsp.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c fphsft.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c fpovlp.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c gnu_script.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c linout.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c psatom.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c relatom.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_config.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_diag.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_phsft.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_plot.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_vkb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c sratom.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c upfout.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c wellstate.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c aeo.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c check_data.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c const_basis.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c dpnint.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c eresid.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c exchdl.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c exc_off_pbe.f
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c excpzca.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c excwig.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c ldiracfb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c ldiracfs.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschfb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschfs.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschkb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschpb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschpse.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschps.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschvkbbe.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschvkbb.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c lschvkbs.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c modcore.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c optimize.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c pspot.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c qroots.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_optimize.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c sbf8.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c sbf_basis.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c sbf_rc_der.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c tfapot.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c vkboutwf.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c vkbphsft.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c vout.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c vpinteg.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c vploc.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c wf_rc_der.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c modcore2.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c gg1cc.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c gp1cc.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c gpp1cc.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c der2exc.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c fcrossover.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c modcore3.f90
-cpp -ansi -DLIBXC_VERSION=203   functionals.F90  > functionals_cpp.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -o functionals.o -c functionals_cpp.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c exc_libxc.f90
-gfortran -o oncvpsp.x oncvpsp.o fphsft.o fpovlp.o gnu_script.o linout.o psatom.o relatom.o run_config.o run_diag.o run_phsft.o run_plot.o run_vkb.o sratom.o upfout.o wellstate.o aeo.o check_data.o const_basis.o dpnint.o eresid.o exchdl.o exc_off_pbe.o excpzca.o excwig.o ldiracfb.o ldiracfs.o lschfb.o lschfs.o lschkb.o lschpb.o lschpse.o lschps.o lschvkbbe.o lschvkbb.o lschvkbs.o modcore.o optimize.o pspot.o qroots.o run_optimize.o sbf8.o sbf_basis.o sbf_rc_der.o tfapot.o vkboutwf.o vkbphsft.o vout.o vpinteg.o vploc.o wf_rc_der.o modcore2.o gg1cc.o gp1cc.o gpp1cc.o der2exc.o fcrossover.o modcore3.o functionals.o exc_libxc.o  -L/usr/local/lapack/lib -llapack -lrefblas -L/home/drh/abinit/fallbacks/exports/lib -lxc
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c oncvpsp_nr.f90
-gfortran -o oncvpspnr.x oncvpsp_nr.o fphsft.o fpovlp.o gnu_script.o linout.o psatom.o relatom.o run_config.o run_diag.o run_phsft.o run_plot.o run_vkb.o sratom.o upfout.o wellstate.o aeo.o check_data.o const_basis.o dpnint.o eresid.o exchdl.o exc_off_pbe.o excpzca.o excwig.o ldiracfb.o ldiracfs.o lschfb.o lschfs.o lschkb.o lschpb.o lschpse.o lschps.o lschvkbbe.o lschvkbb.o lschvkbs.o modcore.o optimize.o pspot.o qroots.o run_optimize.o sbf8.o sbf_basis.o sbf_rc_der.o tfapot.o vkboutwf.o vkbphsft.o vout.o vpinteg.o vploc.o wf_rc_der.o modcore2.o gg1cc.o gp1cc.o gpp1cc.o der2exc.o fcrossover.o modcore3.o functionals.o exc_libxc.o  -L/usr/local/lapack/lib -llapack -lrefblas -L/home/drh/abinit/fallbacks/exports/lib -lxc
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c oncvpsp_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c fphsft_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c fpovlp_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c gnu_script_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c linout_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c psatom_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c renorm_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_config_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_diag_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_diag_sr_so_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_phsft_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_plot_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c run_vkb_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c sr_so_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c upfout_r.f90
-gfortran -O3 -ffast-math -funroll-loops -I/home/drh/abinit/fallbacks/exports/include  -c wellstate_r.f90
-gfortran -o oncvpspr.x oncvpsp_r.o fphsft_r.o fpovlp_r.o gnu_script_r.o linout_r.o psatom_r.o relatom.o renorm_r.o run_config_r.o run_diag_r.o run_diag_sr_so_r.o run_phsft_r.o run_plot_r.o run_vkb_r.o sr_so_r.o upfout_r.o wellstate_r.o aeo.o check_data.o const_basis.o dpnint.o eresid.o exchdl.o exc_off_pbe.o excpzca.o excwig.o ldiracfb.o ldiracfs.o lschfb.o lschfs.o lschkb.o lschpb.o lschpse.o lschps.o lschvkbbe.o lschvkbb.o lschvkbs.o modcore.o optimize.o pspot.o qroots.o run_optimize.o sbf8.o sbf_basis.o sbf_rc_der.o tfapot.o vkboutwf.o vkbphsft.o vout.o vpinteg.o vploc.o wf_rc_der.o modcore2.o gg1cc.o gp1cc.o gpp1cc.o der2exc.o fcrossover.o modcore3.o functionals.o exc_libxc.o  -L/usr/local/lapack/lib -llapack -lrefblas -L/home/drh/abinit/fallbacks/exports/lib -lxc
-make[1]: Leaving directory `/home/drh/oncvpsp-3.2.2/src'
-./set_path
-cd tests/data ; ./TEST.sh
diff -Naur oncvpsp-3.2.2/src/.gitignore oncvpsp-3.2.2--psml-42/src/.gitignore
--- oncvpsp-3.2.2/src/.gitignore	1970-01-01 01:00:00.000000000 +0100
+++ oncvpsp-3.2.2--psml-42/src/.gitignore	2016-06-30 16:57:17.000000000 +0200
@@ -0,0 +1,2 @@
+*.o
+*.x
diff -Naur oncvpsp-3.2.2/src/Makefile oncvpsp-3.2.2--psml-42/src/Makefile
--- oncvpsp-3.2.2/src/Makefile	2015-08-06 16:05:26.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/src/Makefile	2016-06-30 16:57:17.000000000 +0200
@@ -1,10 +1,16 @@
-# Makefile for ONCVPSP
+# Makefile for ONCVPSP+psml
 #
 # Copyright (c) 1989-2015 by D. R. Hamann, Mat-Sim Research LLC and Rutgers
 # University
+# Copyright (c) 2015 by Alberto Garcia (PSML part)
 #
-
-include ../make.inc
+include fortran.mk
+#
+.SUFFIXES:
+.SUFFIXES: .f .f90 .F .F90 .o .a
+#
+default: all
+###include ../make.inc
 
 OBJS_ALL =	aeo.o check_data.o const_basis.o dpnint.o eresid.o exchdl.o \
 		exc_off_pbe.o excpzca.o excwig.o ldiracfb.o ldiracfs.o \
@@ -14,51 +20,44 @@
 		sbf_rc_der.o tfapot.o vkboutwf.o vkbphsft.o vout.o vpinteg.o \
 		vploc.o wf_rc_der.o modcore2.o gg1cc.o gp1cc.o gpp1cc.o \
 		der2exc.o fcrossover.o modcore3.o
-
 OBJS_NRSR =	fphsft.o fpovlp.o gnu_script.o linout.o psatom.o \
 		relatom.o run_config.o run_diag.o run_phsft.o run_plot.o \
 		run_vkb.o sratom.o upfout.o wellstate.o
-
 OBJS_SR =	oncvpsp.o
-
 OBJS_NR =	oncvpsp_nr.o
-
 OBJS_R =	oncvpsp_r.o fphsft_r.o fpovlp_r.o gnu_script_r.o linout_r.o \
 		psatom_r.o relatom.o renorm_r.o run_config_r.o run_diag_r.o \
 		run_diag_sr_so_r.o run_phsft_r.o run_plot_r.o run_vkb_r.o \
 		sr_so_r.o upfout_r.o wellstate_r.o
+#
+OBJS_PSML = m_psmlout.o m_libxc_list.o m_uuid.o
+#
+m_psmlout.o: m_uuid.o
 
-OBJS_OPSP = 	$(OBJS_SR) $(OBJS_NRSR) $(OBJS_ALL) $(OBJS_LIBXC)
-
-OBJS_OPSPNR = 	$(OBJS_NR) $(OBJS_NRSR) $(OBJS_ALL) $(OBJS_LIBXC)
-
-OBJS_OPSPR = 	$(OBJS_R) $(OBJS_ALL) $(OBJS_LIBXC)
-
+OBJS_OPSP = 	$(OBJS_SR) $(OBJS_NRSR) $(OBJS_ALL) $(OBJS_LIBXC) $(OBJS_PSML)
+#
+OBJS_OPSPNR = 	$(OBJS_NR) $(OBJS_NRSR) $(OBJS_ALL) $(OBJS_LIBXC) $(OBJS_PSML)
+#
+OBJS_OPSPR = 	$(OBJS_R) $(OBJS_ALL) $(OBJS_LIBXC) $(OBJS_PSML)
+#
+oncvpsp.o oncvpsp_r.o oncvpsp_nr.o: m_psmlout.o
+m_psmlout.o: m_libxc_list.o m_uuid.o
+#
 all:	oncvpsp oncvpspnr oncvpspr
 
-oncvpsp:	$(OBJS_OPSP)
-		$(FLINKER) -o oncvpsp.x $(OBJS_OPSP) $(LIBS)
+oncvpsp:	$(OBJS_OPSP) 
+		$(FLINKER) -o oncvpsp.x $(OBJS_OPSP) $(LIBS) 
 
 oncvpspnr:	$(OBJS_OPSPNR)
 		$(FLINKER) -o oncvpspnr.x $(OBJS_OPSPNR) $(LIBS)
 
-oncvpspr:	$(OBJS_OPSPR)
-		$(FLINKER) -o oncvpspr.x $(OBJS_OPSPR) $(LIBS)
-
-.SUFFIXES: .c .o .f .f90 .F90
-
-.F90.o:
-	$(FCCPP) $(FCCPPFLAGS) $*.F90  > $*_cpp.f90
-	$(F90) $(FFLAGS) $(INC) -o $*.o -c $*_cpp.f90
-
-.f90.o:
-	$(F90) $(FFLAGS) $(INC) -c $*.f90
-
-.f.o:
-	$(F90) $(FFLAGS) $(INC) -c $*.f
+oncvpspr:	$(OBJS_OPSPR) 
+		$(FLINKER) -o oncvpspr.x $(OBJS_OPSPR) $(LIBS) 
+#
 
-.c.o:
-	$(CC) $(CFLAGS) $(INC) -c $*.c
+#.F90.o:
+#	$(FCCPP) $(FCCPPFLAGS) $*.F90  > $*_cpp.f90
+#	$(F90) $(FFLAGS) $(INC) -o $*.o -c $*_cpp.f90
 
 clean:
 	 /bin/rm -f *.o  *.d  *.mod *.log *_cpp.f90
diff -Naur oncvpsp-3.2.2/src/fortran.mk oncvpsp-3.2.2--psml-42/src/fortran.mk
--- oncvpsp-3.2.2/src/fortran.mk	1970-01-01 01:00:00.000000000 +0100
+++ oncvpsp-3.2.2--psml-42/src/fortran.mk	2016-06-30 16:57:17.000000000 +0200
@@ -0,0 +1,67 @@
+#
+# 
+#
+F77        = gfortran	#EDIT
+F90        = gfortran	#EDIT
+CC         = gcc	#EDIT
+RANLIB     = echo
+AR         = ar
+
+FLINKER     = $(F90)
+
+FFLAGS     = -O3 -msse3 #EDIT
+CFLAGS     = -O3		#EDIT
+
+FCCPPFLAGS = -DLIBXC_VERSION=203  #This probably should not be changed
+
+#LIBS = -L/usr/local/opt/lapack/lib -llapack  -L/usr/local/opt/openblas/lib  -lopenblas	#EDIT
+
+#
+# This line works for MacOSX with veclibFort (a patch for Apple's veclib)
+# (See https://github.com/mcg1969/vecLibFort)
+# You might get good results simply with -framework veclib, but your mileage might vary
+# In case of doubt, get any of the fine blas/lapack packages out there.
+#
+LIBS = -lvecLibFort
+
+#
+# The xmlf90 library (its wxml subsystem) is needed to generate XML.
+# You can download xmlf90 from http://launchpad.net/xmlf90
+#
+XMLF90_ROOT=$(HOME)/lib/xmlf90/1.3/gfortran
+LIBS += -L$(XMLF90_ROOT)/lib -lxmlf90
+INC += -I$(XMLF90_ROOT)/modules
+
+#
+# Optional LIBXC support
+
+# oncvpsp is presently compatible with libxc-2.0.3, not later releases (???)
+
+# To build oncvpsp with libxc, use the following lines and edit
+# the paths to point to your libxc library and include directories
+# make clean in src before rebuilding after changing this
+#
+LIBXC_ROOT=$(HOME)/lib/libxc/2.2.0/gfortran-5.2.0
+LIBS += -L$(LIBXC_ROOT)/lib -lxc -lxcf90
+INC += -I$(LIBXC_ROOT)/include
+OBJS_LIBXC =	functionals.o exc_libxc.o
+#
+# Otherwise, use only the following line
+#
+#OBJS_LIBXC =	exc_libxc_stub.o
+#
+#-------------------------------------------
+
+
+#
+
+#
+.f90.o:
+	$(F90) $(FFLAGS) $(INC) -c $*.f90
+.F90.o:
+	$(F90) $(FFLAGS) $(FCCPPFLAGS) $(INC) -c $*.F90
+.f.o:
+	$(F90) $(FFLAGS) $(INC) -c $*.f
+.F.o:
+	$(F90) $(FFLAGS) $(FCCPPFLAGS) $(INC) -c $*.F
+
diff -Naur oncvpsp-3.2.2/src/gnu_script.f90 oncvpsp-3.2.2--psml-42/src/gnu_script.f90
--- oncvpsp-3.2.2/src/gnu_script.f90	2015-08-06 16:05:26.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/src/gnu_script.f90	2016-06-30 16:57:17.000000000 +0200
@@ -134,7 +134,7 @@
 
  write(6,'(a)') 'GNUSCRIPT'
 
- set='set term wxt font "arial,14" size 800,600'
+ set='set term x11 font "arial,14" size 800,600'
  write(6,'(a/)') trim(set)
  set='set termoption dash'
  write(6,'(a/)') trim(set)
diff -Naur oncvpsp-3.2.2/src/gnu_script_r.f90 oncvpsp-3.2.2--psml-42/src/gnu_script_r.f90
--- oncvpsp-3.2.2/src/gnu_script_r.f90	2015-08-06 16:05:26.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/src/gnu_script_r.f90	2016-06-30 16:57:17.000000000 +0200
@@ -178,7 +178,7 @@
 
  write(6,'(a)') 'GNUSCRIPT'
 
- set='set term wxt font "arial,14" size 800,600'
+ set='set term x11 font "arial,14" size 800,600'
  write(6,'(a/)') trim(set)
  set='set termoption dash'
  write(6,'(a/)') trim(set)
diff -Naur oncvpsp-3.2.2/src/m_libxc_list.F90 oncvpsp-3.2.2--psml-42/src/m_libxc_list.F90
--- oncvpsp-3.2.2/src/m_libxc_list.F90	1970-01-01 01:00:00.000000000 +0100
+++ oncvpsp-3.2.2--psml-42/src/m_libxc_list.F90	2016-06-30 16:57:17.000000000 +0200
@@ -0,0 +1,215 @@
+module m_libxc_list
+!
+! List of selected functionals in libxc, wrapped
+! in a derived type record.
+!
+! Copyright (c) Alberto Garcia, 2014, 2015
+! 
+
+type, public :: libxc_kind_t
+   character(len=24) :: str
+end type libxc_kind_t
+
+type(libxc_kind_t), parameter :: EXCH = libxc_kind_t("XC_EXCHANGE")
+type(libxc_kind_t), parameter :: CORR = libxc_kind_t("XC_CORRELATION")
+type(libxc_kind_t), parameter :: EXCH_CORR =  &
+                                 libxc_kind_t("XC_EXCHANGE_CORRELATION")
+
+!character(len=*), parameter :: EXCH = "XC_EXCHANGE"
+!character(len=*), parameter :: CORR = "XC_CORRELATION"
+!character(len=*), parameter :: EXCH_CORR = "XC_EXCHANGE_CORRELATION"
+
+type, public :: libxc_t
+   character(len=40)  :: name
+   integer            :: code
+   type(libxc_kind_t) :: xc_kind
+!   character(len=40)  :: xc_kind
+end type libxc_t
+
+type(libxc_t), parameter, public  ::                  &
+   XC_EMPTY = libxc_t("XC_EMPTY", 0 , EXCH_CORR),  &
+   XC_NOT_IMPL = libxc_t("XC_NOT_IMPL", -1 , EXCH_CORR)
+
+! Exchange
+
+type(libxc_t), parameter  ::                  &
+   XC_LDA_X = libxc_t("XC_LDA_X", 1 , EXCH),  &
+   XC_LDA_X_2D = libxc_t("XC_LDA_X_2D", 19 , EXCH),  &
+   XC_LDA_X_1D = libxc_t("XC_LDA_X_1D", 21 , EXCH),  &
+   XC_GGA_X_Q2D = libxc_t("XC_GGA_X_Q2D", 48 , EXCH),  &
+   XC_GGA_X_PBE_MOL = libxc_t("XC_GGA_X_PBE_MOL", 49 , EXCH),  &
+   XC_GGA_X_AK13 = libxc_t("XC_GGA_X_AK13", 56 , EXCH),  &
+   XC_GGA_X_LV_RPW86 = libxc_t("XC_GGA_X_LV_RPW86", 58 , EXCH),  &
+   XC_GGA_X_PBE_TCA = libxc_t("XC_GGA_X_PBE_TCA", 59 , EXCH),  &
+   XC_GGA_X_PBEINT = libxc_t("XC_GGA_X_PBEINT", 60 , EXCH),  &
+   XC_GGA_X_VMT84_GE = libxc_t("XC_GGA_X_VMT84_GE", 68 , EXCH),  &
+   XC_GGA_X_VMT84_PBE = libxc_t("XC_GGA_X_VMT84_PBE", 69 , EXCH),  &
+   XC_GGA_X_VMT_GE = libxc_t("XC_GGA_X_VMT_GE", 70 , EXCH),  &
+   XC_GGA_X_VMT_PBE = libxc_t("XC_GGA_X_VMT_PBE", 71 , EXCH),  &
+   XC_GGA_X_N12 = libxc_t("XC_GGA_X_N12", 82 , EXCH),  &
+   XC_GGA_X_SSB_SW = libxc_t("XC_GGA_X_SSB_SW", 90 , EXCH),  &
+   XC_GGA_X_SSB = libxc_t("XC_GGA_X_SSB", 91 , EXCH),  &
+   XC_GGA_X_SSB_D = libxc_t("XC_GGA_X_SSB_D", 92 , EXCH),  &
+   XC_GGA_X_BPCCAC = libxc_t("XC_GGA_X_BPCCAC", 98 , EXCH),  &
+   XC_GGA_X_PBE = libxc_t("XC_GGA_X_PBE", 101 , EXCH),  &
+   XC_GGA_X_PBE_R = libxc_t("XC_GGA_X_PBE_R", 102 , EXCH),  &
+   XC_GGA_X_B86 = libxc_t("XC_GGA_X_B86", 103 , EXCH),  &
+   XC_GGA_X_HERMAN = libxc_t("XC_GGA_X_HERMAN", 104 , EXCH),  &
+   XC_GGA_X_B86_MGC = libxc_t("XC_GGA_X_B86_MGC", 105 , EXCH),  &
+   XC_GGA_X_B88 = libxc_t("XC_GGA_X_B88", 106 , EXCH),  &
+   XC_GGA_X_G96 = libxc_t("XC_GGA_X_G96", 107 , EXCH),  &
+   XC_GGA_X_PW86 = libxc_t("XC_GGA_X_PW86", 108 , EXCH),  &
+   XC_GGA_X_PW91 = libxc_t("XC_GGA_X_PW91", 109 , EXCH),  &
+   XC_GGA_X_OPTX = libxc_t("XC_GGA_X_OPTX", 110 , EXCH),  &
+   XC_GGA_X_DK87_R1 = libxc_t("XC_GGA_X_DK87_R1", 111 , EXCH),  &
+   XC_GGA_X_DK87_R2 = libxc_t("XC_GGA_X_DK87_R2", 112 , EXCH),  &
+   XC_GGA_X_LG93 = libxc_t("XC_GGA_X_LG93", 113 , EXCH),  &
+   XC_GGA_X_FT97_A = libxc_t("XC_GGA_X_FT97_A", 114 , EXCH),  &
+   XC_GGA_X_FT97_B = libxc_t("XC_GGA_X_FT97_B", 115 , EXCH),  &
+   XC_GGA_X_PBE_SOL = libxc_t("XC_GGA_X_PBE_SOL", 116 , EXCH),  &
+   XC_GGA_X_RPBE = libxc_t("XC_GGA_X_RPBE", 117 , EXCH),  &
+   XC_GGA_X_WC = libxc_t("XC_GGA_X_WC", 118 , EXCH),  &
+   XC_GGA_X_MPW91 = libxc_t("XC_GGA_X_MPW91", 119 , EXCH),  &
+   XC_GGA_X_AM05 = libxc_t("XC_GGA_X_AM05", 120 , EXCH),  &
+   XC_GGA_X_PBEA = libxc_t("XC_GGA_X_PBEA", 121 , EXCH),  &
+   XC_GGA_X_MPBE = libxc_t("XC_GGA_X_MPBE", 122 , EXCH),  &
+   XC_GGA_X_XPBE = libxc_t("XC_GGA_X_XPBE", 123 , EXCH),  &
+   XC_GGA_X_2D_B86_MGC = libxc_t("XC_GGA_X_2D_B86_MGC", 124 , EXCH),  &
+   XC_GGA_X_BAYESIAN = libxc_t("XC_GGA_X_BAYESIAN", 125 , EXCH),  &
+   XC_GGA_X_PBE_JSJR = libxc_t("XC_GGA_X_PBE_JSJR", 126 , EXCH),  &
+   XC_GGA_X_2D_B88 = libxc_t("XC_GGA_X_2D_B88", 127 , EXCH),  &
+   XC_GGA_X_2D_B86 = libxc_t("XC_GGA_X_2D_B86", 128 , EXCH),  &
+   XC_GGA_X_2D_PBE = libxc_t("XC_GGA_X_2D_PBE", 129 , EXCH),  &
+   XC_GGA_X_OPTB88_VDW = libxc_t("XC_GGA_X_OPTB88_VDW", 139 , EXCH),  &
+   XC_GGA_X_PBEK1_VDW = libxc_t("XC_GGA_X_PBEK1_VDW", 140 , EXCH),  &
+   XC_GGA_X_OPTPBE_VDW = libxc_t("XC_GGA_X_OPTPBE_VDW", 141 , EXCH),  &
+   XC_GGA_X_RGE2 = libxc_t("XC_GGA_X_RGE2", 142 , EXCH),  &
+   XC_GGA_X_RPW86 = libxc_t("XC_GGA_X_RPW86", 144 , EXCH),  &
+   XC_GGA_X_KT1 = libxc_t("XC_GGA_X_KT1", 145 , EXCH),  &
+   XC_GGA_X_MB88 = libxc_t("XC_GGA_X_MB88", 149 , EXCH),  &
+   XC_GGA_X_SOGGA = libxc_t("XC_GGA_X_SOGGA", 150 , EXCH),  &
+   XC_GGA_X_SOGGA11 = libxc_t("XC_GGA_X_SOGGA11", 151 , EXCH),  &
+   XC_GGA_X_C09X = libxc_t("XC_GGA_X_C09X", 158 , EXCH),  &
+   XC_GGA_X_LB = libxc_t("XC_GGA_X_LB", 160 , EXCH),  &
+   XC_GGA_X_LBM = libxc_t("XC_GGA_X_LBM", 182 , EXCH),  &
+   XC_GGA_X_OL2 = libxc_t("XC_GGA_X_OL2", 183 , EXCH),  &
+   XC_GGA_X_APBE = libxc_t("XC_GGA_X_APBE", 184 , EXCH),  &
+   XC_GGA_X_HTBS = libxc_t("XC_GGA_X_HTBS", 191 , EXCH),  &
+   XC_GGA_X_AIRY = libxc_t("XC_GGA_X_AIRY", 192 , EXCH),  &
+   XC_GGA_X_LAG = libxc_t("XC_GGA_X_LAG", 193 , EXCH),  &
+   XC_GGA_X_WPBEH = libxc_t("XC_GGA_X_WPBEH", 524 , EXCH),  &
+   XC_GGA_X_HJS_PBE = libxc_t("XC_GGA_X_HJS_PBE", 525 , EXCH),  &
+   XC_GGA_X_HJS_PBE_SOL = libxc_t("XC_GGA_X_HJS_PBE_SOL", 526 , EXCH),  &
+   XC_GGA_X_HJS_B88 = libxc_t("XC_GGA_X_HJS_B88", 527 , EXCH),  &
+   XC_GGA_X_HJS_B97X = libxc_t("XC_GGA_X_HJS_B97X", 528 , EXCH),  &
+   XC_GGA_X_ITYH = libxc_t("XC_GGA_X_ITYH", 529 , EXCH),  &
+   XC_GGA_X_SFAT = libxc_t("XC_GGA_X_SFAT", 530 , EXCH)
+
+! Correlation
+
+type(libxc_t), parameter  ::                  &
+   XC_LDA_C_WIGNER = libxc_t("XC_LDA_C_WIGNER", 2 , CORR),  &
+   XC_LDA_C_RPA = libxc_t("XC_LDA_C_RPA", 3 , CORR),  &
+   XC_LDA_C_HL = libxc_t("XC_LDA_C_HL", 4 , CORR),  &
+   XC_LDA_C_GL = libxc_t("XC_LDA_C_GL", 5 , CORR),  &
+   XC_LDA_C_XALPHA = libxc_t("XC_LDA_C_XALPHA", 6 , CORR),  &
+   XC_LDA_C_VWN = libxc_t("XC_LDA_C_VWN", 7 , CORR),  &
+   XC_LDA_C_VWN_RPA = libxc_t("XC_LDA_C_VWN_RPA", 8 , CORR),  &
+   XC_LDA_C_PZ = libxc_t("XC_LDA_C_PZ", 9 , CORR),  &
+   XC_LDA_C_PZ_MOD = libxc_t("XC_LDA_C_PZ_MOD", 10 , CORR),  &
+   XC_LDA_C_OB_PZ = libxc_t("XC_LDA_C_OB_PZ", 11 , CORR),  &
+   XC_LDA_C_PW = libxc_t("XC_LDA_C_PW", 12 , CORR),  &
+   XC_LDA_C_PW_MOD = libxc_t("XC_LDA_C_PW_MOD", 13 , CORR),  &
+   XC_LDA_C_OB_PW = libxc_t("XC_LDA_C_OB_PW", 14 , CORR),  &
+   XC_LDA_C_2D_AMGB = libxc_t("XC_LDA_C_2D_AMGB", 15 , CORR),  &
+   XC_LDA_C_2D_PRM = libxc_t("XC_LDA_C_2D_PRM", 16 , CORR),  &
+   XC_LDA_C_vBH = libxc_t("XC_LDA_C_vBH", 17 , CORR),  &
+   XC_LDA_C_1D_CSC = libxc_t("XC_LDA_C_1D_CSC", 18 , CORR),  &
+   XC_LDA_C_ML1 = libxc_t("XC_LDA_C_ML1", 22 , CORR),  &
+   XC_LDA_C_ML2 = libxc_t("XC_LDA_C_ML2", 23 , CORR),  &
+   XC_LDA_C_GOMBAS = libxc_t("XC_LDA_C_GOMBAS", 24 , CORR),  &
+   XC_LDA_C_PW_RPA = libxc_t("XC_LDA_C_PW_RPA", 25 , CORR),  &
+   XC_LDA_C_1D_LOOS = libxc_t("XC_LDA_C_1D_LOOS", 26 , CORR),  &
+   XC_LDA_C_RC04 = libxc_t("XC_LDA_C_RC04", 27 , CORR),  &
+   XC_LDA_C_VWN_1 = libxc_t("XC_LDA_C_VWN_1", 28 , CORR),  &
+   XC_LDA_C_VWN_2 = libxc_t("XC_LDA_C_VWN_2", 29 , CORR),  &
+   XC_LDA_C_VWN_3 = libxc_t("XC_LDA_C_VWN_3", 30 , CORR),  &
+   XC_LDA_C_VWN_4 = libxc_t("XC_LDA_C_VWN_4", 31 , CORR),  &
+   XC_GGA_C_Q2D = libxc_t("XC_GGA_C_Q2D", 47 , CORR),  &
+   XC_GGA_C_ZPBEINT = libxc_t("XC_GGA_C_ZPBEINT", 61 , CORR),  &
+   XC_GGA_C_PBEINT = libxc_t("XC_GGA_C_PBEINT", 62 , CORR),  &
+   XC_GGA_C_ZPBESOL = libxc_t("XC_GGA_C_ZPBESOL", 63 , CORR),  &
+   XC_GGA_C_N12_SX = libxc_t("XC_GGA_C_N12_SX", 79 , CORR),  &
+   XC_GGA_C_N12 = libxc_t("XC_GGA_C_N12", 80 , CORR),  &
+   XC_GGA_C_VPBE = libxc_t("XC_GGA_C_VPBE", 83 , CORR),  &
+   XC_GGA_C_OP_XALPHA = libxc_t("XC_GGA_C_OP_XALPHA", 84 , CORR),  &
+   XC_GGA_C_OP_G96 = libxc_t("XC_GGA_C_OP_G96", 85 , CORR),  &
+   XC_GGA_C_OP_PBE = libxc_t("XC_GGA_C_OP_PBE", 86 , CORR),  &
+   XC_GGA_C_OP_B88 = libxc_t("XC_GGA_C_OP_B88", 87 , CORR),  &
+   XC_GGA_C_FT97 = libxc_t("XC_GGA_C_FT97", 88 , CORR),  &
+   XC_GGA_C_SPBE = libxc_t("XC_GGA_C_SPBE", 89 , CORR),  &
+   XC_GGA_C_REVTCA = libxc_t("XC_GGA_C_REVTCA", 99 , CORR),  &
+   XC_GGA_C_TCA = libxc_t("XC_GGA_C_TCA", 100 , CORR),  &
+   XC_GGA_C_PBE = libxc_t("XC_GGA_C_PBE", 130 , CORR),  &
+   XC_GGA_C_LYP = libxc_t("XC_GGA_C_LYP", 131 , CORR),  &
+   XC_GGA_C_P86 = libxc_t("XC_GGA_C_P86", 132 , CORR),  &
+   XC_GGA_C_PBE_SOL = libxc_t("XC_GGA_C_PBE_SOL", 133 , CORR),  &
+   XC_GGA_C_PW91 = libxc_t("XC_GGA_C_PW91", 134 , CORR),  &
+   XC_GGA_C_AM05 = libxc_t("XC_GGA_C_AM05", 135 , CORR),  &
+   XC_GGA_C_XPBE = libxc_t("XC_GGA_C_XPBE", 136 , CORR),  &
+   XC_GGA_C_LM = libxc_t("XC_GGA_C_LM", 137 , CORR),  &
+   XC_GGA_C_PBE_JRGX = libxc_t("XC_GGA_C_PBE_JRGX", 138 , CORR),  &
+   XC_GGA_C_RGE2 = libxc_t("XC_GGA_C_RGE2", 143 , CORR),  &
+   XC_GGA_C_WL = libxc_t("XC_GGA_C_WL", 147 , CORR),  &
+   XC_GGA_C_WI = libxc_t("XC_GGA_C_WI", 148 , CORR),  &
+   XC_GGA_C_SOGGA11 = libxc_t("XC_GGA_C_SOGGA11", 152 , CORR),  &
+   XC_GGA_C_WI0 = libxc_t("XC_GGA_C_WI0", 153 , CORR),  &
+   XC_GGA_C_SOGGA11_X = libxc_t("XC_GGA_C_SOGGA11_X", 159 , CORR),  &
+   XC_GGA_C_APBE = libxc_t("XC_GGA_C_APBE", 186 , CORR),  &
+   XC_GGA_C_OPTC = libxc_t("XC_GGA_C_OPTC", 200 , CORR)
+
+! Exchange and correlation
+type(libxc_t), parameter  ::                  &
+   XC_LDA_XC_TETER93 = libxc_t("XC_LDA_XC_TETER93", 20 , EXCH_CORR),  &
+   XC_GGA_XC_OPBE_D = libxc_t("XC_GGA_XC_OPBE_D", 65 , EXCH_CORR),  &
+   XC_GGA_XC_OPWLYP_D = libxc_t("XC_GGA_XC_OPWLYP_D", 66 , EXCH_CORR),  &
+   XC_GGA_XC_OBLYP_D = libxc_t("XC_GGA_XC_OBLYP_D", 67 , EXCH_CORR),  &
+   XC_GGA_XC_HCTH_407P = libxc_t("XC_GGA_XC_HCTH_407P", 93 , EXCH_CORR),  &
+   XC_GGA_XC_HCTH_P76 = libxc_t("XC_GGA_XC_HCTH_P76", 94 , EXCH_CORR),  &
+   XC_GGA_XC_HCTH_P14 = libxc_t("XC_GGA_XC_HCTH_P14", 95 , EXCH_CORR),  &
+   XC_GGA_XC_B97_GGA1 = libxc_t("XC_GGA_XC_B97_GGA1", 96 , EXCH_CORR),  &
+   XC_GGA_XC_HCTH_A = libxc_t("XC_GGA_XC_HCTH_A", 97 , EXCH_CORR),  &
+   XC_GGA_XC_KT2 = libxc_t("XC_GGA_XC_KT2", 146 , EXCH_CORR),  &
+   XC_GGA_XC_TH1 = libxc_t("XC_GGA_XC_TH1", 154 , EXCH_CORR),  &
+   XC_GGA_XC_TH2 = libxc_t("XC_GGA_XC_TH2", 155 , EXCH_CORR),  &
+   XC_GGA_XC_TH3 = libxc_t("XC_GGA_XC_TH3", 156 , EXCH_CORR),  &
+   XC_GGA_XC_TH4 = libxc_t("XC_GGA_XC_TH4", 157 , EXCH_CORR),  &
+   XC_GGA_XC_HCTH_93 = libxc_t("XC_GGA_XC_HCTH_93", 161 , EXCH_CORR),  &
+   XC_GGA_XC_HCTH_120 = libxc_t("XC_GGA_XC_HCTH_120", 162 , EXCH_CORR),  &
+   XC_GGA_XC_HCTH_147 = libxc_t("XC_GGA_XC_HCTH_147", 163 , EXCH_CORR),  &
+   XC_GGA_XC_HCTH_407 = libxc_t("XC_GGA_XC_HCTH_407", 164 , EXCH_CORR),  &
+   XC_GGA_XC_EDF1 = libxc_t("XC_GGA_XC_EDF1", 165 , EXCH_CORR),  &
+   XC_GGA_XC_XLYP = libxc_t("XC_GGA_XC_XLYP", 166 , EXCH_CORR),  &
+   XC_GGA_XC_B97 = libxc_t("XC_GGA_XC_B97", 167 , EXCH_CORR),  &
+   XC_GGA_XC_B97_1 = libxc_t("XC_GGA_XC_B97_1", 168 , EXCH_CORR),  &
+   XC_GGA_XC_B97_2 = libxc_t("XC_GGA_XC_B97_2", 169 , EXCH_CORR),  &
+   XC_GGA_XC_B97_D = libxc_t("XC_GGA_XC_B97_D", 170 , EXCH_CORR),  &
+   XC_GGA_XC_B97_K = libxc_t("XC_GGA_XC_B97_K", 171 , EXCH_CORR),  &
+   XC_GGA_XC_B97_3 = libxc_t("XC_GGA_XC_B97_3", 172 , EXCH_CORR),  &
+   XC_GGA_XC_PBE1W = libxc_t("XC_GGA_XC_PBE1W", 173 , EXCH_CORR),  &
+   XC_GGA_XC_MPWLYP1W = libxc_t("XC_GGA_XC_MPWLYP1W", 174 , EXCH_CORR),  &
+   XC_GGA_XC_PBELYP1W = libxc_t("XC_GGA_XC_PBELYP1W", 175 , EXCH_CORR),  &
+   XC_GGA_XC_SB98_1a = libxc_t("XC_GGA_XC_SB98_1a", 176 , EXCH_CORR),  &
+   XC_GGA_XC_SB98_1b = libxc_t("XC_GGA_XC_SB98_1b", 177 , EXCH_CORR),  &
+   XC_GGA_XC_SB98_1c = libxc_t("XC_GGA_XC_SB98_1c", 178 , EXCH_CORR),  &
+   XC_GGA_XC_SB98_2a = libxc_t("XC_GGA_XC_SB98_2a", 179 , EXCH_CORR),  &
+   XC_GGA_XC_SB98_2b = libxc_t("XC_GGA_XC_SB98_2b", 180 , EXCH_CORR),  &
+   XC_GGA_XC_SB98_2c = libxc_t("XC_GGA_XC_SB98_2c", 181 , EXCH_CORR),  &
+   XC_GGA_XC_MOHLYP = libxc_t("XC_GGA_XC_MOHLYP", 194 , EXCH_CORR),  &
+   XC_GGA_XC_MOHLYP2 = libxc_t("XC_GGA_XC_MOHLYP2", 195 , EXCH_CORR),  &
+   XC_GGA_XC_TH_FL = libxc_t("XC_GGA_XC_TH_FL", 196 , EXCH_CORR),  &
+   XC_GGA_XC_TH_FC = libxc_t("XC_GGA_XC_TH_FC", 197 , EXCH_CORR),  &
+   XC_GGA_XC_TH_FCFO = libxc_t("XC_GGA_XC_TH_FCFO", 198 , EXCH_CORR),  &
+   XC_GGA_XC_TH_FCO = libxc_t("XC_GGA_XC_TH_FCO", 199 , EXCH_CORR)
+
+end module m_libxc_list
diff -Naur oncvpsp-3.2.2/src/m_psmlout.f90 oncvpsp-3.2.2--psml-42/src/m_psmlout.f90
--- oncvpsp-3.2.2/src/m_psmlout.f90	1970-01-01 01:00:00.000000000 +0100
+++ oncvpsp-3.2.2--psml-42/src/m_psmlout.f90	2016-06-30 16:57:17.000000000 +0200
@@ -0,0 +1,1367 @@
+!
+! Copyright (c) 1989-2015 by D. R. Hamann, Mat-Sim Research LLC and Rutgers
+! University
+! Copyright (c) 2015 by Alberto Garcia, ICMAB-CSIC for xmlf90-wxml calls
+! in support of the PSML format
+!
+! 
+! This program is free software: you can redistribute it and/or modify
+! it under the terms of the GNU General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+! 
+! This program is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU General Public License for more details.
+! 
+! You should have received a copy of the GNU General Public License
+! along with this program.  If not, see <http://www.gnu.org/licenses/>.
+!
+! Support for PSML file creation
+!
+module m_psmlout
+
+  public :: psmlout, psmlout_r, copy_input_file_for_psml
+  private
+
+  integer, parameter :: dp = selected_real_kind(10,100)
+  character(len=1), dimension(0:4) :: lsymb = (/'s','p','d','f','g'/)
+
+  CONTAINS
+
+ subroutine psmlout(lmax,lloc,rc,vkb,evkb,nproj,rr,vpuns,rho,rhomod, &
+&                  irct, srel, &
+&                  zz,zion,mmax,iexc,icmod,nrl0,drl,atsym,epstot, &
+&                  na,la,ncon,nbas,nvcnf,nacnf,lacnf,nc,nv,lpopt,ncnf, &
+&                  fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
+&                  epsh1,epsh2,depsh,rlmax,psfile,uua)
+
+!lmax  maximum angular momentum
+!lloc  l for local potential
+!rc  core radii
+!vkb  VKB projectors
+!evkb  coefficients of VKB projectors
+!nproj  number of vkb projectors for each l
+!rr  log radial grid
+!vpuns  unscreened semi-local pseudopotentials (vp(:,5) is local potential 
+!  if linear combination is used)
+!rho  valence pseudocharge
+!rhomod  model core charge
+!zz  atomic number
+!zion  at this point, total valence charge (becomes pseudoion charge)
+!mmax  size of log radial grid
+!iexc  type of exchange-correlation
+!icmod  1 if model core charge is used, otherwise 0
+!nrl0 suggested size of linear radial grid in input file
+!drl spacing of linear radial grid
+!atsym  atomic symbol
+!epstot  pseudoatom total energy
+!psfile  should be 'upf' or 'psp8'
+!uua pseudo-atomic orbital array
+
+  ! Alberto Garcia, February 1, 2015
+
+  use xmlf90_wxml     ! To write XML files
+  use m_libxc_list  ! For ease of libxc handling
+  use m_uuid        ! To generate uuid
+
+ implicit none
+
+ real(dp), parameter :: pi=3.141592653589793238462643383279502884197_dp
+
+!Input variables
+ integer :: lmax,lloc,iexc,mmax,nrl0,icmod
+ integer :: nproj(6)
+ integer :: irct ! index of point at which rho_core is matched
+ logical :: srel ! whether it is scalar-relativistic or not
+ real(dp) :: drl,fcfact,zz,zion,epstot
+ real(dp), target :: rr(mmax),vpuns(mmax,5),rho(mmax),vkb(mmax,2,4)
+ real(dp), target :: rhomod(mmax,5)
+ real(dp):: rc(6),evkb(2,4)
+ character*2 :: atsym
+ character(len=40) :: fname
+
+!additional input for upf output to echo input file, all as defined
+! in the main progam
+ integer :: na(30),la(30),ncon(6),nbas(6)
+ integer :: nvcnf(5),nacnf(30,5),lacnf(30,5)
+ integer :: nc,nv,lpopt,ncnf
+ real(dp) :: fa(30),rc0(6),ep(6),qcut(6),debl(6),facnf(30,5)
+ real(dp) :: dvloc0,epsh1,epsh2,depsh,rlmax
+ character*4 :: psfile
+ real(dp) :: uua(mmax,nv)
+
+!Local variables
+ integer :: dtime(8), nrl
+ logical :: nrl_changed
+
+!-------
+!psml stuff
+
+  type(xmlf_t) :: xf
+  type(libxc_t) :: libxc_id(2)
+
+  integer   :: i, j, npts
+  integer   :: ii, jj, l1
+  real(dp)  :: rcore
+  real(dp)  :: total_valence_charge
+  real(dp), pointer :: r(:), chval(:), chcore(:)
+  real(dp), pointer :: vps(:), vlocal(:)
+  real(dp), allocatable :: r0(:), f0(:)
+
+  character(len=100)    :: line
+  character*4      :: polattrib, coreattrib
+  character*1      :: pscode, char_dummy
+  character(len=2) :: nameat
+  character(len=40):: psflavor
+
+  character(len=1), dimension(0:4) :: lsymb = (/'s','p','d','f','g'/)
+
+  character*30 xcfuntype, xcfunparam
+  integer :: x_code, c_code
+  integer          :: ncore, nval, ncp, norbs, npots
+
+  integer, allocatable  :: n(:), l(:)
+  integer, allocatable  :: nn(:), ll(:)
+  real(dp), allocatable :: f(:), ff(:)
+  real(dp), allocatable :: fdown(:), fup(:)
+
+  character(len=10)     :: datestr
+
+  logical :: tdopsp, nonrel, polarized, there_is_core, found
+  integer :: lun, stat
+
+  external :: dpnint   ! Resampler + extrapolator to r=0
+
+!---
+
+ call date_and_time(VALUES=dtime)
+ write(datestr,"(i4,'-',i2.2,'-',i2.2)") dtime(1:3)
+
+  call xml_OpenFile("ONCVPSPPSML",xf, indent=.false.)
+
+  call xml_AddXMLDeclaration(xf,"UTF-8")
+
+  call xml_NewElement(xf,"psml")
+  call my_add_attribute(xf,"version","0.9")
+  call my_add_attribute(xf,"energy_unit","hartree")
+  call my_add_attribute(xf,"length_unit","bohr")
+  call my_add_attribute(xf,"uuid",generate_uuid(version=1))
+
+  call xml_NewElement(xf,"provenance")
+  call my_add_attribute(xf,"creator","ONCVPSP-3.2.2+psml")
+  call my_add_attribute(xf,"date",datestr)
+  call xml_NewElement(xf,"input-file")
+  call my_add_attribute(xf,"name","oncvpsp-input")
+!
+!    Use INP_COPY (generated in the main program)
+!
+  call cdata_section_from_file(xf,"INP_COPY")
+
+  call xml_EndElement(xf,"input-file")
+  !
+  call xml_EndElement(xf,"provenance")
+
+!  nameat = symbol(nint(zz))
+  nameat = atsym
+  ncore  = nc
+  nval   = nv
+
+  norbs = ncore + nval
+  allocate (n(norbs), l(norbs), f(norbs))
+
+  total_valence_charge = 0.0_dp
+  ncp = ncore + 1
+  do i = 1, norbs
+     n(i) = na(i)
+     l(i) = la(i)
+     f(i) = fa(i)
+     if (i > ncore) then
+        total_valence_charge =   total_valence_charge + f(i)
+     endif
+  enddo
+  lmax = lmax
+
+  npots = lmax + 1
+  allocate (ll(npots), nn(npots), ff(npots))
+  do i = 1, npots
+     ll(i) = i - 1
+     found = .false.
+     ! look for the appropriate shell in the valence
+     do j = ncp, norbs
+        if (l(j) == ll(i)) then
+           found = .true.
+           nn(i) = n(j)
+           ff(i) = f(j)
+           exit
+        endif
+     enddo
+     if (.not. found) then
+        ! generate the appropriate effective n
+        nn(i) = ll(i) + 1
+        do j = 1, ncore
+           if (l(j) == ll(i)) then
+              nn(i) = nn(i) + 1
+           endif
+           ff(i) = 0.0_dp
+        enddo
+     endif
+  enddo
+
+  psflavor ="Hamann's oncvpsp"
+
+  polarized = .false.
+  polattrib = "no"
+  there_is_core = (icmod >= 1)
+  if (there_is_core) then
+     coreattrib = "yes"
+  else
+     coreattrib = "no"
+  endif
+
+  ! XC name handling
+
+  select case(iexc)
+
+  case(1) 
+     xcfuntype    = 'LDA'
+     xcfunparam   = 'Wigner'
+     libxc_id = (/ XC_LDA_X, XC_LDA_C_WIGNER /)
+  case(2) 
+     xcfuntype    = 'LDA'
+     xcfunparam   = 'Hedin-Lundqvist'
+     libxc_id = (/ XC_LDA_X, XC_LDA_C_HL /)
+  case(3) 
+     xcfuntype    = 'LDA'
+     xcfunparam   = 'Ceperley-Alder PZ'
+     libxc_id = (/ XC_LDA_X, XC_LDA_C_PZ /)
+
+  case(4) 
+     xcfuntype    = 'GGA'
+     xcfunparam   = 'Perdew-Burke-Ernzerhof'
+     libxc_id = (/ XC_GGA_X_PBE, XC_GGA_C_PBE /) 
+
+  case(:-1)      ! libxc encoding -XXXCCC
+     xcfuntype    = 'libxc-family'
+     xcfunparam   = 'libxc-authors'
+     x_code = -iexc/1000
+     c_code = -iexc - 1000*x_code
+     ! We need a way to get the symbolic name from the code
+     ! ... and to cover the special case of EXCH_CORR functionals
+     libxc_id = (/ libxc_t("XC_???_X_???", x_code, EXCH), &
+                   libxc_t("XC_???_C_???", c_code, CORR) /) 
+     
+  case default
+
+     xcfuntype    = '-----'
+     xcfunparam   = '-----'
+     libxc_id = (/  XC_NOT_IMPL, XC_NOT_IMPL /)   ! ???
+
+  end select
+  !
+  !
+  call xml_NewElement(xf,"header")
+  call my_add_attribute(xf,"atomic-label",nameat)
+  call my_add_attribute(xf,"atomic-number",str(zz))
+  call my_add_attribute(xf,"z-pseudo",str(zion))
+  call my_add_attribute(xf,"flavor",psflavor)
+  if (srel) then
+     call my_add_attribute(xf,"relativity","scalar")
+  else
+     call my_add_attribute(xf,"relativity","no")
+  endif
+  call my_add_attribute(xf,"polarized",polattrib)
+  call my_add_attribute(xf,"core-corrections",coreattrib)
+
+          call xml_NewElement(xf,"exchange-correlation")
+          call xml_NewElement(xf,"annotation")
+          call my_add_attribute(xf,"oncvpsp-xc-code",str(iexc))
+          call my_add_attribute(xf,"oncvpsp-xc-type",trim(xcfuntype))
+          call my_add_attribute(xf,"oncvpsp-xc-authors",trim(xcfunparam))
+          call xml_EndElement(xf,"annotation")
+
+          call xml_NewElement(xf,"libxc-info")
+          call my_add_attribute(xf,"number-of-functionals","2")
+           do i = 1, 2
+              call xml_NewElement(xf,"functional")
+               call my_add_attribute(xf,"name",trim(libxc_id(i)%name))
+               call my_add_attribute(xf,"type",trim(libxc_id(i)%xc_kind%str))
+               call my_add_attribute(xf,"id",str(libxc_id(i)%code))
+              call xml_EndElement(xf,"functional")
+           enddo
+          call xml_EndElement(xf,"libxc-info")
+          call xml_EndElement(xf,"exchange-correlation")
+          !
+
+  !
+  call do_configuration()
+  call xml_EndElement(xf,"header")
+
+!AG: save
+   if(lloc==4) then
+       ! fitted local potential
+   else
+       ! 'l_local="',lloc,'"'
+   end if
+!AG -- decide how to handle the case of Vlocal as one of the sl pots.
+
+
+!AG: decide whether to use a single mesh (Hamann's own) or have the
+! projectors use another one (linear, shorter)
+
+ npts = mmax
+ nrl  = nrl0
+
+ r => rr(:)
+ chval => rho(:)
+ chcore => rhomod(:,1)
+
+  allocate(r0(nrl))
+  do  ii=1,nrl
+     r0(ii)=drl*dble(ii-1)
+  end do
+
+  call xml_NewElement(xf,"grid")
+  call my_add_attribute(xf,"npts",str(nrl))
+
+  call xml_NewElement(xf,"annotation")
+  call my_add_attribute(xf,"type","linear with r=0")
+  if (nrl_changed) then
+     call my_add_attribute(xf,"oncvpsp-suggested-nrl",str(nrl0))
+  endif
+  call my_add_attribute(xf,"oncvpsp-nrl",str(nrl))
+  call my_add_attribute(xf,"oncvpsp-drl",trim(str(drl)))
+  call xml_EndElement(xf,"annotation")
+
+  call xml_NewElement(xf,"grid-data")
+  call xml_AddArray(xf,r0(1:nrl))
+  call xml_EndElement(xf,"grid-data")
+
+  call xml_EndElement(xf,"grid")
+
+  call xml_NewElement(xf,"semilocal-potentials")
+  if (srel) then
+     call my_add_attribute(xf,"set","scalar_relativistic")
+  else
+     call my_add_attribute(xf,"set","non_relativistic")
+  endif
+  !  
+  allocate(f0(nrl))
+  vpsd: do i = 1, npots
+     vps => vpuns(:,i)
+     ! For linear grid:  (assuming r0 and nrl have been set earlier)
+     ! This call resamples vps onto r0, and extrapolates to r=0
+     ! In future we might select 'npoly' instead of using the hardwired
+     ! value of '7'.
+     call dpnint(r,vps,npts,r0,f0,nrl)
+     call write_psml_item(xf, class="slps", &
+                          n=nn(i), l=ll(i), &
+                          rc=rc(i),flavor=psflavor,&
+                          f=f0)
+  enddo vpsd
+  call xml_EndElement(xf,"semilocal-potentials")
+!
+!--------
+! Check that the range of the linear grid is appropriate to hold the orbitals
+! (and, by implication, the charge density) correctly
+
+  call get_new_nrl(nrl0,drl,mmax,rr,nv,uua,nrl,nrl_changed)
+
+  call xml_NewElement(xf,"valence-charge")
+  call my_add_attribute(xf,"total-charge",  &
+                      str(total_valence_charge))
+  call xml_NewElement(xf,"radfunc")
+
+  if (nrl_changed) then
+     deallocate(r0,f0)
+     allocate(r0(nrl),f0(nrl))
+     do  ii=1,nrl
+        r0(ii)=drl*dble(ii-1)
+     end do
+
+     call xml_NewElement(xf,"grid")
+     call my_add_attribute(xf,"npts",str(nrl))
+
+     call xml_NewElement(xf,"annotation")
+      call my_add_attribute(xf,"type","linear with r=0")
+      call my_add_attribute(xf,"oncvpsp-nrl-adjusted",str(nrl))
+      call my_add_attribute(xf,"oncvpsp-drl",trim(str(drl)))
+     call xml_EndElement(xf,"annotation")
+
+     call xml_NewElement(xf,"grid-data")
+     call xml_AddArray(xf,r0(1:nrl))
+     call xml_EndElement(xf,"grid-data")
+
+     call xml_EndElement(xf,"grid")
+  endif
+     
+  call xml_NewElement(xf,"data")
+  call dpnint(r,chval,npts,r0,f0,nrl)
+  call check_grid(r,chval,npts,r0,f0,nrl,"chval.check")
+  call xml_AddArray(xf,f0(1:nrl))
+  call xml_EndElement(xf,"data")
+  call xml_EndElement(xf,"radfunc")
+  call xml_EndElement(xf,"valence-charge")
+
+  if (nrl_changed) then
+     ! Go back to the standard grid
+     deallocate(r0,f0)
+     nrl = nrl0
+     allocate(r0(nrl),f0(nrl))
+     do  ii=1,nrl
+        r0(ii)=drl*dble(ii-1)
+     end do
+  endif
+
+  if (there_is_core) then
+     rcore = rr(irct)
+     call xml_NewElement(xf,"pseudocore-charge")
+     call my_add_attribute(xf,"matching-radius",str(rcore))
+     call my_add_attribute(xf,"number-of-continuous-derivatives", &
+                                    str(4))
+     call my_add_attribute(xf,"annotation",  &
+                  "Monotonic 7th-order polynomial with no linear term")
+     call xml_NewElement(xf,"radfunc")
+
+     call xml_NewElement(xf,"data")
+     call dpnint(r,chcore,npts,r0,f0,nrl)
+     call check_grid(r,chcore,npts,r0,f0,nrl,"chcore.check")
+     call xml_AddArray(xf,f0(1:nrl))
+     call xml_EndElement(xf,"data")
+     call xml_EndElement(xf,"radfunc")
+     call xml_EndElement(xf,"pseudocore-charge")
+     deallocate(chcore)
+  endif
+
+        vlocal => vpuns(:,lloc+1)
+        call xml_NewElement(xf,"local-potential")
+            if (lloc > lmax) then
+               call my_add_attribute(xf,"type","oncv-fit")
+            else
+               call my_add_attribute(xf,"type","l="//str(lloc))
+            endif
+            call xml_NewElement(xf,"radfunc")
+               call xml_NewElement(xf,"data")
+               call dpnint(r,vlocal,npts,r0,f0,nrl)
+               call check_grid(r,vlocal,npts,r0,f0,nrl,"vlocal.check")
+               call xml_AddArray(xf,f0(1:nrl))
+               call xml_EndElement(xf,"data")
+            call xml_EndElement(xf,"radfunc")
+        call xml_EndElement(xf,"local-potential")
+
+      call xml_NewElement(xf,"nonlocal-projectors")
+      if (srel) then
+         call my_add_attribute(xf,"set","scalar_relativistic")
+      else
+         call my_add_attribute(xf,"set","non_relativistic")
+      endif
+
+      do l1=1,lmax+1
+         if(l1==lloc+1) cycle
+         do jj=1,nproj(l1)
+            call dpnint(r,vkb(:,jj,l1),npts,r0,f0,nrl)
+            write(fname,"(a,i1,a,i1,a)") "vkb.", l1-1, ".", jj,".check"
+            call check_grid(r,vkb(:,jj,l1),npts,r0,f0,nrl,fname)
+            call write_psml_item(xf, class="proj", &
+                                 seq=jj, l=l1-1, &
+                                 ekb=evkb(jj,l1), &
+                                 type="oncv", f=f0)
+         enddo
+      enddo
+
+      call xml_EndElement(xf,"nonlocal-projectors")
+
+  call xml_EndElement(xf,"psml")
+
+
+  call xml_Close(xf)
+
+  deallocate(f0,r0)
+
+CONTAINS
+  subroutine do_configuration()
+
+  call xml_NewElement(xf,"valence-configuration")
+  call my_add_attribute(xf,"total-valence-charge", str(total_valence_charge))
+  do i = ncp, norbs
+     if (f(i) .lt. 1.0e-10_dp) cycle
+     call xml_NewElement(xf,"shell")
+     call my_add_attribute(xf,"n",str(n(i)))
+     call my_add_attribute(xf,"l",lsymb(l(i)))
+     call my_add_attribute(xf,"occupation",str(f(i)))
+     if (polarized) then
+        call my_add_attribute(xf,"occupation-down",str(fdown(i)))
+        call my_add_attribute(xf,"occupation-up",str(fup(i)))
+     endif
+     call xml_EndElement(xf,"shell")
+  enddo
+  call xml_EndElement(xf,"valence-configuration")
+end subroutine do_configuration
+
+end subroutine psmlout
+!
+!=================================================
+! Fully relativistic version
+!
+ subroutine psmlout_r(lmax,lloc,rc,vkb,evkb,nproj,rr,vpuns,rho,rhomod, &
+&                  irct, &
+&                  vsr,esr,vso,eso, &
+&                  zz,zion,mmax,iexc,icmod,nrl0,drl,atsym,epstot, &
+&                  na,la,ncon,nbas,nvcnf,nacnf,lacnf,nc,nv,lpopt,ncnf, &
+&                  fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
+&                  epsh1,epsh2,depsh,rlmax,psfile,uua)
+
+!lmax  maximum angular momentum
+!lloc  l for local potential
+!rc  core radii
+!vkb  VKB projectors
+!evkb  coefficients of VKB projectors
+!nproj  number of vkb projectors for each l
+!rr  log radial grid
+!vpuns  unscreened semi-local pseudopotentials (vp(:,5) is local potential 
+!  if linear combination is used)
+!rho  valence pseudocharge
+!rhomod  model core charge
+!zz  atomic number
+!zion  at this point, total valence charge (becomes pseudoion charge)
+!mmax  size of log radial grid
+!iexc  type of exchange-correlation
+!icmod  1 if model core charge is used, otherwise 0
+!nrl size of linear radial grid
+!drl spacing of linear radial grid
+!atsym  atomic symbol
+!epstot  pseudoatom total energy
+!psfile  should be 'upf' or 'psp8'
+!uua pseudo-atomic orbital array
+
+  ! Alberto Garcia, February 1, 2015
+
+  use xmlf90_wxml     ! To write XML files
+  use m_libxc_list  ! For ease of libxc handling
+  use m_uuid        ! To generate uuid
+
+ implicit none
+
+ real(dp), parameter :: pi=3.141592653589793238462643383279502884197_dp
+
+!Input variables
+ integer :: lmax,lloc,iexc,mmax,nrl0,icmod
+ integer :: nproj(6)
+ integer :: irct ! index of point at which rho_core is matched
+ real(dp) :: drl,fcfact,zz,zion,epstot
+ real(dp), target :: rr(mmax),vpuns(mmax,5,2),rho(mmax),vkb(mmax,2,4,2)
+ real(dp), target :: rhomod(mmax,5)
+ real(dp):: rc(6),evkb(2,4,2)
+ real(dp), target :: vsr(mmax,4,4),vso(mmax,4,4)
+ real(dp) :: esr(4,4),eso(4,4)
+ character*2 :: atsym
+
+!additional input for upf output to echo input file, all as defined
+! in the main progam
+ integer :: na(30),la(30),ncon(6),nbas(6)
+ integer :: nvcnf(5),nacnf(30,5),lacnf(30,5)
+ integer :: nc,nv,lpopt,ncnf
+ real(dp) :: fa(30),rc0(6),ep(6),qcut(6),debl(6),facnf(30,5)
+ real(dp) :: dvloc0,epsh1,epsh2,depsh,rlmax
+ character*4 :: psfile
+ real(dp) :: uua(mmax,nv)
+
+
+!Local variables
+ integer :: dtime(8), nrl
+ logical :: nrl_changed
+ integer :: npr_so(4), npr_sr(4)
+
+  type(xmlf_t) :: xf
+  type(libxc_t) :: libxc_id(2)
+
+  integer   :: i, j, npts
+  integer   :: ii, jj, l1, jk
+  real(dp)  :: rcore, jval
+  real(dp)  :: total_valence_charge
+  real(dp), pointer :: r(:), chval(:), chcore(:)
+  real(dp), pointer :: vlocal(:)
+  real(dp), allocatable :: r0(:), f0(:), vps(:)
+
+  character(len=100)    :: line
+  character*4      :: polattrib, coreattrib
+  character*1      :: pscode, char_dummy
+  character(len=2) :: nameat
+  character(len=40):: psflavor
+
+  character(len=1), dimension(0:4) :: lsymb = (/'s','p','d','f','g'/)
+
+  character*30 xcfuntype, xcfunparam
+  integer :: x_code, c_code
+  integer          :: ncore, nval, ncp, norbs, npots
+
+  integer, allocatable  :: n(:), l(:)
+  integer, allocatable  :: nn(:), ll(:)
+  real(dp), allocatable :: f(:), ff(:)
+  real(dp), allocatable :: fdown(:), fup(:)
+  character(len=10)     :: datestr
+
+  logical :: tdopsp, nonrel, polarized, there_is_core, found
+  integer :: lun, stat
+
+!---
+
+ call date_and_time(VALUES=dtime)
+ write(datestr,"(i4,'-',i2.2,'-',i2.2)") dtime(1:3)
+
+  call xml_OpenFile("ONCVPSPPSML",xf, indent=.false.)
+
+  call xml_AddXMLDeclaration(xf,"UTF-8")
+
+  call xml_NewElement(xf,"psml")
+  call my_add_attribute(xf,"version","0.9")
+  call my_add_attribute(xf,"energy_unit","hartree")
+  call my_add_attribute(xf,"length_unit","bohr")
+  call my_add_attribute(xf,"uuid",generate_uuid(version=1))
+
+  call xml_NewElement(xf,"provenance")
+  call my_add_attribute(xf,"creator","ONCVPSP-3.2.2+psml")
+  call my_add_attribute(xf,"date",datestr)
+  call xml_NewElement(xf,"input-file")
+  call my_add_attribute(xf,"name","oncvpsp-input")
+!
+!    Use INP_COPY (generated in the main program)
+!                                                                                               
+  call cdata_section_from_file(xf,"INP_COPY")
+  call xml_EndElement(xf,"input-file")
+  !
+  call xml_EndElement(xf,"provenance")
+
+!  nameat = symbol(nint(zz))
+  nameat = atsym
+  ncore  = nc
+  nval   = nv
+
+  norbs = ncore + nval
+  allocate (n(norbs), l(norbs), f(norbs))
+
+  total_valence_charge = 0.0_dp
+  ncp = ncore + 1
+  do i = 1, norbs
+     n(i) = na(i)
+     l(i) = la(i)
+     f(i) = fa(i)
+     if (i > ncore) then
+        total_valence_charge =   total_valence_charge + f(i)
+     endif
+  enddo
+  lmax = lmax
+
+  npots = lmax + 1
+  allocate (ll(npots), nn(npots), ff(npots))
+  do i = 1, npots
+     ll(i) = i - 1
+     found = .false.
+     ! look for the appropriate shell in the valence
+     do j = ncp, norbs
+        if (l(j) == ll(i)) then
+           found = .true.
+           nn(i) = n(j)
+           ff(i) = f(j)
+           exit
+        endif
+     enddo
+     if (.not. found) then
+        ! generate the appropriate effective n
+        nn(i) = ll(i) + 1
+        do j = 1, ncore
+           if (l(j) == ll(i)) then
+              nn(i) = nn(i) + 1
+           endif
+           ff(i) = 0.0_dp
+        enddo
+     endif
+  enddo
+
+  psflavor ="Hamann's oncvpsp"
+
+  polarized = .false.
+  polattrib = "no"
+  there_is_core = (icmod >= 1)
+  if (there_is_core) then
+     coreattrib = "yes"
+  else
+     coreattrib = "no"
+  endif
+
+  ! XC name handling
+
+  select case(iexc)
+
+  case(1) 
+     xcfuntype    = 'LDA'
+     xcfunparam   = 'Wigner'
+     libxc_id = (/ XC_LDA_X, XC_LDA_C_WIGNER /)
+  case(2) 
+     xcfuntype    = 'LDA'
+     xcfunparam   = 'Hedin-Lundqvist'
+     libxc_id = (/ XC_LDA_X, XC_LDA_C_HL /)
+  case(3) 
+     xcfuntype    = 'LDA'
+     xcfunparam   = 'Ceperley-Alder PZ'
+     libxc_id = (/ XC_LDA_X, XC_LDA_C_PZ /)
+
+  case(4) 
+     xcfuntype    = 'GGA'
+     xcfunparam   = 'Perdew-Burke-Ernzerhof'
+     libxc_id = (/ XC_GGA_X_PBE, XC_GGA_C_PBE /) 
+
+  case(:-1)      ! libxc encoding -XXXCCC
+     xcfuntype    = 'libxc-family'
+     xcfunparam   = 'libxc-authors'
+     x_code = -iexc/1000
+     c_code = -iexc - 1000*x_code
+     ! We need a way to get the symbolic name from the code
+     ! ... and to cover the special case of EXCH_CORR functionals
+     libxc_id = (/ libxc_t("XC_???_X_???", x_code, EXCH), &
+                   libxc_t("XC_???_C_???", c_code, CORR) /) 
+     
+  case  default
+
+     xcfuntype    = '-----'
+     xcfunparam   = '-----'
+     libxc_id = (/  XC_NOT_IMPL, XC_NOT_IMPL /)   ! ???
+
+  end select
+  !
+  !
+  call xml_NewElement(xf,"header")
+  call my_add_attribute(xf,"atomic-label",nameat)
+  call my_add_attribute(xf,"atomic-number",str(zz))
+  call my_add_attribute(xf,"z-pseudo",str(zion))
+  call my_add_attribute(xf,"flavor",psflavor)
+  call my_add_attribute(xf,"relativity","dirac")
+  call my_add_attribute(xf,"polarized",polattrib)
+  call my_add_attribute(xf,"core-corrections",coreattrib)
+
+          call xml_NewElement(xf,"exchange-correlation")
+          call xml_NewElement(xf,"annotation")
+          call my_add_attribute(xf,"oncvpsp-xc-code",str(iexc))
+          call my_add_attribute(xf,"oncvpsp-xc-type",trim(xcfuntype))
+          call my_add_attribute(xf,"oncvpsp-xc-authors",trim(xcfunparam))
+          call xml_EndElement(xf,"annotation")
+
+          call xml_NewElement(xf,"libxc-info")
+          call my_add_attribute(xf,"number-of-functionals","2")
+           do i = 1, 2
+              call xml_NewElement(xf,"functional")
+               call my_add_attribute(xf,"name",trim(libxc_id(i)%name))
+               call my_add_attribute(xf,"type",trim(libxc_id(i)%xc_kind%str))
+               call my_add_attribute(xf,"id",str(libxc_id(i)%code))
+              call xml_EndElement(xf,"functional")
+           enddo
+          call xml_EndElement(xf,"libxc-info")
+          call xml_EndElement(xf,"exchange-correlation")
+          !
+
+  !
+  call do_configuration()
+  call xml_EndElement(xf,"header")
+
+!AG: save
+   if(lloc==4) then
+       ! fitted local potential
+   else
+       ! 'l_local="',lloc,'"'
+   end if
+!AG -- decide how to handle the case of Vlocal as one of the sl pots.
+
+
+!AG: decide whether to use a single mesh (Hamann's own) or have the
+! projectors use another one (linear, shorter)
+
+ npts = mmax
+ nrl  = nrl0
+
+ r => rr(:)
+ chval => rho(:)
+ chcore => rhomod(:,1)
+ allocate(vps(npts))
+
+  allocate(r0(nrl))
+  do  ii=1,nrl
+     r0(ii)=drl*dble(ii-1)
+  end do
+
+  call xml_NewElement(xf,"grid")
+  call my_add_attribute(xf,"npts",str(nrl))
+
+  call xml_NewElement(xf,"annotation")
+  call my_add_attribute(xf,"type","linear with r=0")
+  if (nrl_changed) then
+     call my_add_attribute(xf,"oncvpsp-suggested-nrl",str(nrl0))
+  endif
+  call my_add_attribute(xf,"oncvpsp-nrl",str(nrl))
+  call my_add_attribute(xf,"oncvpsp-drl",trim(str(drl)))
+  call xml_EndElement(xf,"annotation")
+
+  call xml_NewElement(xf,"grid-data")
+  call xml_AddArray(xf,r0(1:nrl))
+  call xml_EndElement(xf,"grid-data")
+
+  call xml_EndElement(xf,"grid")
+
+  !  
+  ! Semilocal potentials
+  !
+  allocate(f0(nrl))
+
+  if (trim(psfile)=="psp8") then
+
+     call xml_NewElement(xf,"semilocal-potentials")
+     call my_add_attribute(xf,"set","scalar_relativistic")
+! sr components
+    do i = 1, npots
+     l1 = i
+     ! last index:  1: j=l+1/2; 2: j=l-1/2; l=0,j=0 stored in index 1
+     vps(:) = ((ll(i)+1)*vpuns(:,l1,1)+ ll(i)*vpuns(:,l1,2)) / dble(2*ll(i)+1)
+     call dpnint(r,vps,npts,r0,f0,nrl)
+     call write_psml_item(xf, class="slps", &
+                          n=nn(i), l=ll(i), &
+                          rc=rc(i),flavor=psflavor,&
+                          f=f0)
+  enddo
+  call xml_EndElement(xf,"semilocal-potentials")
+!
+! so components
+!
+  call xml_NewElement(xf,"semilocal-potentials")
+   call my_add_attribute(xf,"set","spin_orbit")
+
+ do i = 2, npots
+     l1 = i
+     vps(:) = 2*(vpuns(:,l1,1) - vpuns(:,l1,2)) / dble(2*ll(i)+1)
+     call dpnint(r,vps,npts,r0,f0,nrl)
+     call write_psml_item(xf, class="slps", &
+                          n=nn(i), l=ll(i), &
+                          rc=rc(i),flavor=psflavor,&
+                          f=f0)
+  enddo
+
+  call xml_EndElement(xf,"semilocal-potentials")
+
+  else   ! upf
+
+     call xml_NewElement(xf,"semilocal-potentials")
+     call my_add_attribute(xf,"set","lj")
+
+     do i = 1, npots
+        l1 = i
+        if (i == 1) then
+           jval = 0.0
+           ! last index:  1: j=l+1/2; 2: j=l-1/2; l=0,j=0 stored in index 1
+           vps(:) = vpuns(:,l1,1)
+           call dpnint(r,vps,npts,r0,f0,nrl)
+           call write_psml_item(xf, class="slps", &
+                          n=nn(i), l=ll(i), j=jval, &
+                          rc=rc(i),flavor=psflavor,&
+                          f=f0)
+        else
+           do jj=1,2
+              jval = ll(i) + (3-2*jj)*0.5  ! convert (1,2) to (1,-1)*1/2
+              ! last index:  1: j=l+1/2; 2: j=l-1/2; l=0,j=0 stored in index 1
+              vps(:) = vpuns(:,l1,jj)
+              call dpnint(r,vps,npts,r0,f0,nrl)
+              call write_psml_item(xf, class="slps", &
+                          n=nn(i), l=ll(i), j=jval, &
+                          rc=rc(i),flavor=psflavor,&
+                          f=f0)
+           enddo
+        endif
+     enddo
+     call xml_EndElement(xf,"semilocal-potentials")
+
+  endif ! upf vs psp8
+!
+!--------
+! Check that the range of the linear grid is appropriate to hold the orbitals
+! (and, by implication, the charge density) correctly
+
+  call get_new_nrl(nrl0,drl,mmax,rr,nv,uua,nrl,nrl_changed)
+
+  call xml_NewElement(xf,"valence-charge")
+  call my_add_attribute(xf,"total-charge",  &
+                      str(total_valence_charge))
+  call xml_NewElement(xf,"radfunc")
+
+  if (nrl_changed) then
+     deallocate(r0,f0)
+     allocate(r0(nrl),f0(nrl))
+     do  ii=1,nrl
+        r0(ii)=drl*dble(ii-1)
+     end do
+
+     call xml_NewElement(xf,"grid")
+     call my_add_attribute(xf,"npts",str(nrl))
+
+     call xml_NewElement(xf,"annotation")
+      call my_add_attribute(xf,"type","linear with r=0")
+      call my_add_attribute(xf,"oncvpsp-nrl-adjusted",str(nrl))
+      call my_add_attribute(xf,"oncvpsp-drl",trim(str(drl)))
+     call xml_EndElement(xf,"annotation")
+
+     call xml_NewElement(xf,"grid-data")
+     call xml_AddArray(xf,r0(1:nrl))
+     call xml_EndElement(xf,"grid-data")
+
+     call xml_EndElement(xf,"grid")
+  endif
+     
+  call xml_NewElement(xf,"data")
+  call dpnint(r,chval,npts,r0,f0,nrl)
+  call check_grid(r,chval,npts,r0,f0,nrl,"chval.check")
+  call xml_AddArray(xf,f0(1:nrl))
+  call xml_EndElement(xf,"data")
+  call xml_EndElement(xf,"radfunc")
+  call xml_EndElement(xf,"valence-charge")
+
+  if (nrl_changed) then
+     ! Go back to the standard grid
+     deallocate(r0,f0)
+     nrl = nrl0
+     allocate(r0(nrl),f0(nrl))
+     do  ii=1,nrl
+        r0(ii)=drl*dble(ii-1)
+     end do
+  endif
+
+  if (there_is_core) then
+     rcore = rr(irct)
+     call xml_NewElement(xf,"pseudocore-charge")
+     call my_add_attribute(xf,"matching-radius",str(rcore))
+     call my_add_attribute(xf,"number-of-continuous-derivatives", &
+                                    str(4))
+     call my_add_attribute(xf,"annotation",  &
+                  "Monotonic 7th-order polynomial with no linear term")
+     call xml_NewElement(xf,"radfunc")
+
+     call xml_NewElement(xf,"data")
+     call dpnint(r,chcore,npts,r0,f0,nrl)
+     call check_grid(r,chcore,npts,r0,f0,nrl,"chcore.check")
+     call xml_AddArray(xf,f0(1:nrl))
+     call xml_EndElement(xf,"data")
+     call xml_EndElement(xf,"radfunc")
+     call xml_EndElement(xf,"pseudocore-charge")
+     deallocate(chcore)
+  endif
+
+
+        vlocal => vpuns(:,lloc+1,1)
+        call xml_NewElement(xf,"local-potential")
+            if (lloc > lmax) then
+               call my_add_attribute(xf,"type","oncv-fit")
+            else
+               call my_add_attribute(xf,"type","l="//str(lloc))
+            endif
+            call xml_NewElement(xf,"radfunc")
+               call xml_NewElement(xf,"data")
+               call dpnint(r,vlocal,npts,r0,f0,nrl)
+               call check_grid(r,vlocal,npts,r0,f0,nrl,"vlocal.check")
+               call xml_AddArray(xf,f0(1:nrl))
+               call xml_EndElement(xf,"data")
+            call xml_EndElement(xf,"radfunc")
+        call xml_EndElement(xf,"local-potential")
+
+!
+!     Scalar-relativistic projectors
+!
+  if (trim(psfile)=="psp8") then
+
+! set up projector number for sr_so calculations based on non-zero coefficients
+  npr_sr(:)=0 
+  npr_so(:)=0
+  do l1=1,lmax+1
+   do ii=1,4
+    if(abs(esr(ii,l1))>0.0d0) npr_sr(l1)=npr_sr(l1)+1
+    if(abs(eso(ii,l1))>0.0d0) npr_so(l1)=npr_so(l1)+1
+   end do
+  end do
+
+      call xml_NewElement(xf,"nonlocal-projectors")
+      call my_add_attribute(xf,"set","scalar_relativistic")
+ 
+      do l1=1,lmax+1
+         if(l1==lloc+1) cycle
+         do jj=1,npr_sr(l1)
+            call dpnint(r,vsr(:,jj,l1),npts,r0,f0,nrl)
+            call write_psml_item(xf, class="proj", &
+                                 seq=jj, l=l1-1, &
+                                 ekb=esr(jj,l1), &
+                                 type="oncv", f=f0)
+         enddo
+      enddo
+      call xml_EndElement(xf,"projectors")
+!
+!     Spin-orbit part
+!
+      call xml_NewElement(xf,"projectors")
+      call my_add_attribute(xf,"set","spin_orbit")
+
+      do l1=2,lmax+1
+         if(l1==lloc+1) cycle
+         do jj=1,npr_so(l1)
+            call dpnint(r,vso(:,jj,l1),npts,r0,f0,nrl)
+            call write_psml_item(xf, class="proj", &
+                                 seq=jj, l=l1-1, &
+                                 ekb=eso(jj,l1), &
+                                 type="oncv", f=f0)
+         enddo
+      enddo
+
+      call xml_EndElement(xf,"nonlocal-projectors")
+
+ else  ! upf
+
+      call xml_NewElement(xf,"nonlocal-projectors")
+      call my_add_attribute(xf,"set","lj")
+ 
+      do l1=1,lmax+1
+         if(l1==lloc+1) cycle
+
+         if (l1 == 1) then
+            ! l=0, only one j=0
+            jval = 0.0
+
+            do jj=1,nproj(l1)
+               call dpnint(r,vkb(:,jj,l1,1),npts,r0,f0,nrl)
+               call write_psml_item(xf, class="proj", &
+                                 seq=jj, l=l1-1, j=jval, &
+                                 ekb=evkb(jj,l1,1), &
+                                 type="oncv", f=f0)
+            enddo
+
+         else  ! l1 /=1  (l/=0)
+
+           ! two j values
+           do jk=1,2
+              jval = l1-1 + (3-2*jk)*0.5  ! convert (1,2) to (1,-1)*1/2
+              do jj=1,nproj(l1)
+                 call dpnint(r,vkb(:,jj,l1,jk),npts,r0,f0,nrl)
+                 call write_psml_item(xf, class="proj", &
+                                 seq=jj, l=l1-1, j=jval, &
+                                 ekb=evkb(jj,l1,jk), &
+                                 type="oncv", f=f0)
+              enddo
+           enddo
+
+        endif  ! l1 == 1
+
+      enddo ! over l shells
+      call xml_EndElement(xf,"nonlocal-projectors")
+!
+   endif ! upf vs psp8
+
+  call xml_EndElement(xf,"psml")
+
+
+  call xml_Close(xf)
+
+  deallocate(f0,r0)
+
+CONTAINS
+  subroutine do_configuration()
+
+  call xml_NewElement(xf,"valence-configuration")
+  call my_add_attribute(xf,"total-valence-charge", str(total_valence_charge))
+  do i = ncp, norbs
+     if (f(i) .lt. 1.0e-10_dp) cycle
+     call xml_NewElement(xf,"shell")
+     call my_add_attribute(xf,"n",str(n(i)))
+     call my_add_attribute(xf,"l",lsymb(l(i)))
+     call my_add_attribute(xf,"occupation",str(f(i)))
+     if (polarized) then
+        call my_add_attribute(xf,"occupation-down",str(fdown(i)))
+        call my_add_attribute(xf,"occupation-up",str(fup(i)))
+     endif
+     call xml_EndElement(xf,"shell")
+  enddo
+  call xml_EndElement(xf,"valence-configuration")
+end subroutine do_configuration
+
+
+end subroutine psmlout_r
+
+     subroutine my_add_attribute(xf,name,value)
+       use xmlf90_wxml, only: xmlf_t, xml_AddAttribute
+
+       type(xmlf_t), intent(inout)   :: xf
+       character(len=*), intent(in)  :: name
+       character(len=*), intent(in)  :: value
+
+       call xml_AddAttribute(xf,name,trim(value))
+     end subroutine my_add_attribute
+
+    subroutine get_unit(lun)
+
+!     Get an available Fortran unit number
+
+      integer, intent(out) ::  lun
+
+      integer i
+      logical unit_used
+
+      do i = 10, 99
+         lun = i
+         inquire(lun,opened=unit_used)
+         if (.not. unit_used) return
+      enddo
+      stop 'NO LUNS'
+    end subroutine get_unit
+
+    subroutine write_psml_item(xf,class, &
+                               n, l, j, s, &
+                               seq, &
+                               rc, ekb, &
+                               flavor, type, set, &
+                               f)
+
+       use xmlf90_wxml
+
+
+       type(xmlf_t), intent(inout)   :: xf
+       character(len=*), intent(in)  :: class
+
+       integer, intent(in), optional  :: n
+       integer, intent(in), optional  :: l
+       real(dp), intent(in), optional  :: j
+       real(dp), intent(in), optional  :: s
+
+       ! for sl potentials
+       real(dp), intent(in), optional  :: rc
+       character(len=*), intent(in), optional  :: flavor
+
+       ! for projectors
+       integer, intent(in), optional   :: seq
+       real(dp), intent(in), optional  :: ekb
+       character(len=*), intent(in), optional  :: type
+
+       character(len=*), intent(in), optional  :: set
+       real(dp), intent(in), optional  :: f(:)
+       
+       call xml_NewElement(xf,trim(class))
+         if (present(set))  call my_add_attribute(xf,"set",set)
+
+         ! we might want to check input values
+         if (present(n))  call my_add_attribute(xf,"n",str(n))
+         if (present(l))  call my_add_attribute(xf,"l",lsymb(l))
+         if (present(j))  call my_add_attribute(xf,"j", &
+                                                str(j,format="(f3.1)"))
+         ! spin: +0.5 or -0.5
+         if (present(s))  call my_add_attribute(xf,"s", &
+                                                str(s,format="(f4.1)"))
+
+         if (present(seq)) call my_add_attribute(xf,"seq",str(seq))
+
+         if (present(rc))  call my_add_attribute(xf,"rc",str(rc))
+         if (present(ekb))  call my_add_attribute(xf,"ekb",str(ekb))
+
+         if (present(flavor))  call my_add_attribute(xf,"flavor",flavor)
+         if (present(type))  call my_add_attribute(xf,"type",type)
+
+         call xml_NewElement(xf,"radfunc")
+           call xml_NewElement(xf,"data")
+           call xml_AddArray(xf,f(:))
+           call xml_EndElement(xf,"data")
+         call xml_EndElement(xf,"radfunc")
+
+       call xml_EndElement(xf,trim(class))
+
+     end subroutine write_psml_item
+
+     subroutine check_grid(r1,v1,n1,rg,vg,ng,fname)
+       integer, intent(in) :: n1, ng
+       real(dp), intent(in), dimension(n1) :: r1, v1
+       real(dp), intent(in), dimension(ng) :: rg, vg
+       character(len=*), intent(in) :: fname
+
+       integer  :: i
+       real(dp) :: v2
+       
+       open(unit=77,file=trim(fname),form="formatted", &
+            status="unknown",action="write",position="rewind")
+       do i = 1, n1
+          if (r1(i) > rg(ng)) exit
+          call dpnint1(7,rg,vg,ng,r1(i),v2,.false.)
+          write(77,"(3es24.16)") r1(i), v1(i), v2
+       end do
+     end subroutine check_grid
+!
+! Copyright (c) 1989-2014 by D. R. Hamann, Mat-Sim Research LLC and Rutgers
+! University
+! 
+! Modified by Alberto Garcia, March 2015
+! This routine is included in this module with permission from D.R. Hamann.
+!
+ subroutine dpnint1(npoly, xx, yy, nn, r, val, debug)
+
+! Modified by Alberto Garcia, March 2015 from routine
+! dpnint by D.R. Hamann. 
+! Changes:
+!   -- A single value is returned
+!   -- It can extrapolate, instead of stopping,
+!      when called with an abscissa outside the
+!      data range.
+!   -- If the number of data points is less than
+!      npoly+1, npoly is implicitly reduced, without
+!      error, and without warning.
+!   -- Debug interface 
+!
+! local polynomial interpolation of data yy on nn points xx
+! giving value val on point r
+! npoly sets order of polynomial
+! xx must be ordered in ascending order
+! output interpolated value val on point r
+
+ implicit none
+
+ integer, parameter :: dp=kind(1.0d0)
+
+!Input variables
+ real(dp), intent(in) :: xx(*),yy(*)
+ real(dp), intent(in) :: r
+ real(dp), intent(out) :: val
+ integer, intent(in)   ::  nn,npoly
+ logical, intent(in)   ::  debug
+
+!Local variables
+ real(dp) :: sum,term,zz
+ integer ii,imin,imax,iprod,iy,istart,kk,iend
+
+! interval halving search for xx(ii) points bracketing r
+
+   imin = 1
+   imax = nn
+   do kk = 1, nn
+     ii = (imin + imax) / 2
+     if(r>xx(ii)) then
+       imin = ii
+     else
+       imax = ii
+     end if
+     if(imax - imin .eq. 1) then
+       exit
+     end if
+   end do
+
+
+   zz=r
+
+!   if (debug) print *, "imin, imax: ", imin, imax
+
+   if(mod(npoly,2)==1) then
+    istart=imin-npoly/2
+   else if(zz-xx(imin) < xx(imax)-zz) then
+     istart=imin-npoly/2
+   else
+     istart=imax-npoly/2
+   end if
+
+   istart = min(istart, nn - npoly)
+   istart = max(istart, 1)
+   iend = min(istart+npoly,nn)
+
+ !  if (debug) print *, "istart, iend: ", istart, iend
+   sum=0.0d0
+   do iy=istart,iend
+    if(yy(iy)==0.0d0) cycle
+    term=yy(iy)
+    do iprod=istart, iend
+     if(iprod==iy) cycle
+     term=term*(zz-xx(iprod))/(xx(iy)-xx(iprod))
+    end do
+    sum=sum+term
+   end do
+   val=sum
+
+ end subroutine dpnint1
+
+ subroutine get_new_nrl(nrl,drl,mmax,rr,nv,uua,nrl_new,nrl_changed)
+   integer, intent(in)  :: nrl, mmax, nv
+   real(dp), intent(in) :: drl, rr(mmax), uua(mmax,nv)
+   integer, intent(out) :: nrl_new
+   logical, intent(out) :: nrl_changed
+
+   real(dp) :: al, uurcut, nrmsum
+   integer  :: ii, jj
+
+! adjust nrl to properly accomodate atomic orbitals
+ nrl_changed = .false.
+ al = dlog(rr(2)/rr(1))
+ uurcut = 0.d0
+ do ii=1,nv
+   nrmsum = 0.d0
+   do jj=mmax,1,-1
+     nrmsum = nrmsum + (uua(jj,ii)**2) * rr(jj)*al
+     if (nrmsum > 1.d-6) then
+       exit  ! Cutoff radius such that uu norm accurate to 10^-6
+     end if
+   end do
+   if (rr(jj) > uurcut) uurcut = rr(jj)  
+ end do
+ if (uurcut > drl*dble(nrl-1)) then
+   nrl_changed = .true.
+   nrl_new = 1 + uurcut/drl
+ end if
+end subroutine get_new_nrl
+
+subroutine copy_input_file_for_psml()
+! Makes two copies of the input file: one for oncvpsp
+! to read, and another to echo the input in the PSML file
+
+      character(len=132) :: line
+      integer            :: stat
+
+      open(unit=55,file='INPUT_FILE',action='write',status='replace', &
+           form='formatted')
+      open(unit=66,file='INP_COPY',action='write',status='replace', &
+           form='formatted')
+      do
+         read(5,fmt="(a)",iostat=stat) line
+         if (stat .ne. 0) exit
+         write(55,fmt="(a)") trim(line)
+         write(66,fmt="(a)") trim(line)
+      enddo
+      close(5)
+      close(55)
+      close(66)
+
+!  Now re-open INPUT_FILE as unit 5 for further processing
+!  by oncvpsp
+      
+      open(unit=5,file='INPUT_FILE',action='read',status='old', &
+           form='formatted',position='rewind')
+      
+end subroutine copy_input_file_for_psml
+
+subroutine cdata_section_from_file(xf,filename)
+  use xmlf90_wxml
+
+  type(xmlf_t), intent(inout)   :: xf
+  character(len=*), intent(in) :: filename
+
+  integer :: stat
+  character(len=512) :: line
+  character(len=1)   :: nl = char(10)
+  
+  character(len=32000) :: buffer ! to accumulate characters
+  
+      open(44,file=trim(filename),form="formatted",status="old", &
+           position="rewind",action="read")
+      buffer = ""
+      do
+         read(44,fmt="(a)",iostat=stat) line
+         if (stat .ne. 0) exit
+         buffer = trim(buffer) // trim(line) // nl
+      enddo
+      close(44)
+      
+      call xml_AddCDATASection(xf,trim(buffer),line_feed=.true.)
+!                                                                     
+    end subroutine cdata_section_from_file
+end module m_psmlout
diff -Naur oncvpsp-3.2.2/src/m_uuid.f90 oncvpsp-3.2.2--psml-42/src/m_uuid.f90
--- oncvpsp-3.2.2/src/m_uuid.f90	1970-01-01 01:00:00.000000000 +0100
+++ oncvpsp-3.2.2--psml-42/src/m_uuid.f90	2016-06-30 16:57:17.000000000 +0200
@@ -0,0 +1,607 @@
+module mtprng
+
+!---------------------------------------------------------------------
+! From the Algorithmic Conjurings of Scott Robert Ladd comes...
+!---------------------------------------------------------------------
+!
+!  mtprng.f90 (a Fortran 95 module)
+!
+!  An implementation of the Mersenne Twister algorithm for generating
+!  psuedo-random sequences.
+!
+!  History
+!  -------
+!   1.0.0   Initial release
+!
+!   1.1.0   6 February 2002
+!           Updated to support algorithm revisions posted
+!           by Matsumoto and Nishimura on 26 January 2002
+!
+!   1.5.0   12 December 2003
+!           Added to hypatia project
+!           Minor style changes
+!           Tightened code
+!           Now state based; no static variables
+!           Removed mtprng_rand_real53
+!
+!   2.0.0   4 January 2004
+!           Corrected erroneous unsigned bit manipulations
+!           Doubled resolution by using 64-bit math
+!           Added mtprng_rand64
+
+!  Version for distribution with FoX <http://uszla.me.uk/FoX>
+!  Very small cosmetic changes to fit FoX naming scheme and
+!  avoid additional dependencies.
+!  Toby White <tow@uszla.me.uk>, 2007
+
+!
+!  ORIGINAL ALGORITHM COPYRIGHT
+!  ============================
+!  Copyright (C) 1997,2002 Makoto Matsumoto and Takuji Nishimura.
+!  Any feedback is very welcome. For any question, comments, see
+!  http://www.math.keio.ac.jp/matumoto/emt.html or email
+!  matumoto@math.keio.ac.jp
+!---------------------------------------------------------------------
+!
+!  COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
+!
+!  This notice applies *only* to this specific expression of this
+!  algorithm, and does not imply ownership or invention of the
+!  implemented algorithm.
+!  
+!  If you modify this file, you may insert additional notices
+!  immediately following this sentence.
+!  
+!  Copyright 2001, 2002, 2004 Scott Robert Ladd.
+!  All rights reserved, except as noted herein.
+!
+!  This computer program source file is supplied "AS IS". Scott Robert
+!  Ladd (hereinafter referred to as "Author") disclaims all warranties,
+!  expressed or implied, including, without limitation, the warranties
+!  of merchantability and of fitness for any purpose. The Author
+!  assumes no liability for direct, indirect, incidental, special,
+!  exemplary, or consequential damages, which may result from the use
+!  of this software, even if advised of the possibility of such damage.
+!  
+!  The Author hereby grants anyone permission to use, copy, modify, and
+!  distribute this source code, or portions hereof, for any purpose,
+!  without fee, subject to the following restrictions:
+!  
+!      1. The origin of this source code must not be misrepresented.
+!  
+!      2. Altered versions must be plainly marked as such and must not
+!         be misrepresented as being the original source.
+!  
+!      3. This Copyright notice may not be removed or altered from any
+!         source or altered source distribution.
+!  
+!  The Author specifically permits (without fee) and encourages the use
+!  of this source code for entertainment, education, or decoration. If
+!  you use this source code in a product, acknowledgment is not required
+!  but would be appreciated.
+!  
+!  Acknowledgement:
+!      This license is based on the wonderful simple license that
+!      accompanies libpng.
+!
+!-----------------------------------------------------------------------
+!
+!  For more information on this software package, please visit
+!  Scott's web site, Coyote Gulch Productions, at:
+!
+!      http://www.coyotegulch.com
+!  
+!-----------------------------------------------------------------------
+
+    implicit none
+
+    ! Kind types for 64-, 32-, 16-, and 8-bit signed integers
+    integer, parameter :: INT64 = selected_int_kind(18)
+    integer, parameter :: INT32 = selected_int_kind(9)
+    integer, parameter :: INT16 = selected_int_kind(4)
+    integer, parameter :: INT08 = selected_int_kind(2)
+
+    ! Kind types for IEEE 754/IEC 60559 single- and double-precision reals
+    integer, parameter :: IEEE32 = selected_real_kind(  6,  37 )
+    integer, parameter :: IEEE64 = selected_real_kind( 15, 307 )
+
+    !------------------------------------------------------------------------------
+    ! Everything is private unless explicitly made public
+    private
+
+    public :: mtprng_state, &
+              mtprng_init, mtprng_init_by_array, &
+              mtprng_rand64, mtprng_rand, mtprng_rand_range, &
+              mtprng_rand_real1, mtprng_rand_real2, mtprng_rand_real3
+
+    !------------------------------------------------------------------------------
+    ! Constants
+    integer(INT32), parameter :: N = 624_INT32
+    integer(INT32), parameter :: M = 397_INT32
+
+    !------------------------------------------------------------------------------
+    ! types
+    type mtprng_state
+        integer(INT32)                   :: mti = -1
+        integer(INT64), dimension(0:N-1) :: mt
+    end type 
+
+contains
+    !--------------------------------------------------------------------------
+    !  Initializes the generator with "seed"
+    subroutine mtprng_init(seed, state)
+    
+        ! arguments
+        integer(INT32),     intent(in)  :: seed
+        type(mtprng_state), intent(out) :: state
+        
+        ! working storage
+        integer :: i
+
+        ! save seed        
+        state%mt(0) = seed
+        
+        ! Set the seed using values suggested by Matsumoto & Nishimura, using
+        !   a generator by Knuth. See original source for details.
+        do i = 1, N - 1
+            state%mt(i) = iand(4294967295_INT64,1812433253_INT64 * ieor(state%mt(i-1),ishft(state%mt(i-1),-30_INT64)) + i)
+        end do
+        
+        state%mti = N
+
+    end subroutine mtprng_init
+    
+    !--------------------------------------------------------------------------
+    ! Initialize with an array of seeds
+    subroutine mtprng_init_by_array(init_key, state)
+    
+        ! arguments
+        integer(INT32), dimension(:), intent(in) :: init_key
+        type(mtprng_state), intent(out) :: state
+        
+        ! working storage
+        integer :: key_length
+        integer :: i
+        integer :: j
+        integer :: k
+        
+        call mtprng_init(19650218_INT32,state)
+        
+        i = 1
+        j = 0
+        key_length = size(init_key)
+        
+        do k = max(N,key_length), 0, -1
+            state%mt(i) = ieor(state%mt(i),(ieor(state%mt(i-1),ishft(state%mt(i-1),-30_INT64) * 1664525_INT64))) + init_key(j) + j
+            
+            i = i + 1
+            j = j + 1
+            
+            if (i >= N) then
+                state%mt(0) = state%mt(N-1)
+                i = 1
+            end if
+            
+            if (j >= key_length) j = 0
+        end do
+        
+        do k = N-1, 0, -1
+            state%mt(i) = ieor(state%mt(i),(ieor(state%mt(i-1),ishft(state%mt(i-1),-30_INT64) * 1566083941_INT64))) - i
+            
+            i = i + 1
+            
+            if (i>=N) then
+                state%mt(0) = state%mt(N-1)
+                i = 1
+            end if
+        end do
+
+        state%mt(0) = 1073741824_INT64 ! 0x40000000, assuring non-zero initial array 
+        
+    end subroutine mtprng_init_by_array
+    
+    !--------------------------------------------------------------------------
+    !   Obtain the next 32-bit integer in the psuedo-random sequence
+    function mtprng_rand64(state) result(r)
+    
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+    
+        !return type
+        integer(INT64) :: r
+
+        ! internal constants
+        integer(INT64), dimension(0:1), parameter :: mag01 = (/ 0_INT64, -1727483681_INT64 /)
+
+        ! Period parameters
+        integer(INT64), parameter :: UPPER_MASK =  2147483648_INT64
+        integer(INT64), parameter :: LOWER_MASK =  2147483647_INT64
+
+        ! Tempering parameters
+        integer(INT64), parameter :: TEMPERING_B = -1658038656_INT64
+        integer(INT64), parameter :: TEMPERING_C =  -272236544_INT64
+        
+        ! Note: variable names match those in original example
+        integer(INT32) :: kk
+        
+        ! Generate N words at a time
+        if (state%mti >= N) then
+            ! The value -1 acts as a flag saying that the seed has not been set.
+            if (state%mti == -1) call mtprng_init(4357_INT32,state)
+            
+            ! Fill the mt array
+            do kk = 0, N - M - 1
+                r = ior(iand(state%mt(kk),UPPER_MASK),iand(state%mt(kk+1),LOWER_MASK))
+                state%mt(kk) = ieor(ieor(state%mt(kk + M),ishft(r,-1_INT64)),mag01(iand(r,1_INT64)))
+            end do
+            
+            do kk = N - M, N - 2
+                r = ior(iand(state%mt(kk),UPPER_MASK),iand(state%mt(kk+1),LOWER_MASK))
+                state%mt(kk) = ieor(ieor(state%mt(kk + (M - N)),ishft(r,-1_INT64)),mag01(iand(r,1_INT64)))
+            end do
+            
+            r = ior(iand(state%mt(N-1),UPPER_MASK),iand(state%mt(0),LOWER_MASK))
+            state%mt(N-1) = ieor(ieor(state%mt(M-1),ishft(r,-1)),mag01(iand(r,1_INT64)))
+            
+            ! Start using the array from first element
+            state%mti = 0
+        end if
+        
+        ! Here is where we actually calculate the number with a series of
+        !   transformations 
+        r = state%mt(state%mti)
+        state%mti = state%mti + 1
+        
+        r = ieor(r,ishft(r,-11))
+        r = iand(4294967295_INT64,ieor(r,iand(ishft(r, 7),TEMPERING_B)))
+        r = iand(4294967295_INT64,ieor(r,iand(ishft(r,15),TEMPERING_C)))
+        r = ieor(r,ishft(r,-18))
+        
+    end function mtprng_rand64
+    
+    !--------------------------------------------------------------------------
+    !   Obtain the next 32-bit integer in the psuedo-random sequence
+    function mtprng_rand(state) result(r)
+    
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+    
+        !return type
+        integer(INT32) :: r
+        
+        ! working storage
+        integer(INT64) :: x
+        
+        ! done
+        x = mtprng_rand64(state)
+        
+        if (x > 2147483647_INT64) then
+            r = x - 4294967296_INT64
+        else
+            r = x
+        end if
+        
+    end function mtprng_rand
+    
+    !---------------------------------------------------------------------------
+    !   Obtain a psuedorandom integer in the range [lo,hi]
+    function mtprng_rand_range(state, lo, hi) result(r)
+
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+        integer, intent(in) :: lo
+        integer, intent(in) :: hi
+        
+        ! return type
+        integer(INT32) :: r
+        
+        ! Use real value to caluclate range
+        r = lo + floor((hi - lo + 1.0_IEEE64) * mtprng_rand_real2(state))
+        
+    end function mtprng_rand_range
+
+    !--------------------------------------------------------------------------
+    !   Obtain a psuedorandom real number in the range [0,1], i.e., a number
+    !   greater than or equal to 0 and less than or equal to 1.
+    function mtprng_rand_real1(state) result(r)
+
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+    
+        ! return type
+        real(IEEE64) :: r
+        
+        ! Local constant; precalculated to avoid division below
+        real(IEEE64), parameter :: factor = 1.0_IEEE64 / 4294967295.0_IEEE64
+        
+        ! compute
+        r = real(mtprng_rand64(state),IEEE64) * factor
+        
+    end function mtprng_rand_real1
+
+    !--------------------------------------------------------------------------
+    !   Obtain a psuedorandom real number in the range [0,1), i.e., a number
+    !   greater than or equal to 0 and less than 1.
+    function mtprng_rand_real2(state) result(r)
+
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+    
+        ! return type
+        real(IEEE64) :: r
+        
+        ! Local constant; precalculated to avoid division below
+        real(IEEE64), parameter :: factor = 1.0_IEEE64 / 4294967296.0_IEEE64
+        
+        ! compute
+        r = real(mtprng_rand64(state),IEEE64) * factor
+        
+    end function mtprng_rand_real2
+
+    !--------------------------------------------------------------------------
+    !   Obtain a psuedorandom real number in the range (0,1), i.e., a number
+    !   greater than 0 and less than 1.
+    function mtprng_rand_real3(state) result(r)
+
+        ! arguments
+        type(mtprng_state), intent(inout) :: state
+    
+        ! return type
+        real(IEEE64) :: r
+        
+        ! Local constant; precalculated to avoid division below
+        real(IEEE64), parameter :: factor = 1.0_IEEE64 / 4294967296.0_IEEE64
+        
+        r = (real(mtprng_rand64(state),IEEE64) + 0.5_IEEE64) * factor
+        
+    end function mtprng_rand_real3
+
+end module mtprng
+
+module m_uuid
+  ! Fortran module to generate UUIDs
+  ! Extracted from FoX (work by Toby White and Andrew Walker)
+
+
+  !This generates UUIDs according to RFC 4122
+
+  ! Only types 1 (time-based) and 4 (pseudo-RNG-based) are implemented.
+
+  use mtprng, only : mtprng_state, mtprng_init, mtprng_rand64
+
+  implicit none
+  private
+  
+  integer, parameter :: i4b = selected_int_kind(9)
+  integer, parameter :: i8b = selected_int_kind(18)
+  
+  character, parameter :: hexdigits(0:15) = &
+    (/'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'/)
+  
+  type(mtprng_state), save :: rng_state
+  logical, save :: initialized = .false.
+  integer, save :: values_save ! must be default for date_and_time
+  integer(kind=i4b), save :: hires_count = 0
+
+! clock-seq holds a random number constant for the lifetime of the program
+! using this module. That's the best we can do per S 4.1.5
+  integer, save :: clock_seq = 0
+
+  public :: generate_uuid
+  
+contains
+  
+  function generate_uuid(version) result(uuid)
+    integer, intent(in), optional :: version
+    character(len=36) :: uuid
+
+    integer(kind=i8b) :: timestamp, node
+    integer(kind=i4b) :: clock_sequence
+
+    integer(kind=i4b) :: time_low, time_mid, time_hi_and_version
+    integer(kind=i4b) :: clk_seq_hi_res, clk_seq_low
+
+    integer :: values(8) ! must be default for date_and_time
+    integer(kind=i4b) :: variant, v
+
+
+    if (.not.initialized) then
+      ! Use the current date and time to init mtprng
+      ! but this gives limited varaibility, so mix 
+      ! the result up.  Can we do better? In any
+      ! case, this gets passed through a quick 
+      ! generator inside mtprng_init.
+      call date_and_time(values=values)
+      values(7) = values(7)*1000+values(5)*100+values(3)*10+values(1)
+      values(8) = values(2)*1000+values(4)*100+values(6)*10+values(8)
+      call mtprng_init(int(values(7)*10000+values(8), i4b), rng_state)
+      clock_seq = int(mtprng_rand64(rng_state), i4b)
+      initialized = .true.
+    endif
+
+    variant = 1
+
+    if (present(version)) then
+      v = version
+    else
+      v = 4
+    endif
+
+    select case (v)
+    case (0)
+      ! Nil UUID  - S 4.1.7
+      uuid = repeat('0',8)//'-'//repeat('0',4)//'-'//repeat('0',4)// &
+        '-'//repeat('0',4)//'-'//repeat('0',12)
+      return
+    case(1)
+      call date_and_time(values=values)
+      ! In case of too-frequent requests, we will replace time_low
+      ! with the count below ...
+      if (all(values==values_save)) then
+        hires_count = hires_count + 1
+      else
+        hires_count = 0
+      endif
+    case(2-3)
+      !Unimplemented
+      uuid = ''
+      return
+    case(4)
+      continue
+    case(5)
+      !Unimplemented
+      uuid = ''
+      return
+    case default
+      !Unspecified
+      uuid = ''
+      return
+    end select
+
+!4.1.4 Timestamp
+
+    select case(v)
+    case(1)
+      timestamp = get_utc_since_1582(values)
+    case(4)
+      timestamp = ior(mtprng_rand64(rng_state), ishft(mtprng_rand64(rng_state), 28))
+    end select
+
+!4.1.5 Clock Sequence
+    ! 14 bits
+    select case(v)
+    case(1)
+      clock_sequence = clock_seq
+    case(4)
+      clock_sequence = int(mtprng_rand64(rng_state), i4b)
+    end select
+
+!4.1.6 Node
+    ! 48 bits
+    select case(v)
+    case(1)
+      node = ior(mtprng_rand64(rng_state), ishft(mtprng_rand64(rng_state), 16))
+      ! No MAC address accessible - see section 4.5 !FIXME
+    case(4)
+      node = ior(mtprng_rand64(rng_state), ishft(mtprng_rand64(rng_state), 16))
+    end select
+
+    time_low = ibits(timestamp, 0, 32)
+    time_mid = ibits(timestamp, 32, 16)
+    if (hires_count==0) then
+      time_hi_and_version = ior(int(ibits(timestamp, 48, 12), i4b), ishft(v, 12))
+    else
+      time_hi_and_version = ior(hires_count, ishft(v, 12))
+    endif
+
+    clk_seq_low = ibits(clock_sequence, 0, 8)
+    clk_seq_hi_res = ior(ibits(clock_sequence, 8, 6), ishft(variant, 6))
+
+    uuid = int32ToHexOctets(time_low, 4)//"-"// &
+      int32ToHexOctets(time_mid, 2)//"-"// &
+      int32ToHexOctets(time_hi_and_version, 2)//"-"// & 
+      int32ToHexOctets(clk_seq_hi_res, 1)// &
+      int32ToHexOctets(clk_seq_low, 1)//"-"// &
+      int64ToHexOctets(node, 6)
+
+  contains
+
+    function int32ToHexOctets(b, n) result(s)
+      integer(i4b), intent(in) :: b
+      integer, intent(in) :: n ! number of octets to print
+      character(len=2*n) :: s
+      
+      integer :: i
+      
+      do i = 0, 2*n-1
+        s(2*n-i:2*n-i) = hexdigits(ibits(b, i*4, 4))
+      enddo
+      
+    end function int32ToHexOctets
+    function int64ToHexOctets(b, n) result(s)
+      integer(i8b), intent(in) :: b
+      integer, intent(in) :: n ! number of octets to print
+      character(len=2*n) :: s
+      
+      integer :: i
+      
+      do i = 0, 2*n-1
+        s(2*n-i:2*n-i) = hexdigits(ibits(b, i*4, 4))
+      enddo
+      
+    end function int64ToHexOctets
+
+  end function generate_uuid
+
+  function get_utc_since_1582(values) result(ns)
+    ! This subroutine is a little broken. It only works
+    ! for times after 1/1/2006 and takes no account
+    ! of any future leapseconds. It ought to serve regardless.
+
+    ! It returns the number of 100-ns intervals since 1582-10-15-00-00-00
+
+    integer, dimension(8), intent(in) :: values
+    integer(kind=i8b) :: ns
+
+    integer :: days
+    integer :: years
+
+    integer, parameter :: days_in_normal_year(12) = &
+      (/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)
+
+    ns = 23_i8b * 1000_i8b * 1000_i8b * 10_i8b ! 23 leap seconds until 24:00:00 31/12/2005
+
+    ! A count of the 100-nanosecond intervals since the
+    ! beginning of the day.
+    ns = ns &
+      ! milliseconds
+      + int(values(8), i8b)             * 10_i8b * 1000_i8b &
+      ! seconds
+      + int(values(7), i8b)             * 10_i8b * 1000_i8b * 1000_i8b &
+      ! minutes (with timezone adjustment)
+      + int(values(6) + values(4), i8b) * 10_i8b * 1000_i8b * 1000_i8b * 60_i8b &
+      ! hours
+      + int(values(5), i8b)             * 10_i8b * 1000_i8b * 1000_i8b * 60_i8b * 60_i8b
+
+    ! Number of days this year:
+    days = sum(days_in_normal_year(:values(2)-1))
+    days = days + values(3) - 1 !add days in current month
+    if (values(2)>2 .and. isLeapYear(values(1))) then
+      days = days + 1
+    endif
+    !That's all the time since the turn of this year
+
+    days = days + 78 ! From the start of 15th Oct to the end of 31st Dec in 1582
+    !That's the additional time before the turn of the year 1583
+
+    days = days + 102  ! 102 leap years from 1584 to 2000 inclusive
+    ! That's all the intercalataed days until 2000
+    
+    years = values(1) - 2000 - 1 ! years since 2000 - not including this year
+
+    days = days + years/4 - years/100 + years/400 !Add extra leap days to this total:
+    ! That's all out intercalated days - remaining years are all 365 days long.
+
+    years = years + 418 ! Add the years from 1583-2000 inclusive back on.
+
+    ! Multiply by number of time units in one day & add to today's total.
+    ns = ns + 864000000000_i8b * (int(days,i8b) + 365_i8b * int(years,i8b))
+
+  contains
+    function isLeapYear(y) result(p)
+      integer, intent(in) :: y
+      logical :: p
+      p = (mod(y,4)==0 .and. .not.mod(y,100)==0 .or. mod(y,400)==0)
+    end function isLeapYear
+
+  end function get_utc_since_1582
+
+end module m_uuid
+
+subroutine get_uuid(uuid)
+  use m_uuid, only: generate_uuid
+
+    character(len=36), intent(out) :: uuid
+
+    uuid = generate_uuid(version=1)
+end subroutine get_uuid
diff -Naur oncvpsp-3.2.2/src/modcore.f90 oncvpsp-3.2.2--psml-42/src/modcore.f90
--- oncvpsp-3.2.2/src/modcore.f90	2015-08-07 16:30:16.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/src/modcore.f90	2016-06-30 16:57:17.000000000 +0200
@@ -24,7 +24,7 @@
 ! Teter, Phys. Rev. B 48, 5031 (1993) , Appendix, as 
 
  subroutine modcore(icmod,rhops,rhotps,rhoc,rhoae,rhotae,rhomod, &
-&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, ircc)
 
 !icmod  3 coefficient optimizaion, 4 for specivied fcfact and rfact
 !rhops  state-by-state pseudocharge density
@@ -43,6 +43,7 @@
 !la  angular-momenta
 !zion  ion charge
 !iexc  exchange-correlation function to be used
+!ircc  index of matching point
 
  implicit none
  integer, parameter :: dp=kind(1.0d0)
@@ -57,10 +58,10 @@
 
 !Output variables
  real(dp) :: rhomod(mmax,5)
+ integer  :: ircc            ! Index of matching point
 
 !convergence criterion
  real(dp), parameter :: eps=1.0d-7
-
 !Local variables
  real(dp) :: fcrossover
  real(dp) :: a0,al,et,yy,gg,a0min,a0max,dermax,psum,sf,eeel,eexc
@@ -69,7 +70,7 @@
  real(dp) :: aco(5),polym(5,5),work(5,5),constm(5,5),xpow(9),fmatch(5)
  real(dp), allocatable :: vxcae(:),vxcpsp(:),vo(:),d2excae(:,:),d2excps(:,:)
  real(dp), allocatable :: dvxcae(:,:),dvxcps(:,:),vxct(:)
- integer :: ii,ierr,ircc,irmod,iter,jj,kk,ll,l1,mch
+ integer :: ii,ierr,irmod,iter,jj,kk,ll,l1,mch
  integer :: ipvt(5),nodes(4)
 
 
diff -Naur oncvpsp-3.2.2/src/modcore2.f90 oncvpsp-3.2.2--psml-42/src/modcore2.f90
--- oncvpsp-3.2.2/src/modcore2.f90	2015-08-07 17:05:02.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/src/modcore2.f90	2016-06-30 16:57:17.000000000 +0200
@@ -24,7 +24,7 @@
 ! Teter, Phys. Rev. B 48, 5031 (1993) , Appendix, as 
 
  subroutine modcore2(icmod,rhops,rhotps,rhoc,rhoae,rhotae,rhomod, &
-&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, ircc)
 
 !icmod  3 coefficient optimizaion, 4 for specivied fcfact and rfact
 !rhops  state-by-state pseudocharge density
@@ -43,7 +43,8 @@
 !la  angular-momenta
 !zion  ion charge
 !iexc  exchange-correlation function to be used
-
+!ircc  index of matching point
+   
  implicit none
  integer, parameter :: dp=kind(1.0d0)
 
@@ -57,6 +58,7 @@
 
 !Output variables
  real(dp) :: rhomod(mmax,5)
+ integer  :: ircc            ! Index of matching point
 
 !convergence criterion
  real(dp), parameter :: eps=1.0d-7
@@ -70,7 +72,7 @@
  real(dp) :: fmatch(5)
  real(dp), allocatable :: vxcae(:),vxcpsp(:),vo(:),d2excae(:,:),d2excps(:,:)
  real(dp), allocatable :: dvxcae(:,:),dvxcps(:,:),vxct(:)
- integer :: ii,ierr,ircc,irmod,iter,jj,kk
+ integer :: ii,ierr,irmod,iter,jj,kk
 
  allocate(vxcae(mmax),vxcpsp(mmax),vo(mmax))
  allocate(dvxcae(mmax,nv),dvxcps(mmax,nv),vxct(mmax))
diff -Naur oncvpsp-3.2.2/src/modcore3.f90 oncvpsp-3.2.2--psml-42/src/modcore3.f90
--- oncvpsp-3.2.2/src/modcore3.f90	2015-08-07 17:12:25.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/src/modcore3.f90	2016-06-30 16:57:17.000000000 +0200
@@ -24,7 +24,7 @@
 ! Teter, Phys. Rev. B 48, 5031 (1993) , Appendix, as 
 
  subroutine modcore3(icmod,rhops,rhotps,rhoc,rhoae,rhotae,rhomod, &
-&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&                   fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, ircc)
 
 !icmod  3 coefficient optimizaion, 4 for specivied fcfact and rfact
 !rhops  state-by-state pseudocharge density
@@ -43,6 +43,7 @@
 !la  angular-momenta
 !zion  ion charge
 !iexc  exchange-correlation function to be used
+!ircc  index of matching point
 
  implicit none
  integer, parameter :: dp=kind(1.0d0)
@@ -57,6 +58,7 @@
 
 !Output variables
  real(dp) :: rhomod(mmax,5)
+ integer  :: ircc            ! Index of matching point
 
 !convergence criterion
  real(dp), parameter :: eps=1.0d-7
@@ -69,7 +71,7 @@
  real(dp) :: gg,tt,yy
  real(dp), allocatable :: vxcae(:),vxcpsp(:),vo(:),d2excae(:,:),d2excps(:,:)
  real(dp), allocatable :: dvxcae(:,:),dvxcps(:,:),vxct(:)
- integer :: ii,ierr,ircc,ircross,irmod,iter,jj,kk
+ integer :: ii,ierr,ircross,irmod,iter,jj,kk
 
 !2-dimensional Nelder-Mead variables
  real(dp), parameter :: alpha_nm=1.0d0
diff -Naur oncvpsp-3.2.2/src/oncvpsp.f90 oncvpsp-3.2.2--psml-42/src/oncvpsp.f90
--- oncvpsp-3.2.2/src/oncvpsp.f90	2015-08-07 22:13:17.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/src/oncvpsp.f90	2016-06-30 16:57:17.000000000 +0200
@@ -32,6 +32,8 @@
 !
 !   Output format for ABINIT pspcod=8
 !
+ use m_psmlout, only: psmlout, copy_input_file_for_psml
+
  implicit none
  integer, parameter :: dp=kind(1.0d0)
 
@@ -39,6 +41,7 @@
  integer :: ii,ierr,iexc,iexct,ios,iprint,irps,it,icmod,lpopt
  integer :: jj,kk,ll,l1,lloc,lmax,lt,inline
  integer :: mch,mchf,mmax,n1,n2,nc,nlim,nlloc,nlmax,irpsh,nrl
+ integer :: nrl0
  integer :: nv,irct,ncnf
 !
  integer :: dtime(8),na(30),la(30),np(6)
@@ -83,6 +86,7 @@
  write(6,'(a/a//)') &
 &      'ONCVPSP  (Optimized Norm-Conservinng Vanderbilt PSeudopotential)', &
 &      'scalar-relativistic version 3.2.2 08/07/2015'
+ include 'psml-version.info'
 
  write(6,'(a/a/a//)') &
 &      'While it is not required under the terms of the GNU GPL, it is',&
@@ -96,6 +100,7 @@
  rcfact=0.0d0
 
 ! read input data
+ call copy_input_file_for_psml()
  inline=0
 
 ! atom and reference configuration
@@ -195,6 +200,7 @@
 &                ncnf,na,la,nvcnf,nacnf,lacnf,ncon,nbas,nproj,psfile)
 
  nrl=int((rlmax/drl)-0.5d0)+1
+ nrl0 = nrl
 
 !PWSCF wants an even number of mesh pointe
  if(trim(psfile)=='upf') then
@@ -510,15 +516,15 @@
 
  if(icmod==1) then
    call modcore(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod==2) then
    call modcore2(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod>=3) then
    call modcore3(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
 !   call modcore3(icmod,rho,rhoc,rhomod,fcfact,rcfact,mmax,rr, &
 !&                na,la,ea,fa,nc,nv,iexc,zz,vfull,srel, &
@@ -542,6 +548,13 @@
  do l1=1,max(lmax+1,lloc+1)
    vpuns(:,l1)=vp(:,l1)-vo(:)
  end do
+ write(66,"(a)") "# screening potential"
+ do ii = 1, mmax
+    write(66,"(2es24.16)") rr(ii), vo(ii)
+ enddo
+
+
+
 
 ! fix unscreening error due to greater range of all-electron charge
  do ii=mmax,1,-1
@@ -606,6 +619,15 @@
 &             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
 &             epsh1,epsh2,depsh,rlmax,psfile, uua,eacopy)
  end if
+!
+! Write info for PSML format
+!
+ call psmlout(lmax,lloc,rc,vkb,evkb,nproj,rr,vpuns,rho,rhomod, &
+&             irct, srel, &
+&             zz,zion,mmax,iexc,icmod,nrl0,drl,atsym,epstot, &
+&             na,la,ncon,nbas,nvcnf,nacnf,lacnf,nc,nv,lpopt,ncnf, &
+&             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
+&             epsh1,epsh2,depsh,rlmax,psfile,uua)
 
  stop
  end program oncvpsp
diff -Naur oncvpsp-3.2.2/src/oncvpsp_nr.f90 oncvpsp-3.2.2--psml-42/src/oncvpsp_nr.f90
--- oncvpsp-3.2.2/src/oncvpsp_nr.f90	2015-08-07 22:13:28.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/src/oncvpsp_nr.f90	2016-06-30 16:57:17.000000000 +0200
@@ -32,6 +32,8 @@
 !
 !   Output format for ABINIT pspcod=8
 !
+ use m_psmlout, only: psmlout, copy_input_file_for_psml
+
  implicit none
  integer, parameter :: dp=kind(1.0d0)
 
@@ -39,6 +41,7 @@
  integer :: ii,ierr,iexc,iexct,ios,iprint,irps,it,icmod,lpopt
  integer :: jj,kk,ll,l1,lloc,lmax,lt,inline
  integer :: mch,mchf,mmax,n1,n2,nc,nlim,nlloc,nlmax,irpsh,nrl
+ integer :: nrl0
  integer :: nv,irct,ncnf
 !
  integer :: dtime(8),na(30),la(30),np(6)
@@ -83,6 +86,7 @@
  write(6,'(a/a//)') &
 &      'ONCVPSP  (Optimized Norm-Conservinng Vanderbilt PSeudopotential)', &
 &      'non-relativistic version 3.2.2 08/07/2015'
+ include 'psml-version.info'
 
  write(6,'(a/a/a//)') &
 &      'While it is not required under the terms of the GNU GPL, it is',&
@@ -96,6 +100,7 @@
  rcfact=0.0d0
 
 ! read input data
+ call copy_input_file_for_psml()
  inline=0
 
 ! atom and reference configuration
@@ -195,6 +200,7 @@
 &                ncnf,na,la,nvcnf,nacnf,lacnf,ncon,nbas,nproj,psfile)
 
  nrl=int((rlmax/drl)-0.5d0)+1
+ nrl0 = nrl
 
 !PWSCF wants an even number of mesh pointe
  if(trim(psfile)=='upf') then
@@ -510,15 +516,15 @@
 
  if(icmod==1) then
    call modcore(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod==2) then
    call modcore2(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod>=3) then
    call modcore3(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
 !   call modcore3(icmod,rho,rhoc,rhomod,fcfact,rcfact,mmax,rr, &
 !&                na,la,ea,fa,nc,nv,iexc,zz,vfull,srel, &
@@ -606,6 +612,16 @@
 &             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
 &             epsh1,epsh2,depsh,rlmax,psfile, uua,eacopy)
  end if
+!
+! Write info for PSML format
+!
+ call psmlout(lmax,lloc,rc,vkb,evkb,nproj,rr,vpuns,rho,rhomod, &
+&             irct, srel, &
+&             zz,zion,mmax,iexc,icmod,nrl0,drl,atsym,epstot, &
+&             na,la,ncon,nbas,nvcnf,nacnf,lacnf,nc,nv,lpopt,ncnf, &
+&             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
+&             epsh1,epsh2,depsh,rlmax,psfile,uua)
+
 
  stop
  end program oncvpsp
diff -Naur oncvpsp-3.2.2/src/oncvpsp_r.f90 oncvpsp-3.2.2--psml-42/src/oncvpsp_r.f90
--- oncvpsp-3.2.2/src/oncvpsp_r.f90	2015-08-07 22:13:48.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/src/oncvpsp_r.f90	2016-06-30 16:57:17.000000000 +0200
@@ -33,6 +33,8 @@
 !
 !   Output format for ABINIT pspcod=8
 !
+ use m_psmlout, only: psmlout_r, copy_input_file_for_psml
+
  implicit none
  integer, parameter :: dp=kind(1.0d0)
 
@@ -40,6 +42,7 @@
  integer :: ii,ierr,iexc,iexct,ios,iprint,irps,it,icmod,lpopt
  integer :: jj,kk,ll,l1,lloc,lmax,lt,inline
  integer :: mch,mchf,mmax,n1,n2,nc,nlim,nlloc,nlmax,irpsh,nrl
+ integer :: nrl0
  integer :: nv,irct,ncnf
  integer :: ikap,kap,mkap
 !
@@ -78,6 +81,7 @@
  real(dp), allocatable :: rhomod(:,:),rhoae(:,:),rhops(:,:),rhotae(:)
  real(dp), allocatable :: uua(:,:,:), uuatmp(:,:,:)
  real(dp), allocatable :: vsr(:,:,:),vso(:,:,:),vpsr(:,:)
+ real(dp), allocatable :: vpsml(:,:,:)
 
 
  character*2 :: atsym
@@ -88,6 +92,7 @@
  write(6,'(a/a//)') &
 &      'ONCVPSP  (Optimized Norm-Conservinng Vanderbilt PSeudopotential)', &
 &      'fully-relativistic version 3.2.2 08/07/2015'
+ include 'psml-version.info'
 
  write(6,'(a,a,a,a//)') &
 &      'While it is not required under the terms of the GNU GPL, it is',&
@@ -98,6 +103,7 @@
  nproj(:)=0
 
 ! read input data
+ call copy_input_file_for_psml()
  inline=0
 
 ! atom and reference configuration
@@ -200,6 +206,7 @@
 &                ncnf,na,la,nvcnf,nacnf,lacnf,ncon,nbas,nproj,psfile)
 
  nrl=int((rlmax/drl)-0.5d0)+1
+ nrl0 = nrl
 
 !PWSCF wants an even number of mesh pointe
  if(trim(psfile)=='upf') then
@@ -566,7 +573,9 @@
 ! for abinit output, need decomposition into scalar-relativistic and
 ! spin-orbit projectors
 
- if(trim(psfile)=='psp8') then
+! Do it unconditionally, so that PSML has all the information
+  if (.true.) then
+! if(trim(psfile)=='psp8') then
   call sr_so_r(lmax,irc,nproj,rr,mmax,evkb,vkb, &
 &              vsr,esr,vso,eso)
 
@@ -594,15 +603,15 @@
 
  if(icmod==1) then
    call modcore(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod==2) then
    call modcore2(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  else if(icmod>=3) then
    call modcore3(icmod,rhops,rho,rhoc,rhoae,rhotae,rhomod, &
-&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc)
+&               fcfact,rcfact,irps,mmax,rr,nc,nv,la,zion,iexc, irct)
 
  end if
 
@@ -629,6 +638,14 @@
 
  end if
 
+! save full info for psml 
+ allocate(vpsml(mmax,5,2))
+ do l1=1,max(lmax+1,lloc+1)
+    ll=l1-1
+    vpsml(:,l1,1) = vp(:,l1,1) - vo(:)
+    vpsml(:,l1,2) = vp(:,l1,2) - vo(:)
+ end do
+
 ! unscreen semi-local potentials taking scalar-relativistic average
 
  do l1=1,max(lmax+1,lloc+1)
@@ -711,6 +728,14 @@
 &             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
 &             epsh1,epsh2,depsh,rlmax,psfile, uua,eacopy)
  end if
+!
+  call psmlout_r(lmax,lloc,rc,vkb,evkb,nproj,rr,vpsml,rho,rhomod, &
+&             irct, &
+&             vsr,esr,vso,eso, &
+&             zz,zion,mmax,iexc,icmod,nrl0,drl,atsym,epstot, &
+&             na,la,ncon,nbas,nvcnf,nacnf,lacnf,nc,nv,lpopt,ncnf, &
+&             fa,rc0,ep,qcut,debl,facnf,dvloc0,fcfact, &
+&             epsh1,epsh2,depsh,rlmax,psfile,uua)
 
  stop
  end program oncvpsp_r
diff -Naur oncvpsp-3.2.2/src/psml-version.info oncvpsp-3.2.2--psml-42/src/psml-version.info
--- oncvpsp-3.2.2/src/psml-version.info	1970-01-01 01:00:00.000000000 +0100
+++ oncvpsp-3.2.2--psml-42/src/psml-version.info	2016-06-30 16:57:17.000000000 +0200
@@ -0,0 +1 @@
+ write(6,'(a/)') ' PSML module, patch level 42'
diff -Naur oncvpsp-3.2.2/src/vploc.f90 oncvpsp-3.2.2--psml-42/src/vploc.f90
--- oncvpsp-3.2.2/src/vploc.f90	2015-08-06 16:05:26.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/src/vploc.f90	2016-06-30 16:57:17.000000000 +0200
@@ -111,6 +111,7 @@
 
 ! create polynomial potential inside irc
 
+ write(55,"(a,/,4(es24.16,/))") "Vlocal coeffs:", aco, bco, cco, dco
 
  if(lpopt .eq. 1) then
    do ii=1,irc
diff -Naur oncvpsp-3.2.2/tests/extract.sh oncvpsp-3.2.2--psml-42/tests/extract.sh
--- oncvpsp-3.2.2/tests/extract.sh	2015-08-06 16:05:26.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/tests/extract.sh	2016-06-30 16:57:17.000000000 +0200
@@ -13,7 +13,7 @@
 
 if [ "$STR1" ]
 	then
-	PSPFILE=~/$2/$1.oncvpsp.psp8
+	PSPFILE=$1.oncvpsp.psp8
 
 	awk 'BEGIN{out=0};{if(out == 1) {print}};/PSPCODE8/{out=1}' \
 		$OUTFILE >$PSPFILE
@@ -23,7 +23,7 @@
 
 if [ "$STR2" ]
 	then
-	PSPFILE=~/$2/$1.oncvpsp.upf
+	PSPFILE=$1.oncvpsp.upf
 
 	awk 'BEGIN{out=0};{if(out == 1) {print}};/PSP_UPF/{out=1}' \
 		$OUTFILE >$PSPFILE
diff -Naur oncvpsp-3.2.2/tests/pg.sh oncvpsp-3.2.2--psml-42/tests/pg.sh
--- oncvpsp-3.2.2/tests/pg.sh	1970-01-01 01:00:00.000000000 +0100
+++ oncvpsp-3.2.2--psml-42/tests/pg.sh	2016-06-30 16:57:17.000000000 +0200
@@ -0,0 +1,42 @@
+#!/bin/sh
+#runs ONCVPSP with the command-line argument <prefix> and the graphics
+#which review the results
+#uses the scalar-relativistic all-electron atom calculation
+
+name=$1
+dir=$name.$$
+mkdir $dir; 
+
+INFILE=$1.dat
+cp -p $INFILE $dir
+cd $dir
+
+OUTFILE=$1.out
+PSMLFILE=$1.psml
+
+GNUFILE=$1.scr
+
+PLOTFILE=$1.plot
+
+TEMP=$$.tmp
+
+${ONCVPSP_BIN}/oncvpsp.x <$INFILE >$OUTFILE  #Edit if your executable is
+                                            #in another directory
+
+awk 'BEGIN{out=0};/GNUSCRIPT/{out=0}; {if(out == 1) {print}};\
+	/DATA FOR PLOTTING/{out=1}' $OUTFILE >$PLOTFILE
+
+awk 'BEGIN{out=0};/END_GNU/{out=0}; {if(out == 1) {print}};\
+	/GNUSCRIPT/{out=1}' $OUTFILE >$TEMP
+
+sed -e 1,1000s/t1/$PLOTFILE/ $TEMP >$GNUFILE
+
+mv ONCVPSPPSML $PSMLFILE
+
+##gnuplot $GNUFILE
+
+rm  $TEMP $PLOTFILE
+
+cd ..
+echo "Results in $dir"
+
diff -Naur oncvpsp-3.2.2/tests/run.sh oncvpsp-3.2.2--psml-42/tests/run.sh
--- oncvpsp-3.2.2/tests/run.sh	2015-08-11 23:58:01.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/tests/run.sh	2016-06-30 16:57:17.000000000 +0200
@@ -3,19 +3,19 @@
 #which review the results
 #uses the scalar-relativistic all-electron atom calculation
 
-PREFIX=/home/drh/oncvpsp-3.2.2
 
 INFILE=$1.dat
 
 OUTFILE=$1.out
+PSMLFILE=$1.psml
 
-GNUFILE=$$.scr
+GNUFILE=$1.scr
 
 PLOTFILE=$1.plot
 
 TEMP=$$.tmp
 
-$PREFIX/src/oncvpsp.x <$INFILE >$OUTFILE  #Edit if your executable is
+${ONCVPSP_BIN}/oncvpsp.x <$INFILE >$OUTFILE  #Edit if your executable is
                                             #in another directory
 
 awk 'BEGIN{out=0};/GNUSCRIPT/{out=0}; {if(out == 1) {print}};\
@@ -26,9 +26,12 @@
 
 sed -e 1,1000s/t1/$PLOTFILE/ $TEMP >$GNUFILE
 
+mv ONCVPSPPSML $PSMLFILE
 if [ "$2" != "-np" ]
 then
 	gnuplot $GNUFILE
 fi
 
-rm  $GNUFILE $TEMP $PLOTFILE
+##gnuplot $GNUFILE
+
+rm  $TEMP $PLOTFILE
diff -Naur oncvpsp-3.2.2/tests/run_nr.sh oncvpsp-3.2.2--psml-42/tests/run_nr.sh
--- oncvpsp-3.2.2/tests/run_nr.sh	2015-08-11 23:58:01.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/tests/run_nr.sh	2016-06-30 16:57:17.000000000 +0200
@@ -3,19 +3,18 @@
 #which review the results
 #uses the non-relativistic all-electron atom calculation
 
-PREFIX=/home/drh/oncvpsp-3.2.2
-
 INFILE=$1.dat
 
 OUTFILE=$1_nr.out
+PSMLFILE=$1_nr.psml
 
-GNUFILE=$$.scr
+GNUFILE=$$_nr.scr
 
 PLOTFILE=$1.plot
 
 TEMP=$$.tmp
 
-$PREFIX/src/oncvpspnr.x <$INFILE >$OUTFILE
+${ONCVPSP_BIN}/oncvpspnr.x <$INFILE >$OUTFILE
 
 awk 'BEGIN{out=0};/GNUSCRIPT/{out=0}; {if(out == 1) {print}};\
 	/DATA FOR PLOTTING/{out=1}' $OUTFILE >$PLOTFILE
@@ -25,10 +24,12 @@
 
 sed -e 1,1000s/t1/$PLOTFILE/ $TEMP >$GNUFILE
 
-
+#mv ONCVPSPPSML $PSMLFILE
 if [ "$2" != "-np" ]
 then
 	gnuplot $GNUFILE
 fi
 
-rm  $GNUFILE $TEMP $PLOTFILE
+#gnuplot $GNUFILE
+
+rm  $TEMP $PLOTFILE
diff -Naur oncvpsp-3.2.2/tests/run_r.sh oncvpsp-3.2.2--psml-42/tests/run_r.sh
--- oncvpsp-3.2.2/tests/run_r.sh	2015-08-11 23:58:01.000000000 +0200
+++ oncvpsp-3.2.2--psml-42/tests/run_r.sh	2016-06-30 16:57:17.000000000 +0200
@@ -4,19 +4,18 @@
 #_r is appended to the prefix of the output file
 #uses the fully-relativistic all-electron atom calculation
 
-PREFIX=/home/drh/oncvpsp-3.2.2
-
 INFILE=$1.dat
 
 OUTFILE=$1_r.out
+PSMLFILE=$1_r.psml
 
-GNUFILE=$$.scr
+GNUFILE=$1_r.scr
 
 PLOTFILE=$1.plot
 
 TEMP=$$.tmp
 
-$PREFIX/src/oncvpspr.x <$INFILE >$OUTFILE  #Edit if your executable is
+${ONCVPSP_BIN}/oncvpspr.x <$INFILE >$OUTFILE  #Edit if your executable is
                                             #in another directory
 
 awk 'BEGIN{out=0};/GNUSCRIPT/{out=0}; {if(out == 1) {print}};\
@@ -27,9 +26,11 @@
 
 sed -e 1,1000s/t1/$PLOTFILE/ $TEMP >$GNUFILE
 
+mv ONCVPSPPSML $PSMLFILE
+##gnuplot $GNUFILE
 if [ "$2" != "-np" ]
 then
 	gnuplot $GNUFILE
 fi
 
-rm  $GNUFILE $TEMP $PLOTFILE
+rm  $TEMP $PLOTFILE
